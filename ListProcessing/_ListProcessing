/*===================================================================================
 |              SAS List Processing Utility Macros
 |
 |    Author:  see individual snippets
 | Collector:  Jiangtang Hu (Jiangtanghu.com)
 |  Archived:  https://github.com/Jiangtang/Programming-SAS/tree/master/ListProcessing
 |
 +-------List Creating---------------------------------------------------------------
 |
 | %range:          produces a sequence like 1 2 3 or f1 f2 f3 or 1a 2a 3a
 | %range_non_int:  increment a macro do loop by a non-integer value
 | %suffix_counter: Create a list of variable names formed by adding a numeric counter suffix to a base name.
 |
 | %getVar: get all variables (N, C or all) from a dataset
 |
 | %qreadpipe: read the output of a system command
 | %dir:       return a list of members of a directory
 | %dirfpq:    return a list of full-path quoted members of a directory
 |
 |
 +-------List Formating---------------------------------------------------------------
 |
 | %changesep: change the separator for a list
 | %seplist:   Emit a list of items separated by some delimiter
 |
 | %splitmac: insert split characters in a macro string
 |
 | %capmac:  capitalise the first letter of each  word in a macro string
 |
 +-------quoting---------------------------------------------------------------
 |
 | %qt:        add quotes to each element in a list
 | %quotelst:  quote the elements of a list
 |
 | %upt:       remove quotes from each element of a list
 | %qdequote:  remove front and end matching quotes from a macro string
 | %dequote:   remove front and end matching quotes from a macro string
 |
 | %noquotes:  remove all quoted strings from a macro expression
 |
 | %quotecnt:  count quoted strings in a macro expression
 |
 | %quotescan: scan for a quoted string in a macro   expression
 |
 |
 +-------List Properties-----------------------------------------------------------
 |
 | %num_tokens: Count the number of â€œtokensâ€ (variables) in a list.
 | %countW:     Retrieve the number of words in a macro variable
 | %words:      return the number of words in a string
 | %windex:     return the word count position in a string
 |
 |
 |
 |
 +-------List Manipulation-----------------------------------------------------------
 |
 | %slice:  return a sub-list sliced by a index
 |
 |
 | %zip:           zips two lists together by joining correponding elements, see, a b and c d ==> ac bd
 | %parallel_join: Join two variable lists by connecting each variable in the first list to its correspondingvariable in the second list
 | %add_string:    Add a text string to each variable in a list as either a prefix or suffix
 | %xprod:         take cross product of two lists, see, a b and c d ==> ac ad bc bd
 |
 | %appmvar: append a string onto an existing macro variable
 | %prefix:  return a list with a prefix added
 | %suffix:  return a list with a suffix added
 |
 |
 |
 |
 | %replace:       replace symbolic variable in block of code with each element of a list, see, a b and code = #=__#  ==> a=__a b=__b
 | %rename_string: Create a list suitable for the rename statement
 | %editlist:      edit a list of space delimited items
 |
 | %nodup:  drop duplicates in a space-delimited list
 |
 | %match:  return elements of a list that match those in a reference list
 |
 | %remove:  remove all occurrences of the target string(s) from another string
 | %removew: remove all occurrences of the target word(s) from a source list of words.
 |
 | %reverse:  Reverse a macro variable's value (use %sysfunc(reverse) since v6.12)
 |
 |
 |
 +==================================================================================*/
/*%add_string 
    Purpose: Add a text string to each variable in a list as either a prefix or suffix.
    dependence: %num_tokens

    Required arguments: 
        words – the variable list 
        str – the text string to add to each variable in the &words list 

    Optional arguments: 
        location – whether to add the text string as a prefix or suffix [prefix|suffix, default: suffix] 
        delim – the character(s) separating each variable in the &words list [default: space] 

    Examples: 
        %put  %add_string(a b c, _max); *produces the text a_max b_max c_max;            
        %put %add_string(a b c, max_, location=prefix);     *produces the text max_a max_b max_c;            
        %put %add_string(%str(a,b,c), _max, delim=%str(,)); *produces the text a_max,b_max,c_max;

    Credit:
        source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
          (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf           

*/


%macro add_string(words, str, delim=%str( ), location=suffix); 
    %local outstr i word num_words; 

    %* Verify macro arguments. ; 
    %if (%length(&words) eq 0) %then %do; 
        %put ***ERROR(add_string): Required argument 'words' is missing.; 
        %goto exit; 
    %end; 
    %if (%length(&str) eq 0) %then %do; 
        %put ***ERROR(add_string): Required argument 'str' is missing.; 
        %goto exit; 
    %end; 
    %if (%upcase(&location) ne SUFFIX and %upcase(&location) ne PREFIX) %then %do; 
        %put ***ERROR(add_string): Optional argument 'location' must be; 
        %put *** set to SUFFIX or PREFIX.; 
        %goto exit; 
    %end; 

    %* Build the outstr by looping through the words list and adding the 
    * requested string onto each word. ; 
    %let outstr = ; 
    %let num_words = %num_tokens(&words, delim=&delim); 
    %do i=1 %to &num_words; 
        %let word = %scan(&words, &i, &delim); 
        %if (&i eq 1) %then %do; 
            %if (%upcase(&location) eq PREFIX) %then %do; 
                %let outstr = &str&word; 
            %end; 
            %else %do; 
                %let outstr = &word&str; 
            %end; 
        %end; 
        %else %do; 
            %if (%upcase(&location) eq PREFIX) %then %do; 
                %let outstr = &outstr&delim&str&word; 
            %end; 
            %else %do; 
                %let outstr = &outstr&delim&word&str; 
            %end; 
        %end; 
    %end; 
    %* Output the new list of words. ; 
    &outstr 
    %exit: 
%mend add_string; 
/*<pre><b>
/ Program   : appmvar.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 23-Aug-2012
/ Purpose   : Function-style macro to append a string onto an existing macro
/             variable.
/ SubMacros : none
/ Notes     : This macro has very limited functionality and was written to make
/             your code less messy. It is where you are accumulating messages in
/             a macro variable and when you append onto the end of it you want
/             there to be a separating string to delimit the different messages
/             such as using %str(; ). This macro takes care of the logic of
/             checking what is already there and what you want to add and will
/             only use the separating string if the macro variable being
/             appended onto has contents as well as the string you are appending
/             is non-empty.
/ Usage     : %let err_msg=%appmvar(err_msg,This is another error message);
/             %let err_msg=%appmvar(err_msg,
/             Add this comma-delimited list (%nrbquote(&list)));
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ mvar              (pos) Name of macro variable to append onto
/ append            (pos) String to append
/ sep=%str(; )      Separating string (defaults to "; ")
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  23Aug12         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: appmvar v1.0;

%macro appmvar(mvar,append,sep=%str(; ));
  %if %length(&&&mvar) and %length(&append) %then %do;
&&&mvar&sep&append
  %end;
  %else %if %length(&append) %then %do;
&append
  %end;
  %else %do;
&&&mvar
  %end;
%mend appmvar;

/*<pre><b>
/ Program      : capmac.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date         : 11-Jan-2013
/ Purpose      : Function-style macro to capitalise the first letter of each
/                word in a macro string.
/ SubMacros    : %words %quotelst (%qlowcase from SI supplied autocall library
/                is called so this must be on the sasautos path).
/ Notes        : You can specify words to ignore. Case must match for these.
/                If the string you supply might contain commas or unbalanced
/                quotes then you should use %nrbquote() around it. See usage.
/ Usage        : %let tidy=%capmac(%nrbquote(A, B AND C'S RESULTS));
/                %put %capmac(%bquote(A, B AND C'S RESULTS)); 
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos) Macro string to convert
/ ignore            List of strings (separated by spaces) to ignore
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/ rrb  11Jan13         Header tidy. %lowcase removed from submacro list and
/                      use of %qlowcase documented. %nrbquote() recommended in
/                      place of %bquote() in Notes and Usage. Version number
/                      unchanged as no change made to the macro code (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: capmac v1.0;

%macro capmac(string,ignore=);

  %local i igquote bit words;

  %if %length(&ignore) %then %let igquote=%quotelst(&ignore);
  %let words=%words(&string);

  %do i=1 %to &words;
    %let bit=%qscan(&string,&i,%str( ));
    %if %length(&ignore) %then %do;
      %if %index(&igquote,"%bquote(&bit)") %then %do;
&bit
        %goto done;
      %end;
    %end;
    %let bit=%qlowcase(&bit);
  
    %*- One character word -;
    %if %length(&bit) EQ 1 %then %do;
      %if &i EQ 1 %then %do;
%qupcase(&bit)
      %end;
      %else %if "%bquote(&bit)" EQ "a" %then %do;
a
      %end;
      %else %do;
%qupcase(&bit)
      %end;
     %end;
  
    %*- Longer than one character word -;
    %else %do;
      %*- always capitalise the first word -;
      %if &i EQ 1 %then %do;
%qupcase(%substr(&bit,1,1))%qsubstr(&bit,2)
      %end;
      %*- leave join words as lower text if not the last word -;
      %else %if %index("an" "and" "as" "at" "but" "by" "for" "in" "is" "it" "of"
                       "on" "or" "so" "that" "the" "to" "when" "with",
        "%bquote(&bit)") and (&i LT &words) %then %do;
&bit
      %end;
      %*- all other cases -;
      %else %do;
%qupcase(%substr(&bit,1,1))%qsubstr(&bit,2)
      %end;
    %end;
  
  %done:
  %end;

%mend capmac;
%macro changesep(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , osep=%str(,) /* separator for rteurned list */
     ) ;
 
 /* L (or &LV) is list of quoted items separated by LSEP
 return unquoted list of items separated by OSEP
 LV provides override to specify external variable name instead list.
 If the LV option is used then L and CHG_: should be avoided for variable names.

 examples:
    %put %changesep ( l=a b c, lv= , lsep= %str( ), osep=%str(,) );

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local chg_list ;
 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %length(%superq(&lv)) > 0 %then
 %do ;
     %if %superq(osep)= %str( ) %then
     %do ;
         %let chg_list = %qsysfunc(strip(%superq(&lv))) ;
         %let chg_list = %qsysfunc(compbl(&chg_list)) ;
     %end ;
     %else
     %let chg_list = %superq(&lv) ;
     %let chg_list = %qsysfunc(translate(&chg_list,&osep,&lsep)) ;
 %end ;
 %unquote(&chg_list)
%mend changesep ;
/*Retrieving the number of words in a macro variable*/
/* valid in SAS 9.1 and above. */

/*
http://support.sas.com/kb/26/152.html
*/

%macro countw(L);
    %let countw=%sysfunc(countw(&L));
    %eval(&countw);
%mend countw;


/*example

%put %countw(e 5 5);

*/

/*<pre><b>
/ Program      : dequote.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date         : 04-May-2011
/ Purpose      : Function-style macro to remove front and end matching quotes
/                from a macro string and return the result.
/ SubMacros    : %qdequote
/ Notes        : This is a function-style macro that calls %qdequote and uses
/                %unquote to remove the macro quoting so that you can use it in
/                ordinary sas code.
/ Usage        : %let str=%dequote(%qreadpipe(echo '%username%'));
/                %put  %dequote(%qreadpipe(echo '%username%')); 
/                
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) Macro string to dequote
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dequote v1.0;

%macro dequote(str);
%unquote(%qdequote(&str))
%mend dequote;


/*<pre><b>
/ Program   : dir.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 26-Jun-2011
/ Purpose   : Function-style macro to return a list of members of a directory
/             on a WINDOWS platform according to the file pattern you supply.
/             If you supply just the directory name then all members are
/             listed. This runs the MSDOS command in the form "dir /B mydir"
/ SubMacros : %qreadpipe
/ Notes     : Just the file names are returned unquoted. If you need the full
/             path name in double quotes then use the %dirfpq macro instead
/             which will correctly handle file names containing spaces.
/ Usage     : %let dirlist=%dir(C:\utilmacros);
/             %let dirlist=%dir(C:\utilmacros\*.sas);
/             %put dirlist=%dir(a:\test);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dir               (pos) Directory path name (no quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jun11         Remove quotes if supplied (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dir v1.1;

%macro dir(dir);
  %unquote(%qreadpipe(dir /B %sysfunc(dequote(&dir))))
%mend dir;

/*<pre><b>
/ Program   : dirfpq.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 26-Jun-2011
/ Purpose   : Function-style macro to return a list of full-path quoted members
/             of a directory on a Windows platform according to the file pattern
/             you supply.
/ SubMacros : %qreadpipe
/ Notes     : Members are shown with the full path names in double quotes. If a
/             file name contains spaces then this will be correctly quoted. You
/             MUST give the full file pattern and not just the directory as this
/             does not use the DIR command to act on the directory but rather
/             expands the file pattern.
/ Usage     : %let dirlist=%dirfpq(C:\utilmacros);     %*- NO GOOD -;
/             %let dirlist=%dirfpq(C:\utilmacros\*);      %*- GOOD -;
/             %let dirlist=%dirfpq(C:\utilmacros\*.sas);  %*- GOOD -;
/             %put %dirfpq(a:\test\*.gif);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dir               (pos) Directory path name with file pattern (no quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jun11         Remove quotes if supplied (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dirfpq v1.1;

%macro dirfpq(dir);
%unquote(%qreadpipe(echo off & for %nrstr(%f) in (%sysfunc(dequote(&dir))) do echo "%nrstr(%f)"))
%mend dirfpq;

 
/*<pre><b>
/ Program   : editlist.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 01-Nov-2012
/ Purpose   : Function-style macro to allow you to edit a list of space 
/             delimited items.
/ SubMacros : none
/ Notes     : This macro is for tasks like generating rename statements where a
/             repeat of items in a list is required (see usage notes). The edit
/             string must be enclosed in single quotes. Elements of the list
/             are written to the macro variable "item" which can be referenced
/             in the edit string. If semicolons form part of the edit string
/             then for certain uses these can be protected using %nrstr().
/
/             If used in sas code you might need to %unquote() the final string.
/
/             This macro is essentially the same as the %doallitem macro but
/             giving a different usage emphasis and with no submacros.
/
/ Usage     : %put >>> %editlist(aa bb cc dd,'&item=mr_&item');
/             %put >>> %editlist(xx_aa xx_bb xx_cc,
/             '&item=%substr(&item,4)');
/             %put >>> %editlist(xx_aa xx_bb xx_cc,
/             '%substr(&item,4)=&item%nrbquote(;)');
/
/             (will write to log:)
/             >>> aa=mr_aa bb=mr_bb cc=mr_cc dd=mr_dd
/             >>> xx_aa=aa xx_bb=bb xx_cc=cc
/             >>> aa=xx_aa; bb=xx_bb; cc=xx_cc;
/             %put >>> %editlist(aa bb cc dd,'&item=mr_&item');
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ list              (pos) List of space delimited items
/ editstr           (pos) Edit string (in single quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  31Oct12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: editlist v1.0;

%macro editlist(list,editstr);
  %local i item;
  %let i=1;
  %let item=%scan(&list,&i,%str( ));
  %do %while(%length(&item));
%sysfunc(dequote(&editstr))
    %let i=%eval(&i + 1);
    %let item=%scan(&list,&i,%str( ));
  %end;
%mend editlist;
/*
Purpose: return the list of variables in a data set

Examples:
    %put %getVar(%str(sashelp.class));
    %put %getVar(%str(sashelp.class),n);
    %put %getVar(%str(sashelp.class),N);
    %put %getVar(%str(sashelp.class),c);
    %put %getVar(%str(sashelp.class),C);

Credits:
    Source code by Arthur Carpenter, Storing and Using a List of Values in a Macro Variable
         http://www2.sas.com/proceedings/sugi30/028-30.pdf
    Authored by Michael Bramley
    Jiangtang Hu (2013, Jiangtanghu.com) adds variable type (N, C) options.
*/


%macro getVar(dset,type) ; 
   %local varlist ; 
    %let fid = %sysfunc(open(&dset)) ; 
    %if &fid %then %do ; 
        %do i=1 %to %sysfunc(attrn(&fid,nvars)) ; 
            %if %upcase(&type) = N %then %do;
                %if %sysfunc(vartype(&fid,&i)) = N %then
                    %let varlist= &varlist %sysfunc(varname(&fid,&i));
            %end;
            %else %if %upcase(&type) = C %then %do;
                %if %sysfunc(vartype(&fid,&i)) = C %then
                    %let varlist= &varlist %sysfunc(varname(&fid,&i));
            %end;
            %else
                %let varlist= &varlist %sysfunc(varname(&fid,&i)); 
        %end ; 
        %let fid = %sysfunc(close(&fid)) ; 
    %end ; 
    &varlist 
%mend getVar ;


/*<pre><b>
/ Program   : match.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 03-Dec-2012
/ Purpose   : Function-style macro to return elements of a list that match those
/             in a reference list.
/ SubMacros : %words %nodup
/ Notes     : Non-matching list elements are returned in the global macro
/             variable _nomatch_ .
/ Usage     : %let match=%match(aa bb,aa cc);
/             %put %match(aa bb,aa cc); 
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ref               (pos) Space-delimited reference list
/ list              (pos) Space-delimited list
/ nodup=yes         By default, remove duplicates from the list
/ casesens=no       By default, case sensitivity is not important.
/ fixcase=no        By default, do not make the case of matching items the same
/                   as the item in the reference list.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  19Mar07         Macro called message added plus header tidy
/ rrb  30Jul07         Header tidy
/ rrb  01May11         Code restructured and missing list allowed (v2.0)
/ rrb  03Dec12         Header tidy (%nodup added to submacro list)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: match v2.0;

%macro match(ref,list,nodup=yes,casesens=no,fixcase=no);
  %local err errflag list2 nref nlist i j item match refitem;
  %let err=ERR%str(OR);
  %let errflag=0;

  %global _nomatch_;
  %let _nomatch_=;

  %if not %length(&nodup) %then %let nodup=yes;
  %if not %length(&casesens) %then %let casesens=no;
  %if not %length(&fixcase) %then %let fixcase=no;

  %let nodup=%upcase(%substr(&nodup,1,1));
  %let casesens=%upcase(%substr(&casesens,1,1));
  %let fixcase=%upcase(%substr(&fixcase,1,1));

  %if "&nodup" EQ "Y" %then %let list2=%nodup(&list,casesens=&casesens);
  %else %let list2=&list;

  %let nref=%words(&ref);
  %let nlist=%words(&list2);

  %if not &nref %then %do;
    %put &err: (match) No elements in reference list;
    %let errflag=1;
  %end;

  %if &errflag %then %goto exit;

  %if not &nlist %then %goto skip;

  %do i=1 %to &nlist;
    %let item=%scan(&list2,&i,%str( ));
    %let match=NO;
    %do j=1 %to &nref;
      %let refitem=%scan(&ref,&j,%str( ));
      %if "&casesens" EQ "N" %then %do;
        %if "%upcase(&item)" EQ "%upcase(&refitem)" %then %do;
          %let match=YES;
          %let j=&nref;
        %end;
      %end;
      %else %do;
        %if "&item" EQ "&refitem" %then %do;
          %let match=YES;
          %let j=&nref;
        %end;
      %end;
    %end;
    %if &match EQ YES %then %do;
      %if "&fixcase" EQ "N" %then &item;
      %else &refitem;
    %end;
    %else %let _nomatch_=&_nomatch_ &item;
  %end;

  %goto skip;
  %exit: %put &err: (match) Leaving macro due to problem(s) listed.;
  %skip:
%mend match;

/*<pre><b>
/ Program   : nodup.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to drop duplicates in a space-delimited list
/ SubMacros : %words
/ Notes     : 
/ Usage     : %let str=%nodup(aaa bbb aaa);
/             %put %nodup(aaa bbb aaa); 
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ list              (pos) space-delimited list of items
/ casesens=no       Case sensitive. no by default.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: nodup v1.0;

%macro nodup(list,casesens=no);

  %local i j match item errflag err;
  %let err=ERR%str(OR);
  %let errflag=0;
  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));

  %if not %index(YN,&casesens) %then %do;
    %put &err: (nodup) casesens must be set to yes or no;
    %let errflag=1;
  %end;

  %if &errflag %then %goto exit;

  %do i=1 %to %words(&list);
    %let item=%scan(&list,&i,%str( ));
    %let match=NO;
    %if &i LT %words(&list) %then %do;
      %do j=%eval(&i+1) %to %words(&list);
        %if &casesens EQ Y %then %do;
          %if "&item" EQ "%scan(&list,&j,%str( ))" %then %let match=YES;
        %end;
        %else %do;
          %if "%upcase(&item)" EQ "%upcase(%scan(&list,&j,%str( )))" %then %let match=YES;
        %end;
      %end;
    %end;
    %if &match EQ NO %then &item;
  %end;

  %goto skip;
  %exit: %put &err: (nodup) Leaving macro due to problem(s) listed;
  %skip:

%mend nodup;
  

/*<pre><b>
/ Program   : noquotes.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to remove all quoted strings from a macro
/             expression.
/ SubMacros : none
/ Notes     : This gets rid of all quoted strings and returns what is left.
/ Usage     : %let noquotes=%noquotes(&str);
/             %put %noquotes(%str(a e "c" e)); 
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: noquotes v1.0;

%macro noquotes(str);

  %local i pos1 pos2 qtype tempstr;
  %let tempstr=&str;

  %redo:

  %let pos1=0;
  %let pos2=0;
  %let qtype=;

  %do i=1 %to %length(&tempstr);
    %if &pos1 EQ 0 %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(%')
       or %qsubstr(&tempstr,&i,1) EQ %str(%") %then %do;
        %let pos1=&i;
        %let qtype=%qsubstr(&tempstr,&i,1);
      %end;
    %end;
    %else %if (&pos1 GT 0) and (&pos2 EQ 0) %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(&qtype) %then %let pos2=&i;
    %end;
  %end; 

  %if (&pos1 GT 0) and (&pos2 GT 0) %then %do;
    %if (&pos1 GT 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1)%qsubstr(&tempstr,&pos2+1);
    %else %if (&pos1 EQ 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,&pos2+1);
    %if (&pos1 GT 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1);
    %else %if (&pos1 EQ 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=;
    %if %length(&tempstr) %then %goto redo;
  %end;

&tempstr

%mend noquotes;

/*%num_tokens 
 Purpose: Count the number of “tokens” (variables) in a list. 
 Required arguments: 
   words – the variable list 
 Optional arguments: 
   delim – the character(s) separating each variable in the &words list [default: space] 

 Example: 
     %put  %num_tokens(a b c d e);
     %put  %num_tokens(a-b-c-d-e, delim=-);

 Credit:
    source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
        (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf
    authored by Gabriel Cano;
*/

%macro num_tokens(words, delim=%str( )); 
    %local counter; 
    %* Loop through the words list, incrementing a counter for each word found. ; 
    %let counter = 1; 
    %do %while (%length(%scan(&words, &counter, &delim)) > 0); 
        %let counter = %eval(&counter + 1); 
    %end; 
    %* Our loop above pushes the counter past the number of words by 1. ; 
    %let counter = %eval(&counter - 1); 
    %* Output the count of the number of words. ; 
    &counter 
%mend num_tokens; 
/*%parallel_join 
    Purpose: Join two variable lists by connecting each variable in the first list 
             to its correspondingvariable in the second list by a text string. 
    dependence: %num_tokens

    Required arguments: 
        words1 – the first variable list 
        words2 – the second variable list 
        joinstr – the text string used to join the variable names in &words1 with the variable names in &words2 
    Optional arguments: 
        delim1 – the character(s) separating each variable in the &words1 list [default: space] 
        delim2 – the character(s) separating each variable in the &words2 list [default: space] 

    Examples: 
    %put  %parallel_join(a b c, d e f, *);                    *produces the text a*d b*e c*f ;           
    %put  %parallel_join(a#b#c, d.e.f, *, delim1=#, delim2=.);*produces the text a*d b*e c*f;

    Credit:
      source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
        (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf            
*/


%macro parallel_join(words1, words2, joinstr, delim1=%str( ), delim2=%str( )); 
    %local i num_words1 num_words2 word outstr; 
    %* Verify macro arguments. ; 

    %if (%length(&words1) eq 0) %then %do; 
        %put ***ERROR(parallel_join): Required argument 'words1' is missing.; 
        %goto exit; 
    %end; 
    %if (%length(&words2) eq 0) %then %do; 
        %put ***ERROR(parallel_join): Required argument 'words2' is missing.; 
        %goto exit; 
    %end; 
        %if (%length(&joinstr) eq 0) %then %do; 
        %put ***ERROR(parallel_join): Required argument 'joinstr' is missing.; 
        %goto exit; 
    %end; 

    %* Find the number of words in each list. ; 
    %let num_words1 = %num_tokens(&words1, delim=&delim1); 
    %let num_words2 = %num_tokens(&words2, delim=&delim2); 
    %* Check the number of words. ; 
    %if (&num_words1 ne &num_words2) %then %do; 
        %put ***ERROR(parallel_join): The number of words in 'words1' and; 
        %put *** 'words2' must be equal.; 
        %goto exit; 
    %end; 
    %* Build the outstr by looping through the corresponding words and joining 
    * them by the joinstr. ; 
    %let outstr=; 
    %do i = 1 %to &num_words1; 
        %let word = %scan(&words1, &i, &delim1); 
        %let outstr = &outstr &word&joinstr%scan(&words2, &i, &delim2); 
    %end; 
    %* Output the list of joined words. ; 
    &outstr 
    %exit: 
%mend parallel_join; 
/*<pre><b>
/ Program   : prefix.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 12-Jun-2011
/ Purpose   : Function-style macro to return a list with a prefix added.
/ SubMacros : none
/ Notes     : Items in matching quotes are treated as single elements
/ Usage     : %let preflist=%prefix(C:\mylib\,fname1 "fname 2" fname3);
/             %put %prefix(C:\mylib\,fname1 "fname 2" fname3); 
/             
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ prefix            (pos) Text to prefix each item with (unquoted)
/ list              (pos) List of items to prefix (separated by spaces)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: prefix v1.0;

%macro prefix(prefix,list);
  %local i bit;
  %let i=1;
  %let bit=%sysfunc(scanq(&list,&i,%str( )));
  %do %while(%length(&bit));
&prefix.&bit
    %let i=%eval(&i+1);
    %let bit=%sysfunc(scanq(&list,&i,%str( )));
  %end;
%mend prefix;

/*<pre><b>
/ Program      : qdequote.sas
/ Version      : 1.3
/ Author       : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date         : 16-Nov-2011
/ Purpose      : Function-style macro to remove front and end matching quotes
/                from a macro string and return the result MACRO QUOTED.
/ SubMacros    : none
/ Notes        : This is a function-style macro. The resulting expression will
/                be MACRO QUOTED so you will have to use the %unquote() function
/                if you are using the results in sas code. See usage notes.
/ Usage        : %let str=%qdequote(%qreadpipe(echo '%username%'));
/                CLASS %unquote(%qdequote('&trtvar')) ;
/                %put %qdequote(%qreadpipe(echo '%username%')); 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ N/A
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  30Jul07         Header tidy
/ rrb  19Jan08         Note added in header about macro quoting
/ rrb  31Oct08         Purpose in header updated 
/ rrb  01Jan09         Use %qtrim() instead of %quote()
/ rrb  12Oct09         Macro renamed from dequote to qdequote (v1.2)
/ rrb  04May11         Code tidy
/ rrb  16Nov11         Bug when str is "" fixed (v1.3)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: qdequote v1.3;

%macro qdequote(str);
  %if (%qsubstr(&str,1,1) EQ %str(%') and %qsubstr(&str,%length(&str),1) EQ %str(%'))
  or (%qsubstr(&str,1,1) EQ %str(%") and %qsubstr(&str,%length(&str),1) EQ %str(%"))
  %then %do;
    %if %length(&str) LE 2 %then %qtrim();
    %else %qsubstr(&str,2,%length(&str)-2);
  %end;
  %else %qtrim(&str);
%mend qdequote;




/*<pre><b>
/ Program   : qreadpipe.sas
/ Version   : 2.1
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 23-Sep-2011
/ Purpose   : Function-style macro to read the output of a system command and
/             return the result trimmed and MACRO QUOTED.
/ SubMacros : %qtrim
/ Notes     : Result will be MACRO QUOTED. Use %unquote to make the string
/             output usable in ordinary sas code.
/ Usage     : %let mvar=%qreadpipe(echo $USER);
/             %put  %qreadpipe(echo '%username%');
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ command           (pos) System command. This should not be enclosed in quotes
/                   but may be enclosed in %str(), %quote() etc..
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  22Jul07         Header tidy
/ rrb  30Jul07         Header tidy
/ rrb  31Oct08         Major redesign for v2.0
/ rrb  12Oct09         Macro renamed from readpipe to qreadpipe (v2.1)
/ rrb  04May11         Code tidy
/ rrb  23Sep11         Header tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: qreadpipe v2.1;

%macro qreadpipe(command);
  %local fname fid str rc res err;
  %let err=ERR%str(OR);
  %let rc=%sysfunc(filename(fname,&command,pipe));
  %if &rc NE 0 %then %do;
    %put &err: (qreadpipe) Pipe file could not be assigned due to the following:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let fid=%sysfunc(fopen(&fname,s,80,b));
    %if &fid EQ 0 %then %do;
  %put &err: (qreadpipe) Pipe file could not be opened due to the following:;
  %put %sysfunc(sysmsg());
    %end;
    %else %do;
      %do %while(%sysfunc(fread(&fid)) EQ 0);
        %let rc=%sysfunc(fget(&fid,str,80));
        %let res=&res%superq(str);
      %end;
%qtrim(&res)
      %let rc=%sysfunc(fclose(&fid));
      %if &rc NE 0 %then %do;
  %put &err: (qreadpipe) Pipe file could not be closed due to the following:;
  %put %sysfunc(sysmsg());
      %end;
      %let rc=%sysfunc(filename(fname));
      %if &rc NE 0 %then %do;
  %put &err: (qreadpipe) Pipe file could not be deassigned due to the following:;
  %put %sysfunc(sysmsg());
      %end;
    %end;
  %end;
%mend qreadpipe;


%macro qt(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , qt=%str(%")  /* type of quote mark */
     , osep=%str( ) /* separtor for returned list */
     ) ;

 /* List of items separated by &lsep
     Return items in list quoted with &qt, and separated with &osep
     if lsep is not %STR( ) then there can be only one separator between items.
     Note: leading and trailing spaces are stripped from list when LSEP is %STR( ).
     LV provides override to specify external variable name instead list.
     If the LV option is used then L and QT_: should be avoided for variable names.

examples:
    %put %qt(l=a b c,osep=%str(,));

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf

 */

 %local qt_list ;
 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %superq(lsep) = %str( ) and %length(&lsep)=1 %then
 %do ;
     %let qt_list = %qsysfunc(strip(%superq(&lv))) ;
     %if %length(&qt_list) > 0 %then
     %let qt_list = %qsysfunc(compbl(&qt_list)) ;
 %end ;
 %else
     %let qt_list = %superq(&lv) ;
 %if %length(&qt_list) > 0 %then
     %do ;
     %unquote(&qt%qsysfunc(tranwrd( &qt_list
     , &lsep
     , &qt&osep&qt
     )
     )&qt
     )
 %end ;
%mend qt ;
/*<pre><b>
/ Program   : quotecnt.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to count quoted strings in a macro expression
/ SubMacros : none
/ Notes     : This returns the number of quoted strings.
/ Usage     : %let count=%quotecnt(&str);
/             %put %quotecnt(%str(a b "cc"));  
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message and header tidy
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: quotecnt v1.0;

%macro quotecnt(str);

  %local i pos1 pos2 qtype tempstr count;
  %let tempstr=&str;
  %let count=0;

  %redo:

  %let pos1=0;
  %let pos2=0;
  %let qtype=;

  %do i=1 %to %length(&tempstr);
    %if &pos1 EQ 0 %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(%')
       or %qsubstr(&tempstr,&i,1) EQ %str(%") %then %do;
        %let pos1=&i;
        %let qtype=%qsubstr(&tempstr,&i,1);
      %end;
    %end;
    %else %if (&pos1 GT 0) and (&pos2 EQ 0) %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(&qtype) %then %let pos2=&i;
    %end;
  %end; 

  %if (&pos1 GT 0) and (&pos2 GT 0) %then %do;
    %let count=%eval(&count + 1);
    %if (&pos1 GT 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1)%qsubstr(&tempstr,&pos2+1);
    %else %if (&pos1 EQ 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,&pos2+1);
    %if (&pos1 GT 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1);
    %else %if (&pos1 EQ 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=;
    %if %length(&tempstr) %then %goto redo;
  %end;

&count

%mend quotecnt;  
/*<pre><b>
/ Program   : quotelst.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to quote the elements of a list
/ SubMacros : none
/ Notes     : DO NOT COPY AND PASTE THIS FROM THIS BROWSER WINDOW. YOU MUST USE
/             THE "VIEW" PULL-DOWN WINDOW AND USE "SOURCE". This is because the
/             browser will change some of the characters in this file to quotes.
/
/             This is useful to turn a list into a quoted list so that you can
/             use the in() function on it in a data step. Also, if you search for
/             a quoted string among a list of quoted strings then you can avoid
/             matching on a subset of a single element. Note that you can change
/             not only the quote mark but the delimiter as well so you can use
/             this macro for other purposes like putting commas between variable
/             names etc. It is assumed that the elements of the list are
/             delimited by spaces.
/ Usage     : %put %quotelst(a b c d);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               String to quote elements of (pos)
/ quote=%str(%")    Quote character to use (defaults to double quotation mark)
/ delim=%str( )     Delimiter character to use (defaults to a space)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  21May08         Use of %scan replaced by %qscan
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: quotelst v1.1;

%macro quotelst(str,quote=%str(%"),delim=%str( ));
  %local i quotelst;
  %let i=1;
  %do %while(%length(%qscan(&str,&i,%str( ))) GT 0);
    %if %length(&quotelst) EQ 0 %then %let quotelst=&quote.%qscan(&str,&i,%str( ))&quote;
    %else %let quotelst=&quotelst.&quote.%qscan(&str,&i,%str( ))&quote;
    %let i=%eval(&i + 1);
    %if %length(%qscan(&str,&i,%str( ))) GT 0 %then %let quotelst=&quotelst.&delim;
  %end;
%unquote(&quotelst)
%mend quotelst;
/*<pre><b>
/ Program   : quotescan.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to scan for a quoted string in a macro
/             expression.
/ SubMacros : none
/ Notes     : The quoted string will still have its quote marks around it.
/             A null string will be returned if there is nothing quoted.
/             Note that any string returned will be macro-quoted so you should
/             put it inside %unquote() if using the output in normal sas code.
/ Usage     : %let scan=%quotescan(&str,2);
/            %put %quotescan(%str( a b "ee" "r" e ),2);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/ pos               (pos) Position
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  28May07         Header tidy
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: quotescan v1.0;

%macro quotescan(str,pos);

  %local i pos1 pos2 qtype tempstr count qstr;
  %let tempstr=&str;
  %let count=0;
  %if not %length(&pos) %then %let pos=1;
  %redo:

  %let pos1=0;
  %let pos2=0;
  %let qtype=;

  %do i=1 %to %length(&tempstr);
    %if &pos1 EQ 0 %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(%')
       or %qsubstr(&tempstr,&i,1) EQ %str(%") %then %do;
        %let pos1=&i;
        %let qtype=%qsubstr(&tempstr,&i,1);
      %end;
    %end;
    %else %if (&pos1 GT 0) and (&pos2 EQ 0) %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(&qtype) %then %let pos2=&i;
    %end;
  %end; 

  %if (&pos1 GT 0) and (&pos2 GT 0) %then %do;
    %let count=%eval(&count + 1);
    %let qstr=%qsubstr(&tempstr,&pos1,%eval(&pos2-&pos1+1));
    %if (&pos1 GT 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1)%qsubstr(&tempstr,&pos2+1);
    %else %if (&pos1 EQ 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,&pos2+1);
    %if (&pos1 GT 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1);
    %else %if (&pos1 EQ 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=;
    %if (&count LT &pos) and %length(&tempstr) %then %goto redo;
  %end;

  %if &count EQ &pos %then &qstr;

%mend quotescan;  
%macro range (
       to  =        /* end integer value */
     , from=1       /* starting integer value */
     , step=1       /* increment integer */
     , osep=%str( ) /* separator between integers */
     , opre=%str()  /* prefix for sequence of integers*/
     , osuf=%str()  /* suffix for sequence of integers*/
     ) ;

/*
return sequence of integers like 1 2 3 or
    strings ended with sequences of integers like data1 data2 data3
    starting at &FROM going to &TO in steps of &step

examples:
   %put %range(to=10);
   %put %range(to=10, opre=%str(data));
   %put %range(from=2,to=10,step=3,osep=%str(,));
   %put %range(from=2,to=10,step=3,osep=%str(,),osuf=%str(a));

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
    This snippet used a more efficient style from Chang Chung(http://changchung.com)
    Jiangtang Hu (2013, http://www.jiangtanghu.com):
        1)used %let rg_i = ; to initiate the macro variable rather than %local rg_i;
        2)added two parameters (prefix/suffix) so it works more than generating sequence of integers
        3)archived in https://github.com/Jiangtang/Programming-SAS/tree/master/ListProcessing
*/

 %let rg_i = ;
 %do rg_i = &from %to &to %by &step ;
     %if &rg_i = &from %then
     %do;&opre.&rg_i.&osuf%end ;
     %else
     %do;&osep.&opre.&rg_i.&osuf%end ;
 %end ;
%mend range ;

/*
%put %range_non_int(start = 1 , end = 5 , by = .25 ) ;

http://support.sas.com/kb/37/536.html

*/

%macro range_non_int( start= , end= , by= ) ;
    %local list;

    %do i = 1 %to %eval(%sysfunc( ceil( %sysevalf( ( &end - &start ) / &by ) ) ) +1) ;
       %let value=%sysevalf( ( &start - &by ) + ( &by * &i ) ) ;
       %if &value <=&end %then %do;
           %let list=&list. &value;
       %end;
    %end ;
    &list
%mend range_non_int ;
/*<pre><b>
/ Program   : remove.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to remove all occurrences of the target
/             string(s) from another string.
/ SubMacros : none
/ Notes     : none
/ Usage     : %let string2=%remove(&string1,XXX,yyy,YYY);
/             %put %remove(aaa xxx yyy yyee,XXX,yyy,YYY);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos - unquoted) String to remove target from
/ target1-30        (pos - unquoted) Target string(s) to remove
/ casesens=no       Whether the search for the target(s) is case sensitive
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: remove v1.0;

%macro remove(string,
              target1,
              target2,
              target3,
              target4,
              target5,
              target6,
              target7,
              target8,
              target9,
              target10,
              target11,
              target12,
              target13,
              target14,
              target15,
              target16,
              target17,
              target18,
              target19,
              target20,
              target21,
              target22,
              target23,
              target24,
              target25,
              target26,
              target27,
              target28,
              target29,
              target30,
           casesens=no
              );

  %local i result index targlen beyond newstr;

  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));

  %let result=&string;

  %do i=1 %to 30;
    %let targlen=%length(&&target&i);
    %if &targlen %then %do;
      %if "&casesens" EQ "Y" %then %let index=%index(&result,&&target&i);
      %else %let index=%index(%qupcase(&result),%qupcase(&&target&i));
      %do %while(&index GT 0);
        %if &index GT 1 %then %let newstr=%qsubstr(&result,1,%eval(&index-1));
        %else %let newstr=;
        %let beyond=%eval(&index+&targlen);
        %if &beyond LE %length(&result) %then %let newstr=&newstr%qsubstr(&result,&beyond);
        %let result=&newstr;
        %if "&casesens" EQ "Y" %then %let index=%index(&result,&&target&i);
        %else %let index=%index(%qupcase(&result),%qupcase(&&target&i));
      %end;
    %end;
  %end;

&result

%mend remove;
/*<pre><b>
/ Program   : removew.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 05-Dec-2012
/ Purpose   : Function-style macro to remove all occurrences of the target
/             word(s) from a source list of words.
/ SubMacros : %words
/ Notes     : For a word to be removed, the whole word must match. This macro
/             will not remove substrings in the sense that "low" will not be
/             removed from the end of the word "yellow". Multiple occurences of
/             a word will be removed. This macro will only work correctly for
/             lists of space-delimited words containing no special characters
/             that need quoting. You should avoid combinations of a string with
/             many words and many target words such that their product is very
/             high (e.g. 100 x 100 = 10000) as this code will run slow and use
/             a lot of processor power. Data step solutions or SQL solutions are
/             better for those cases. Final result returned will have leading
/             and trailing spaces removed and multiple adjacent blanks replaced
/             by single blanks.
/ Usage     : %let colors2=%removew(&rainbow,green yellow);
/             %put %removew(green yellow red,green yellow);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos) Unquoted space-delimited source list of words
/ targetwords       (pos) Unquoted space-delimited target word(s) to remove
/ casesens=no       Whether the search for the target word(s) is case sensitive
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jan08         compbl bug fixed
/ rrb  04May11         Code tidy
/ rrb  05Dec12         Usage notes macro call coreected
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: removew v1.1;

%macro removew(string,
          targetwords,
             casesens=no
              );

  %local i j result match twords swords tword sword;

  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));

  %let twords=%words(&targetwords);
  %let swords=%words(&string);

  %let result=;

  %do i=1 %to &swords;
    %let match=0;
    %let sword=%scan(&string,&i,%str( ));
    %do j=1 %to &twords;
      %let tword=%scan(&targetwords,&j,%str( ));
      %if "&casesens" EQ "Y" %then %do;
        %if "&tword" EQ "&sword" %then %do;
          %let match=1;
          %let j=&twords;
        %end;
      %end;
      %else %do;
        %if "%upcase(&tword)" EQ "%upcase(&sword)" %then %do;
          %let match=1;
          %let j=&twords;
        %end;
      %end;
    %end;
    %if not &match %then %let result=&result &sword;
  %end;

  %if %length(&result) %then %let result=%sysfunc(compbl(&result));

&result

%mend removew;
/*%rename_string 
    Purpose: Create a list suitable for the rename statement where the variables in a list 
                are renamed so that they have a common text string as a prefix or suffix.
    dependence: %num_tokens, %parallel_join, %add_string
 

    Required arguments: 
        words – the variable list containing the original names 
        str – the text string to add to each renamed variable 

    Optional arguments: 
        location – whether to add the text string as a prefix or suffix [prefix|suffix, default: suffix] 
        delim – the character(s) separating each variable in the &words list [default: space] 

    Examples: 
    %put  %rename_string(a b c, _1);
                produces the text a=a_1 b=b_1 c=c_1
    %put %rename_string(a b c, r_, location=prefix);
                produces the text a=r_a b=r_b c=r_c
    %put  %rename_string(a|b|c, _1, delim=|);
                produces the text a=a_1 b=b_1 c=c_1
    Credit:
        source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
          (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf   
*/


%macro rename_string(words, str, delim=%str( ), location=suffix); 
    %* Verify macro arguments. ; 
    %if (%length(&words) eq 0) %then %do; 
        %put ***ERROR(rename_string): Required argument 'words' is missing.; 
        %goto exit; 
    %end; 

    %if (%length(&str) eq 0) %then %do; 
        %put ***ERROR(rename_string): Required argument 'str' is missing.; 
        %goto exit; 
    %end; 
    %if (%upcase(&location) ne SUFFIX and %upcase(&location) ne PREFIX) %then %do; 
        %put ***ERROR(rename_string): Optional argument 'location' must be; 
        %put *** set to SUFFIX or PREFIX.; 
        %goto exit; 
    %end; 

    %* Since rename_string is just a special case of parallel_join, 
    * simply pass the appropriate arguments on to that macro. ; 
    %parallel_join( 
    &words, 
    %add_string(&words, &str, delim=&delim, location=&location), 
    =, 
    delim1 = &delim, 
    delim2 = &delim 
    ) 
    %exit: 
%mend rename_string; 
%macro replace(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , code=        /* block of code containing symbolic variable */
     , key=#        /* symbolic variable to replace (#abc# etc.) */
     , osep=%str( ) /* separator between new elements */
                    /* may be %str(;) when code is statement */
                    /* if so remember to add closing semicolon */
     ) ;

 /* for elt in the list replace key in code
     LV provides override to specify external variable name instead of list.
     If the LV option is used then L and RG_: should be avoided for variable names.

examples:
    %macro rename ( list, pref=__ ) ;
         %* make a rename list from &LIST *;
         %replace ( l=&list, code = # = &pref# )
    %mend rename ;
    %put %rename ( x y z, pref=__ );

     %macro char2num ( list , pref = __ ) ;
     %* make list of char to num assignments *;
     %replace ( l=&list
        , code= %str(# = input(&pref#,best32.);)
      )
    %mend char2num ;
    %put %char2num(x y z);

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local rg_i rg_w rg_list ;
 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %length(%superq(&lv)) = 0 /*or %index(%superq(code),&key) = 0*/ %then
 %do ;
     %let rg_list = %superq(code) ;
     %goto mexit ;
 %end ;
 %do rg_i = 1 %to &sysmaxlong ;
     %let rg_w = %qscan(%superq(&lv),&rg_i,&lsep) ;
     %if %length(&rg_w) = 0 %then %goto mexit ;
     %if &rg_i = 1 %then
     %let rg_list = %sysfunc(tranwrd(%superq(code),&key,&rg_w)) ;
     %else
     %let rg_list =
     &rg_list&osep%sysfunc(tranwrd(%superq(code),&key,&rg_w)) ;
 %end ;
 %mexit:

 %unquote(&rg_list)
%mend replace ;
/*
Purpose: Reverse a macro variable's value.
Notes: For versions before v6.12. Otherwise use 
            %sysfunc(reverse(&<macro-variable>))

example:
    %put %reverse(gfee);



Credit: Richard A. DeVenezia
    http://www.devenezia.com/downloads/sas/macros/index.php?m=reverse

*/

%macro reverse (string);
  %local i rstring;
  %let rstring=;
  %let string=%quote(&string);
  %do i=%length(&string) %to 1 %by -1;%quote(%substr(&string,&i,1))%end;
%mend;


/*
Purpose: Emit a list of items separated by some delimiter

example:
    %put %seplist (a b c);
    %put %seplist (a b c, dlm=+);
    %put %seplist (a|b|c, indlm=|, dlm=%str( ));
    %put %seplist (a b c, prefix=ORACLE., nest=QQ);
    %put %seplist (a$b$c, indlm=$, suffix=@mail.com, dlm=%str( ));
    %put %seplist (a$b$c, indlm=$, prefix=antispam_, suffix=@mail.com, dlm=%str( ));
    %put %seplist (a b c, dlm=||, nest=Q);
    %put %seplist (a b c, nest=C);
    %put %seplist (a b c, nest=P);
    %put %seplist (a b c, nest=B);
    %put %seplist (a xyz b xyz c, indlm=xyz, dlm=%str( or ), prefix=%str( not ));



Credit: Richard A. DeVenezia
    http://www.devenezia.com/downloads/sas/macros/index.php?m=seplist
*/



%macro seplist (

    items
  , indlm = %str( )
  , dlm   = %str(,)
  , prefix=
  , nest=
  , suffix=

  );

%* Richard A. DeVenezia - 990902;
%*
%* emit a list of words separated by a delimiter
%*
%* items  - list of items, separated by indlm
%* indlm  - string that delimits each item of items
%*   dlm  - string that delimits list of items emitted
%* prefix - string to place before each item
%* nest   - Q (single quote ''),
%*          QQ (double quotes ""),
%*          P (parenthesis ()),
%*          C (curly braces {}),
%*          B (brackets [])
%* suffix - string to place after each item
%*
%* Note: nest is a convenience, and could be accomplished using
%*       prefix and suffix
%*;

  %local item n emit;

  %let emit=;

  %let nest = %upcase (&nest);

  %if (&nest = Q) %then %do;
    %let prefix = &prefix.%str(%');
    %let suffix = %str(%')&suffix;
  %end;
  %else
  %if (&nest = QQ) %then %do;
    %let prefix = &prefix.%str(%");
    %let suffix = %str(%")&suffix;
  %end;
  %else
  %if (&nest = P) %then %do;
    %let prefix = &prefix.%str(%();
    %let suffix = %str(%))&suffix;
  %end;
  %else
  %if (&nest = C) %then %do;
    %let prefix = &prefix.%str({);
    %let suffix = %str(})&suffix;
  %end;
  %else
  %if (&nest = B) %then %do;
    %let prefix = &prefix.%str([);
    %let suffix = %str(])&suffix;
  %end;

  %let n = 1;
  %let item = %qscan (&items, &n, %quote(&indlm));

  %do %while (%superq(item) ne );

    %if (&n = 1)
      %then %let emit = &prefix.&item.&suffix;
      %else %let emit = &emit.&dlm.&prefix.&item.&suffix;

    %let n = %eval (&n+1);
    %let item = %qscan (&items, &n, %quote(&indlm));
  %end;

  &emit

%mend;

%macro slice(
    L,            /*list*/
    i,            /*index*/
    sep_L=%str( ),/*separator for list*/
    sep_i=%str( ) /*separator for index*/
    );

    /*
    return a sub-list sliced by a index

    examples(all produce a c d):
       %put %slice(a b c d,1 3  4);                                   
       %put %slice(%str(a, b, c, d),1 3  4,sep_L=%str(,));
       %put %slice(%str(a, b, c, d),%str(1, 3, 4),sep_L=%str(,),sep_i=%str(,)); 

    Credit:
        Jiangtang Hu (2013-03-31, http://www.jiangtanghu.com):
    */

    %let VarList = ;
    %let count=%sysfunc(countw(&i,&sep_i));

    %do j = 1 %to &count;
      %let index=%qscan(&i,&j,&sep_i);
      %let VarList = &VarList.%str( )%qscan(&L,&index,&sep_L);
    %end;

    &VarList
%mend slice;
/*<pre><b>
/ Program   : splitmac.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 08-May-2011
/ Purpose   : Function-style macro to insert split characters in a macro string
/ SubMacros : none
/ Notes     : This is the sister macro to %splitmac except it works on macro
/             values instead of SAS variables. It is a function-style macro.
/
/             A split character will normally be placed in a blank space. If
/             there is no suitable space then it will be inserted after a hyphen.
/             But if there is no suitable space and no hyphen then it will be
/             inserted at the end. 
/
/             This macro will only look back the floor of half the column width
/             to find a place to insert the split character.
/
/             If the input string has one or more equals signs in it then
/             enclose the string in %str(). If it has one or more commas in it
/             then enclose it in %quote().
/
/ Usage     : %let str=The quick brown fox jumped over the lazy dog;
/             %let splitstr=%splitmac(&str,10);
/             %put %splitmac(The quick brown fox jumped over the lazy dog,10);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) Macro string to split.
/ cols              (pos) Maximum number of columns allowed.
/ split=*           Split character. Must be a single character, unquoted.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  08May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: splitmac v1.0;

%macro splitmac(str,cols,split=*);

  %local errflag err _cols tempstr res;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&str) %then %do;
    %let errflag=1;
    %put &err: (splitmac) No string supplied as first positional parameter;
  %end;

  %if not %length(&cols) %then %do;
    %let errflag=1;
    %put &err: (splitmac) No column width supplied as second positional parameter;
  %end;
  %else %if %sysfunc(verify(&cols,1234567890)) %then %do;
    %let errflag=1;
    %put &err: (splitmac) Cols parameter "&cols" not a valid number of columns;
  %end;

  %if not %length(&split) %then %let split=*;

  %if %length(&split) GT 1 %then %do;
    %let errflag=1;
    %put &err: (splitmac) Split character &split is not a single unquoted character;
  %end;

  %if &errflag %then %goto exit;

  %let tempstr=&str;

  %do %while(%length(&tempstr) GT &cols);
    %do _cols=(&cols+1) %to %eval(&cols/2) %by -1;
      %if "%qsubstr(%quote(&tempstr),&_cols,1)" EQ " " %then %do;
        %let res=&res%qsubstr(%quote(&tempstr),1,%eval(&_cols - 1))&split;
        %let tempstr=%qsubstr(%quote(&tempstr),%eval(&_cols+1));
        %let _cols=1;
      %end;
    %end;
    %*- if space character not found look for a hyphen -;
    %if &_cols GT 1 %then %do;
      %do _cols=&cols %to %eval(&cols/2) %by -1;
        %if "%qsubstr(%quote(&tempstr),&_cols,1)" EQ "-" %then %do;
          %let res=&res%qsubstr(%quote(&tempstr),1,&_cols)&split;
          %let tempstr=%qsubstr(%quote(&tempstr),%eval(&_cols+1));
          %let _cols=1;
        %end;
      %end;
    %end;
    %*- if no hyphen found then split at end -;
    %if &_cols GT 1 %then %do;
      %let res=&res%qsubstr(%quote(&tempstr),1,&cols)&split;
      %let tempstr=%qsubstr(%quote(&tempstr),&cols+1);
    %end;
  %end;

&res&tempstr

  %goto skip;
  %exit: %put &err: (splitmac) Leaving macro due to problem(s) listed;
  %skip:

%mend splitmac;

/*<pre><b>
/ Program   : suffix.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 12-Jun-2011
/ Purpose   : Function-style macro to return a list with a suffix added.
/ SubMacros : none
/ Notes     : Items in matching quotes are treated as single elements
/ Usage     : %let sufflist=%suffix(.sas,fname1 "fname 2" fname3);
/             %put %suffix(.sas,fname1 "fname 2" fname3); 
/             
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ suffix            (pos) Text to suffix each item with (unquoted)
/ list              (pos) List of items to suffix (separated by spaces)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: suffix v1.0;

%macro suffix(suffix,list);
  %local i bit;
  %let i=1;
  %let bit=%sysfunc(scanq(&list,&i,%str( )));
  %do %while(%length(&bit));
&bit.&suffix
    %let i=%eval(&i+1);
    %let bit=%sysfunc(scanq(&list,&i,%str( )));
  %end;
%mend suffix;

/*%suffix_counter 
    Purpose: Create a list of variable names formed by adding a numeric counter suffix to a base name. 

    Required arguments: 
        base – the text that should be the base of the variable names 
        end – the last number in the counter 

    Optional arguments: 
        start – the first number inthe counter [default: 1] 
        zpad – the number of digits to which the counter should be padded. Use zpad=0 for no padding. [default: 0] 

    Examples: 
        %put  %suffix_counter(v, 4);
                    produces the text v1 v2 v3 v4
        %put %suffix_counter(v, 14, start=10);
                    produces the text v10 v11 v12 v13 v14
        %put  %suffix_counter(v, 4, zpad=2);
                    produces the text v01 v02 v03 v04

    Credit:
        source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
          (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf  
*/


%macro suffix_counter(base, end, start=1, zpad=0); 
%local outstr i counter; 

%* Verify macro arguments. ; 
%if (%length(&base) eq 0) %then %do; 
    %put ***ERROR(suffix_counter): Required argument 'base' is missing.; 
    %goto exit; 
%end; 
%if (%length(&end) eq 0) %then %do; 
    %put ***ERROR(suffix_counter): Required argument 'end' is missing.; 
    %goto exit; 
%end; 
%if (&end < &start) %then %do; 
    %put ***ERROR(suffix_counter): The 'end' argument must not be less; 
    %put *** than the 'start' argument.; 
    %goto exit; 
%end; 

%* Construct the outstr by looping from &start to &end, adding the counter 
* value to &base in each iteration. To handle the zero-padding, use the 
* putn function to format the counter variable with the Z. format. ; 
%let outstr=; 
%do i=&start %to &end; 
    %if (&zpad > 0) %then %do; 
        %let counter = %sysfunc(putn(&i, z&zpad..)); 
    %end; 
    %else %do; 
        %let counter = &i; 
    %end; 
    %let outstr=&outstr &base&counter; 
%end; 

%* Output the new list. ; 
&outstr 
%exit: 
%mend suffix_counter; 
%macro uqt(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , qt=%str(%")  /* type of quote mark */
     ) ;

 /* L (or &LV) is list of quoted items separated by LSEP

 return unquoted list of items separated by space
 LV provides override to specify external variable name instead list.
 If the LV option is used then L and UQT_: should be avoided for variable names.

examples:
    %put %Uqt(l="a" "b" "c");

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %length(%superq(&lv)) > 0 %then
 %do ;
     %sysfunc(compbl(%sysfunc(translate(%superq(&lv),%str( ),&qt&lsep))))
 %end ;
%mend uqt ;
/*<pre><b>
/ Program   : windex.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the word count position in a string
/ SubMacros : %words
/ Notes     : none
/ Usage     : %let windex=%windex(string,target);
/             %put %windex(Word worde,worde); 
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               String (pos) UNQUOTED
/ target            Target string (pos) UNQUOTED
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  10May07         Break loop if match is found (v1.1)
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: windex v1.1;

%macro windex(str,target);
  %local i res words;
  %let res=0;
  %let words=%words(&str);
  %do i=1 %to &words;
    %if "%scan(&str,&i,%str( ))" EQ "&target" %then %do;
      %let res=&i;
      %let i=&words;
    %end;
  %end;
&res
%mend windex;
/*<pre><b>
/ Program   : words.sas
/ Version   : 3.2
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 09-Jan-2013
/ Purpose   : Function-style macro to return the number of words in a string
/ SubMacros : none
/ Notes     : You can change the delimiter to other than a space if required.
/ Usage     : %put %words(a b c d e);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               String (pos) UNQUOTED
/ delim=%str( )     Delimeter (defaults to a space)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  26Sep08         "countw" used for sas version 9 onwards for v2.0
/ rrb  01Sep09         Use of countw() function discontinued (v3.0)
/ rrb  04May11         Code tidy
/ rrb  02Jan13         Use of %qscan dropped (v3.1)
/ rrb  09Jan13         Use of %qscan reinstated (v3.2)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: words v3.2;

%macro words(str,delim=%str( ));
  %local i;
  %let i=1;
  %do %while(%length(%qscan(&str,&i,&delim)) GT 0);
    %let i=%eval(&i + 1);
  %end;
%eval(&i - 1)
%mend words;
%macro xprod(
     l1  =        /* first list */
   , lv1 =        /* external variable override for first list */
   , sep1=%str( ) /* separator between elements of first list */
   , l2  =        /* second list */
   , lv2 =        /* external variable override for second list */
   , sep2=%str( ) /* separator between elements of second list */
   , osep=%str( ) /* separator between elements of new list */
 );

 /* %xprod ( l1= a b , l2= c d ) produces ac ad bc bd

examples:
 %let list1 = a b ;
 %let list2 = c d ;
 %put %xprod (lv1=list1, lv2=list2);
 %put %xprod (lv1=list1, lv2=list2,osep=%str(,));

 LV1 and LV2 provide override to specify external variable name instead of lists.
 If one or more of the lists are empty then the empty list is returned.
 If the LV options are used then L1, L2, and XP_: should be avoided for variable names.

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
        (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
        (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local xp_i xp_j xp_1 xp_2 xp_list ;
 %if %length(&lv1) = 0 %then
 %let lv1 = l1 ;
 %if %length(&lv2) = 0 %then
 %let lv2 = l2 ;
 %do xp_i = 1 %to &sysmaxlong ;
   %let xp_1 = %qscan(%superq(&lv1), &xp_i, &sep1) ;
   %if %length(&xp_1) = 0 %then %goto endloop1 ;
   %do xp_j = 1 %to &sysmaxlong ;
     %let xp_2 = %qscan(%superq(&lv2), &xp_j, &sep2) ;
     %if %length(&xp_2) = 0 %then %goto endloop2 ;
     %if &xp_i = 1 and &xp_j = 1 %then
     %let xp_list = &xp_1&xp_2 ;
     %else
     %let xp_list = &xp_list&osep&xp_1&xp_2 ;
   %end ;
   %endloop2:
 %end ;
 %endloop1:
 %unquote(&xp_list)
%mend xprod ;
%macro zip(
       l1   =        /* first list */
     , lv1 =        /* external variable override for first list */
     , sep1 =%str( ) /* separator between the joined elements */
     , l2   =        /* second list */
     , lv2  =        /* external variable override for second list */
     , sep2 =%str( ) /* separator between the joined elements */
     , osep =%str( ) /* separator between new elements */
     ) ;

 /* %zip ( l1= a b , l2= c d ) produces ac bd

examples:
 %let list1 = a b ;
 %let list2 = c d ;
 %put %zip (lv1=list1, lv2=list2);
 %put %zip (lv1=list1, lv2=list2,osep =%str(,));
 %put %zip (l1=a b, l2=c d,osep =%str(,));

 If lists do not have same length shorter length used and warning to the log.
 Empty lists result in empty list and no message.
 If the LV options are used then L1, L2, and ZIP_: should be avoided for variable names.

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
          (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
          (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local zip_i zip_1 zip_2 zip_list ;
 %if %length(&lv1) = 0 %then
 %let lv1 = l1 ;
 %if %length(&lv2) = 0 %then
 %let lv2 = l2 ;
 %do zip_i = 1 %to &sysmaxlong ;
   %let zip_1 = %qscan(%superq(&lv1) , &zip_i, &sep1 ) ;
   %let zip_2 = %qscan(%superq(&lv2) , &zip_i, &sep2 ) ;
   %if %length(&zip_1) = 0 or %length(&zip_2) = 0 %then
   %goto check ;
   %if &zip_i = 1 %then
   %let zip_list = &zip_1&zip_2 ;
   %else
   %let zip_list = &zip_list&osep&zip_1&zip_2 ;
 %end ;
 %check:
 %if %length(&zip_1) > 0 or %length(&zip_2) > 0 %then
 %put WARNING: Macro ZIP - list lengths do not match - shorter used. ;
 %unquote(&zip_list)
%mend zip ;

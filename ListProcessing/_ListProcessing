/*===================================================================================
 |              SAS List Processing Utility Macros
 |
 |    Author:  see individual snippets
 | Collector:  Jiangtang Hu (Jiangtanghu.com)
 |  Archived:  https://github.com/Jiangtang/Programming-SAS/tree/master/ListProcessing
 |
 +-------List Creating---------------------------------------------------------------
 |
 | %range:          produces a sequence like 1 2 3 or f1 f2 f3 or 1a 2a 3a
 | %suffix_counter: Create a list of variable names formed by adding a numeric counter suffix to a base name.
 |
 |
 +-------List Formating---------------------------------------------------------------
 |
 | %pt:        add quotes to each element in a list
 | %upt:       remove quotes from each element of a list
 | %changesep: change the separator for a list
 |
 +-------List Manipulation-----------------------------------------------------------
 |
 | %num_tokens: Count the number of â€œtokensâ€ (variables) in a list.
 | %countW: Retrieve the number of words in a macro variable
 |
 | %slice:  return a sub-list sliced by a index
 |
 | %zip:           zips two lists together by joining correponding elements, see, a b and c d ==> ac bd
 | %parallel_join: Join two variable lists by connecting each variable in the first list to its correspondingvariable in the second list
 | %add_string:    Add a text string to each variable in a list as either a prefix or suffix
 | %xprod:         take cross product of two lists, see, a b and c d ==> ac ad bc bd
 |
 |
 | %replace:       replace symbolic variable in block of code with each element of a list, see, a b and code = #=__#  ==> a=__a b=__b
 | %rename_string: Create a list suitable for the rename statement
 |
 |
 |
 +==================================================================================*/
/*%add_string 
    Purpose: Add a text string to each variable in a list as either a prefix or suffix.
    dependence: %num_tokens

    Required arguments: 
        words – the variable list 
        str – the text string to add to each variable in the &words list 

    Optional arguments: 
        location – whether to add the text string as a prefix or suffix [prefix|suffix, default: suffix] 
        delim – the character(s) separating each variable in the &words list [default: space] 

    Examples: 
        %put  %add_string(a b c, _max); *produces the text a_max b_max c_max;            
        %put %add_string(a b c, max_, location=prefix);     *produces the text max_a max_b max_c;            
        %put %add_string(%str(a,b,c), _max, delim=%str(,)); *produces the text a_max,b_max,c_max;

    Credit:
        source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
          (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf           

*/


%macro add_string(words, str, delim=%str( ), location=suffix); 
    %local outstr i word num_words; 

    %* Verify macro arguments. ; 
    %if (%length(&words) eq 0) %then %do; 
        %put ***ERROR(add_string): Required argument 'words' is missing.; 
        %goto exit; 
    %end; 
    %if (%length(&str) eq 0) %then %do; 
        %put ***ERROR(add_string): Required argument 'str' is missing.; 
        %goto exit; 
    %end; 
    %if (%upcase(&location) ne SUFFIX and %upcase(&location) ne PREFIX) %then %do; 
        %put ***ERROR(add_string): Optional argument 'location' must be; 
        %put *** set to SUFFIX or PREFIX.; 
        %goto exit; 
    %end; 

    %* Build the outstr by looping through the words list and adding the 
    * requested string onto each word. ; 
    %let outstr = ; 
    %let num_words = %num_tokens(&words, delim=&delim); 
    %do i=1 %to &num_words; 
        %let word = %scan(&words, &i, &delim); 
        %if (&i eq 1) %then %do; 
            %if (%upcase(&location) eq PREFIX) %then %do; 
                %let outstr = &str&word; 
            %end; 
            %else %do; 
                %let outstr = &word&str; 
            %end; 
        %end; 
        %else %do; 
            %if (%upcase(&location) eq PREFIX) %then %do; 
                %let outstr = &outstr&delim&str&word; 
            %end; 
            %else %do; 
                %let outstr = &outstr&delim&word&str; 
            %end; 
        %end; 
    %end; 
    %* Output the new list of words. ; 
    &outstr 
    %exit: 
%mend add_string; 
%macro changesep(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , osep=%str(,) /* separator for rteurned list */
     ) ;
 
 /* L (or &LV) is list of quoted items separated by LSEP
 return unquoted list of items separated by OSEP
 LV provides override to specify external variable name instead list.
 If the LV option is used then L and CHG_: should be avoided for variable names.

 examples:
    %put %changesep ( l=a b c, lv= , lsep= %str( ), osep=%str(,) );

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local chg_list ;
 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %length(%superq(&lv)) > 0 %then
 %do ;
     %if %superq(osep)= %str( ) %then
     %do ;
         %let chg_list = %qsysfunc(strip(%superq(&lv))) ;
         %let chg_list = %qsysfunc(compbl(&chg_list)) ;
     %end ;
     %else
     %let chg_list = %superq(&lv) ;
     %let chg_list = %qsysfunc(translate(&chg_list,&osep,&lsep)) ;
 %end ;
 %unquote(&chg_list)
%mend changesep ;
/*Retrieving the number of words in a macro variable*/
/* valid in SAS 9.1 and above. */

/*
http://support.sas.com/kb/26/152.html
*/

%macro countw(L);
    %let countw=%sysfunc(countw(&L));
    %eval(&countw);
%mend countw;


/*example

%put %countw(e 5 5);

*/

/*%num_tokens 
 Purpose: Count the number of “tokens” (variables) in a list. 
 Required arguments: 
   words – the variable list 
 Optional arguments: 
   delim – the character(s) separating each variable in the &words list [default: space] 

 Example: 
     %put  %num_tokens(a b c d e);
     %put  %num_tokens(a-b-c-d-e, delim=-);

 Credit:
    source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
        (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf
    authored by Gabriel Cano;
*/

%macro num_tokens(words, delim=%str( )); 
    %local counter; 
    %* Loop through the words list, incrementing a counter for each word found. ; 
    %let counter = 1; 
    %do %while (%length(%scan(&words, &counter, &delim)) > 0); 
        %let counter = %eval(&counter + 1); 
    %end; 
    %* Our loop above pushes the counter past the number of words by 1. ; 
    %let counter = %eval(&counter - 1); 
    %* Output the count of the number of words. ; 
    &counter 
%mend num_tokens; 
/*%parallel_join 
    Purpose: Join two variable lists by connecting each variable in the first list 
             to its correspondingvariable in the second list by a text string. 
    dependence: %num_tokens

    Required arguments: 
        words1 – the first variable list 
        words2 – the second variable list 
        joinstr – the text string used to join the variable names in &words1 with the variable names in &words2 
    Optional arguments: 
        delim1 – the character(s) separating each variable in the &words1 list [default: space] 
        delim2 – the character(s) separating each variable in the &words2 list [default: space] 

    Examples: 
    %put  %parallel_join(a b c, d e f, *);                    *produces the text a*d b*e c*f ;           
    %put  %parallel_join(a#b#c, d.e.f, *, delim1=#, delim2=.);*produces the text a*d b*e c*f;

    Credit:
      source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
        (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf            
*/


%macro parallel_join(words1, words2, joinstr, delim1=%str( ), delim2=%str( )); 
    %local i num_words1 num_words2 word outstr; 
    %* Verify macro arguments. ; 

    %if (%length(&words1) eq 0) %then %do; 
        %put ***ERROR(parallel_join): Required argument 'words1' is missing.; 
        %goto exit; 
    %end; 
    %if (%length(&words2) eq 0) %then %do; 
        %put ***ERROR(parallel_join): Required argument 'words2' is missing.; 
        %goto exit; 
    %end; 
        %if (%length(&joinstr) eq 0) %then %do; 
        %put ***ERROR(parallel_join): Required argument 'joinstr' is missing.; 
        %goto exit; 
    %end; 

    %* Find the number of words in each list. ; 
    %let num_words1 = %num_tokens(&words1, delim=&delim1); 
    %let num_words2 = %num_tokens(&words2, delim=&delim2); 
    %* Check the number of words. ; 
    %if (&num_words1 ne &num_words2) %then %do; 
        %put ***ERROR(parallel_join): The number of words in 'words1' and; 
        %put *** 'words2' must be equal.; 
        %goto exit; 
    %end; 
    %* Build the outstr by looping through the corresponding words and joining 
    * them by the joinstr. ; 
    %let outstr=; 
    %do i = 1 %to &num_words1; 
        %let word = %scan(&words1, &i, &delim1); 
        %let outstr = &outstr &word&joinstr%scan(&words2, &i, &delim2); 
    %end; 
    %* Output the list of joined words. ; 
    &outstr 
    %exit: 
%mend parallel_join; 
%macro qt(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , qt=%str(%")  /* type of quote mark */
     , osep=%str( ) /* separtor for returned list */
     ) ;

 /* List of items separated by &lsep
     Return items in list quoted with &qt, and separated with &osep
     if lsep is not %STR( ) then there can be only one separator between items.
     Note: leading and trailing spaces are stripped from list when LSEP is %STR( ).
     LV provides override to specify external variable name instead list.
     If the LV option is used then L and QT_: should be avoided for variable names.

examples:
    %put %qt(l=a b c,osep=%str(,));

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf

 */

 %local qt_list ;
 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %superq(lsep) = %str( ) and %length(&lsep)=1 %then
 %do ;
     %let qt_list = %qsysfunc(strip(%superq(&lv))) ;
     %if %length(&qt_list) > 0 %then
     %let qt_list = %qsysfunc(compbl(&qt_list)) ;
 %end ;
 %else
     %let qt_list = %superq(&lv) ;
 %if %length(&qt_list) > 0 %then
     %do ;
     %unquote(&qt%qsysfunc(tranwrd( &qt_list
     , &lsep
     , &qt&osep&qt
     )
     )&qt
     )
 %end ;
%mend qt ;
%macro range (
       to  =        /* end integer value */
     , from=1       /* starting integer value */
     , step=1       /* increment integer */
     , osep=%str( ) /* separator between integers */
     , opre=%str()  /* prefix for sequence of integers*/
     , osuf=%str()  /* suffix for sequence of integers*/
     ) ;

/*
return sequence of integers like 1 2 3 or
    strings ended with sequences of integers like data1 data2 data3
    starting at &FROM going to &TO in steps of &step

examples:
   %put %range(to=10);
   %put %range(to=10, opre=%str(data));
   %put %range(from=2,to=10,step=3,osep=%str(,));
   %put %range(from=2,to=10,step=3,osep=%str(,),osuf=%str(a));

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
    This snippet used a more efficient style from Chang Chung(http://changchung.com)
    Jiangtang Hu (2013, http://www.jiangtanghu.com):
        1)used %let rg_i = ; to initiate the macro variable rather than %local rg_i;
        2)added two parameters (prefix/suffix) so it works more than generating sequence of integers
        3)archived in https://github.com/Jiangtang/Programming-SAS/tree/master/ListProcessing
*/

 %let rg_i = ;
 %do rg_i = &from %to &to %by &step ;
     %if &rg_i = &from %then
     %do;&opre.&rg_i.&osuf%end ;
     %else
     %do;&osep.&opre.&rg_i.&osuf%end ;
 %end ;
%mend range ;
/*%rename_string 
    Purpose: Create a list suitable for the rename statement where the variables in a list 
                are renamed so that they have a common text string as a prefix or suffix.
    dependence: %num_tokens, %parallel_join, %add_string
 

    Required arguments: 
        words – the variable list containing the original names 
        str – the text string to add to each renamed variable 

    Optional arguments: 
        location – whether to add the text string as a prefix or suffix [prefix|suffix, default: suffix] 
        delim – the character(s) separating each variable in the &words list [default: space] 

    Examples: 
    %put  %rename_string(a b c, _1);
                produces the text a=a_1 b=b_1 c=c_1
    %put %rename_string(a b c, r_, location=prefix);
                produces the text a=r_a b=r_b c=r_c
    %put  %rename_string(a|b|c, _1, delim=|);
                produces the text a=a_1 b=b_1 c=c_1
    Credit:
        source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
          (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf   
*/


%macro rename_string(words, str, delim=%str( ), location=suffix); 
    %* Verify macro arguments. ; 
    %if (%length(&words) eq 0) %then %do; 
        %put ***ERROR(rename_string): Required argument 'words' is missing.; 
        %goto exit; 
    %end; 

    %if (%length(&str) eq 0) %then %do; 
        %put ***ERROR(rename_string): Required argument 'str' is missing.; 
        %goto exit; 
    %end; 
    %if (%upcase(&location) ne SUFFIX and %upcase(&location) ne PREFIX) %then %do; 
        %put ***ERROR(rename_string): Optional argument 'location' must be; 
        %put *** set to SUFFIX or PREFIX.; 
        %goto exit; 
    %end; 

    %* Since rename_string is just a special case of parallel_join, 
    * simply pass the appropriate arguments on to that macro. ; 
    %parallel_join( 
    &words, 
    %add_string(&words, &str, delim=&delim, location=&location), 
    =, 
    delim1 = &delim, 
    delim2 = &delim 
    ) 
    %exit: 
%mend rename_string; 
%macro replace(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , code=        /* block of code containing symbolic variable */
     , key=#        /* symbolic variable to replace (#abc# etc.) */
     , osep=%str( ) /* separator between new elements */
                    /* may be %str(;) when code is statement */
                    /* if so remember to add closing semicolon */
     ) ;

 /* for elt in the list replace key in code
     LV provides override to specify external variable name instead of list.
     If the LV option is used then L and RG_: should be avoided for variable names.

examples:
    %macro rename ( list, pref=__ ) ;
         %* make a rename list from &LIST *;
         %replace ( l=&list, code = # = &pref# )
    %mend rename ;
    %put %rename ( x y z, pref=__ );

     %macro char2num ( list , pref = __ ) ;
     %* make list of char to num assignments *;
     %replace ( l=&list
        , code= %str(# = input(&pref#,best32.);)
      )
    %mend char2num ;
    %put %char2num(x y z);

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local rg_i rg_w rg_list ;
 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %length(%superq(&lv)) = 0 /*or %index(%superq(code),&key) = 0*/ %then
 %do ;
     %let rg_list = %superq(code) ;
     %goto mexit ;
 %end ;
 %do rg_i = 1 %to &sysmaxlong ;
     %let rg_w = %qscan(%superq(&lv),&rg_i,&lsep) ;
     %if %length(&rg_w) = 0 %then %goto mexit ;
     %if &rg_i = 1 %then
     %let rg_list = %sysfunc(tranwrd(%superq(code),&key,&rg_w)) ;
     %else
     %let rg_list =
     &rg_list&osep%sysfunc(tranwrd(%superq(code),&key,&rg_w)) ;
 %end ;
 %mexit:

 %unquote(&rg_list)
%mend replace ;
%macro slice(
    L,            /*list*/
    i,            /*index*/
    sep_L=%str( ),/*separator for list*/
    sep_i=%str( ) /*separator for index*/
    );

    /*
    return a sub-list sliced by a index

    examples(all produce a c d):
       %put %slice(a b c d,1 3  4);                                   
       %put %slice(%str(a, b, c, d),1 3  4,sep_L=%str(,));
       %put %slice(%str(a, b, c, d),%str(1, 3, 4),sep_L=%str(,),sep_i=%str(,)); 

    Credit:
        Jiangtang Hu (2013-03-31, http://www.jiangtanghu.com):
    */

    %let VarList = ;
    %let count=%sysfunc(countw(&i,&sep_i));

    %do j = 1 %to &count;
      %let index=%qscan(&i,&j,&sep_i);
      %let VarList = &VarList.%str( )%qscan(&L,&index,&sep_L);
    %end;

    &VarList
%mend slice;
/*%suffix_counter 
    Purpose: Create a list of variable names formed by adding a numeric counter suffix to a base name. 

    Required arguments: 
        base – the text that should be the base of the variable names 
        end – the last number in the counter 

    Optional arguments: 
        start – the first number inthe counter [default: 1] 
        zpad – the number of digits to which the counter should be padded. Use zpad=0 for no padding. [default: 0] 

    Examples: 
        %put  %suffix_counter(v, 4);
                    produces the text v1 v2 v3 v4
        %put %suffix_counter(v, 14, start=10);
                    produces the text v10 v11 v12 v13 v14
        %put  %suffix_counter(v, 4, zpad=2);
                    produces the text v01 v02 v03 v04

    Credit:
        source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
          (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf  
*/


%macro suffix_counter(base, end, start=1, zpad=0); 
%local outstr i counter; 

%* Verify macro arguments. ; 
%if (%length(&base) eq 0) %then %do; 
    %put ***ERROR(suffix_counter): Required argument 'base' is missing.; 
    %goto exit; 
%end; 
%if (%length(&end) eq 0) %then %do; 
    %put ***ERROR(suffix_counter): Required argument 'end' is missing.; 
    %goto exit; 
%end; 
%if (&end < &start) %then %do; 
    %put ***ERROR(suffix_counter): The 'end' argument must not be less; 
    %put *** than the 'start' argument.; 
    %goto exit; 
%end; 

%* Construct the outstr by looping from &start to &end, adding the counter 
* value to &base in each iteration. To handle the zero-padding, use the 
* putn function to format the counter variable with the Z. format. ; 
%let outstr=; 
%do i=&start %to &end; 
    %if (&zpad > 0) %then %do; 
        %let counter = %sysfunc(putn(&i, z&zpad..)); 
    %end; 
    %else %do; 
        %let counter = &i; 
    %end; 
    %let outstr=&outstr &base&counter; 
%end; 

%* Output the new list. ; 
&outstr 
%exit: 
%mend suffix_counter; 
%macro uqt(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , qt=%str(%")  /* type of quote mark */
     ) ;

 /* L (or &LV) is list of quoted items separated by LSEP

 return unquoted list of items separated by space
 LV provides override to specify external variable name instead list.
 If the LV option is used then L and UQT_: should be avoided for variable names.

examples:
    %put %Uqt(l="a" "b" "c");

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %length(%superq(&lv)) > 0 %then
 %do ;
     %sysfunc(compbl(%sysfunc(translate(%superq(&lv),%str( ),&qt&lsep))))
 %end ;
%mend uqt ;
%macro xprod(
     l1  =        /* first list */
   , lv1 =        /* external variable override for first list */
   , sep1=%str( ) /* separator between elements of first list */
   , l2  =        /* second list */
   , lv2 =        /* external variable override for second list */
   , sep2=%str( ) /* separator between elements of second list */
   , osep=%str( ) /* separator between elements of new list */
 );

 /* %xprod ( l1= a b , l2= c d ) produces ac ad bc bd

examples:
 %let list1 = a b ;
 %let list2 = c d ;
 %put %xprod (lv1=list1, lv2=list2);
 %put %xprod (lv1=list1, lv2=list2,osep=%str(,));

 LV1 and LV2 provide override to specify external variable name instead of lists.
 If one or more of the lists are empty then the empty list is returned.
 If the LV options are used then L1, L2, and XP_: should be avoided for variable names.

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
        (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
        (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local xp_i xp_j xp_1 xp_2 xp_list ;
 %if %length(&lv1) = 0 %then
 %let lv1 = l1 ;
 %if %length(&lv2) = 0 %then
 %let lv2 = l2 ;
 %do xp_i = 1 %to &sysmaxlong ;
   %let xp_1 = %qscan(%superq(&lv1), &xp_i, &sep1) ;
   %if %length(&xp_1) = 0 %then %goto endloop1 ;
   %do xp_j = 1 %to &sysmaxlong ;
     %let xp_2 = %qscan(%superq(&lv2), &xp_j, &sep2) ;
     %if %length(&xp_2) = 0 %then %goto endloop2 ;
     %if &xp_i = 1 and &xp_j = 1 %then
     %let xp_list = &xp_1&xp_2 ;
     %else
     %let xp_list = &xp_list&osep&xp_1&xp_2 ;
   %end ;
   %endloop2:
 %end ;
 %endloop1:
 %unquote(&xp_list)
%mend xprod ;
%macro zip(
       l1   =        /* first list */
     , lv1 =        /* external variable override for first list */
     , sep1 =%str( ) /* separator between the joined elements */
     , l2   =        /* second list */
     , lv2  =        /* external variable override for second list */
     , sep2 =%str( ) /* separator between the joined elements */
     , osep =%str( ) /* separator between new elements */
     ) ;

 /* %zip ( l1= a b , l2= c d ) produces ac bd

examples:
 %let list1 = a b ;
 %let list2 = c d ;
 %put %zip (lv1=list1, lv2=list2);
 %put %zip (lv1=list1, lv2=list2,osep =%str(,));
 %put %zip (l1=a b, l2=c d,osep =%str(,));

 If lists do not have same length shorter length used and warning to the log.
 Empty lists result in empty list and no message.
 If the LV options are used then L1, L2, and ZIP_: should be avoided for variable names.

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
          (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
          (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local zip_i zip_1 zip_2 zip_list ;
 %if %length(&lv1) = 0 %then
 %let lv1 = l1 ;
 %if %length(&lv2) = 0 %then
 %let lv2 = l2 ;
 %do zip_i = 1 %to &sysmaxlong ;
   %let zip_1 = %qscan(%superq(&lv1) , &zip_i, &sep1 ) ;
   %let zip_2 = %qscan(%superq(&lv2) , &zip_i, &sep2 ) ;
   %if %length(&zip_1) = 0 or %length(&zip_2) = 0 %then
   %goto check ;
   %if &zip_i = 1 %then
   %let zip_list = &zip_1&zip_2 ;
   %else
   %let zip_list = &zip_list&osep&zip_1&zip_2 ;
 %end ;
 %check:
 %if %length(&zip_1) > 0 or %length(&zip_2) > 0 %then
 %put WARNING: Macro ZIP - list lengths do not match - shorter used. ;
 %unquote(&zip_list)
%mend zip ;

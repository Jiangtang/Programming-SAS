/*<pre><b>
/ Program   : addautos.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To concatenate a macro library onto the sasautos path
/ SubMacros : none
/ Notes     : To allow the user to add a macro library fileref or full path name
/             to the front or at the back of the current sasautos path.
/ Usage     : %addautos(mymacros)
/ 
/===============================================================================
/ REQUIREMENTS SPECIFICATION:
/ --id--  ---------------------------description--------------------------------
/ REQ001: New items on the sasautos path should be placed either at the start of
/         the list or last on the list according to user choice.
/ REQ002: The default position should be "first" on the sasautos path.
/ REQ003: The position specified should not be case sensitive.
/ REQ004: The position should be triggered by the first letter such that "first"
/         or "front" is activated by the first letter being an "F" whereas
/         "last" can be triggered with the first letter being an "L" or a "B"
/         for "back".
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ autolib           (pos) Name of the macro library to concatenate. This should
/                   be unquoted if it is a fileref or quoted if a path name.
/ pos               (pos - unquoted) Position in the list. Can be first or last
/                   or front or back (defaults to first)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  24Mar09         No longer puts commas in the sasautos path definition
/                      and requirements specification added to header.
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: addautos v1.1;

%macro addautos(autolib,pos);
  %local place autolist err;
  %let err=ERR%str(OR);
  %let place=&pos;
  %if %length(&place) EQ 0 %then %let place=first;
  %let place=%substr(%upcase(&place),1,1);
  %if %length(%sysfunc(compress(&place,FLB))) GT 0 %then 
  %put &err: (addautos) Position &pos is not recognised;
  %else %do;
    %let autolist=%sysfunc(compress(%sysfunc(getoption(sasautos)),%str(%(%))));
    %if "&place" EQ "F" %then %do;
      options sasautos=(&autolib &autolist);
    %end;
    %else %do;
      options sasautos=(&autolist &autolib);
    %end;
  %end;
%mend addautos;
/*<pre><b>
/ Program      : adddecodevars.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : To add decode variables where a user format is specified
/ SubMacros    : %sysfmtlist
/ Notes        : This macro allows the programmer to better understand their
/                data by making a copy of a dataset with user-formatted
/                variables decoded as new variables placed after the user-
/                formatted variables which should have their user formats
/                removed so that both the raw values and formatted values can be
/                seen side by side.
/
/                Length of decode variable is determined from the format length.
/                Decode variable names will be same as the ones being decoded
/                but with the suffix defined to this macro added. The variables
/                will be reordered such that a decode variable will logically
/                follow the variable being decoded. System formats will not be
/                decoded and the list is maintained in the %sysfmtlist macro.
/
/ Usage        : %adddecodevars(dsin=ds1,dsout=ds2)
/ 
/===============================================================================
/ REQUIREMENTS SPECIFICATION:
/ --id--  ---------------------------description--------------------------------
/ REQ001: The variables that are the decode of the orginal user-formatted
/         variables should be positioned immediately after the corresponding 
/         coded variable.
/ REQ002: The decoded variables should have the same name as the coded variables
/         but with a general suffix added.
/ REQ003: It should be possible for the user to change the suffix for the
/         decoded variable names.
/ REQ004: The user should have the option of showing the coded variables as
/         originally formatted, if they so wish, but the default should be to
/         show these coded variables as unformatted in the output dataset.
/ REQ005: Whether a variable is user-formatted or system-formatted should be
/         determined by reference to the %sysfmtlist macro which contains a list
/         of system formats that might be encountered during normal use.
/ REQ006: The length of the decoded variables should be optimised to save space
/         while at the same time not showing truncated decoded values. The
/         length of each decoded variable will be the same as the format length
/         in the "formatl" variable obtained from a "proc contents" of the
/         original dataset.
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsin=             Input dataset
/ dsout=            Output dataset (no modifiers)
/ suffix="__D"      Suffix to use for the decode variable. This will be added
/                   at the end of the name of the variable being decoded.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  24Mar09         requirements specification added
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: adddecodevars v1.0;

%macro adddecodevars(dsin=,dsout=,suffix="__D",killusrfmts=yes);

  %local errflag err;
  %let err=ERR%str(OR);
  %let errflag=0;


        /*----------------------------------*
            check that parameters are set
         *----------------------------------*/

  %if not %length(&dsin) %then %do;
    %let errflag=1;
    %put &err: (adddecodevars) No input dataset defined to dsin=;
  %end;

  %if not %length(&dsout) %then %do;
    %let errflag=1;
    %put &err: (adddecodevars) No output dataset defined to dsout=;
  %end;

  %if not %length(&suffix) %then %do;
    %let errflag=1;
    %put &err: (adddecodevars) No characters defined to sufFix=;
  %end;

  %if &errflag %then %goto exit;


        /*----------------------------------*
              prepare parameter settings
         *----------------------------------*/

  %let suffix="%sysfunc(compress(&suffix,%str(%'%")))";

  %if not %length(&killusrfmts) %then %let killusrfmts=yes;
  %let killusrfmts=%upcase(%substr(&killusrfmts,1,1));


        /*----------------------------------*
             get contents of input dataset
         *----------------------------------*/

  *- Option "fmtlen" is used to get lengths of user formats. -;
  proc contents noprint fmtlen varnum data=&dsin mtype=data out=_adddecont;
  run;

  *- put in logical variable order -;
  proc sort data=_adddecont;
    by memname varnum;
  run;

        /*----------------------------------*
           create long strings of variables 
         *----------------------------------*/

  data _adddecont;
    *- long lists of retain, length and user variables -;
    length retlist lenlist usrlist $ 32767;
    retain retlist "retain" lenlist "length" usrlist "format";
    set _adddecont end=last;
    *- this is trying to identify non-user formats -;
    if format in (" " %sysfmtlist) then _fmt="SYS";
    else _fmt="USR";
    *- add to the retain list for future reordering of variables -;
    retlist=trim(retlist)||" "||trim(name);
    if _fmt="USR" then do;
      *- add decode variable to the length statement list -;
      lenlist=trim(lenlist)||" "||trim(name)||&suffix||" $ "||compress(put(formatl,4.));
      *- add decode variable to the retain statement list -;
      retlist=trim(retlist)||" "||trim(name)||&suffix;
      *- add original variable to the format kill list -;
      usrlist=trim(usrlist)||" "||name;
    end;
    if last then do;
      *- write the long lists out to local macro variables -;
      call symput('retlist',trim(retlist));
      call symput('lenlist',trim(lenlist));
      call symput('usrlist',trim(usrlist));
    end;
    keep name type _fmt;
  run;


        /*----------------------------------*
                generate call executes
         *----------------------------------*/

  data _null_;
    set _adddecont end=last;
    *- start of generated data step -;
    if _n_=1 then do;
      call execute('data &dsout;');
      call execute('&lenlist;');
      call execute('set &dsin;');
    end;
    *- generate the decoding code and the label statement -;
    if _fmt="USR" then do;
      if type=2 then do;
        *- variable type is character -;
        call execute(trim(name)||&suffix||"=putc("||trim(name)||",vformat("||trim(name)||"));");
      end;
      else do;
        *- variable type is numeric -;
        call execute(trim(name)||&suffix||"=putn("||trim(name)||",vformat("||trim(name)||"));");
      end;
      call execute("label "||trim(name)||&suffix||"='Decode of variable "||trim(name)||"';");
    end;
    *- end of data step followed by reordering data step -;
    if last then do;
      call execute('run;');
      call execute('data &dsout;');
      call execute('&retlist;');
      call execute('set &dsout;');
      %if "&killusrfmts" EQ "Y" %then %do;
        call execute('&usrlist;');
      %end;
      call execute('run;');
    end;
  run;


        /*----------------------------------*
                   tidy up and exit
         *----------------------------------*/

  proc datasets nolist;
    delete _adddecont;
  run;
  quit;

  %goto skip;
  %exit: %put &err: (adddecodevars) Leaving maco due to problem(s) listed;
  %skip:

%mend adddecodevars;

/*<pre><b>
/ Program      : adjfmt.sas
/ Version      : 1.2
/ Author       : Roland Rashleigh-Berry
/ Date         : 29-Jan-2012
/ Purpose      : To create a format based on a current format that can be
/                adjusted by indenting the labels or by adding leading and
/                trailing underscores.
/ SubMacros    : %words %fmtpath %verifyb %varlen
/ Notes        : The informat will be called "adjfmt" by default but a leading
/                $ will be added for a character format. The name of the format
/                (corrected with a leading $ if needed and without a trailing
/                period) will also be written to the global macro variable
/                _adjfmt_ so that it can be resolved in your program code.
/ Usage        : %adjfmt(agernge,adjrnge,indent=4)
/                %adjfmt(agernge,adjrnge,underscore=yes)
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ format            (pos) Format name to create adjusted format from
/ adjfmt=adjfmt     (pos) Name of the adjusted new format to create. Default is
/                   "adjfmt". A $ sign will be added for character formats if
/                   this is missing. This name will also be written to the
/                   global macro variable _adjfmt_ .
/                   ----- you must set one of the two following adjustments ----
/ indent=0          Number of spaces to indent the label
/ underscore=no     Whether to add leading and trailing underscores to the label
/                   (will override indent= usage if set to yes).
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  21Dec11         New (v1.0)
/ rrb  02Jan12         Notes disabled (v1.1)
/ rrb  29Jan12         2nd parameter was not positional but is now (v1.2)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: adjfmt v1.2;

%macro adjfmt(format,
              adjfmt,
              indent=0,
          underscore=no);

  %global _adjfmt_;
  %let _adjfmt_=;
  %local ext i cat catlist gotit err fmtname len savopts;
  %let err=ERR%str(OR);

  %let savopts=%sysfunc(getoption(notes));
  options nonotes;

  %if not %length(&adjfmt) %then %let adjfmt=adjfmt;

  %if not %length(&indent) %then %let indent=0;

  %if not %length(&underscore) %then %let underscore=no;
  %let underscore=%upcase(%substr(&underscore,1,1));

  %*- drop the "." ending and any numbers immediately preceding it -;
  %let fmtname=%upcase(%substr(&format,1,%verifyb(&format,0123456789.)));
  %let format=&fmtname;
  %let adjfmt=%upcase(%substr(&adjfmt,1,%verifyb(&adjfmt,0123456789.)));

  %let ext=FORMAT;
  %if "%substr(&fmtname,1,1)" EQ "$" %then %do;
    %let ext=FORMATC;
    %let fmtname=%substr(&fmtname,2);
    %if "%substr(&adjfmt,1,1)" NE "$" %then %let adjfmt=$&adjfmt;
  %end;

  %let catlist=%fmtpath;

  %let gotit=0;
  %do i=1 %to %words(&catlist);
    %let cat=%scan(&catlist,&i,%str( ));
    %if %sysfunc(cexist(&cat..&fmtname..&ext)) %then %do;
      %let gotit=1;
      proc format lib=&cat cntlout=_adjfmt;
        select &format;
      run;
      quit;
      %let len=%eval(%varlen(_adjfmt,label,x)+%sysfunc(max(2,&indent)));
      data _adjfmt;
        length label $ &len;
        retain fmtname "&adjfmt";
        set _adjfmt(keep=start label rename=(label=xlabel));
        %if &underscore EQ Y %then %do;
          label="_"||trim(xlabel)||"_";
        %end;
        %else %if &indent GT 0 %then %do;
          label=repeat(" ",%eval(&indent-1))||xlabel;
        %end;
        %else %do;
          label=xlabel;
        %end;
        drop xlabel;
      run;
      proc format cntlin=_adjfmt;
      run;
      proc datasets nolist;
        delete _adjfmt;
      run;
      quit;
      %let i=99;
      %let _adjfmt_=&adjfmt;
    %end;
  %end;

  %if not &gotit %then %put &err: (adjfmt) Format "&format" not found;

  options &savopts;

%mend adjfmt;
/*<pre><b>
/ Program   : after.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to give you what comes directly after a
/             target string.
/ SubMacros : none
/ Notes     : This macro is for scanning text to give you the next space-
/             delimited word or quote-enclosed string directly following one
/             of a list of nine target strings that you can specify. For
/             multiple target strings, it will use the first match. The search
/             is not case sensitive. Note that if your target contains an equals
/             sign then you must enclose it in %str( ) otherwise it is
/             interpreted as a parameter. See usage notes.
/ Usage     : %let width=%after(&str,%str(width=),%str( w=));
/ 
/===============================================================================
/ REQUIREMENTS SPECIFICATION:
/ --id--  ---------------------------description--------------------------------
/ REQ001: The user be allowed to specify up to nine target strings.
/ REQ002: Macro parameters should be positional.
/ REQ003: This macro should be a function-style macro that returns a result.
/ REQ004: For multiple target strings then what follows the first matching
/         target string will be returned. 
/ REQ005: If what follows the target string is a single-quoted or double-quoted
/         string then that whole string (including quotes) should be returned.
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos) String to search
/ target1-9         (pos) Target strings
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  24Mar09         Requirements specification added to header
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: after v1.0;

%macro after(string,
            target1,
            target2,
            target3,
            target4,
            target5,
            target6,
            target7,
            target8,
            target9);

  %local word i start len qtype;
  %let len=0;
  %do i=1 %to 9;
    %if %index(%qupcase(&string),%qupcase(&&target&i)) %then %do;
      %let start=%index(%qupcase(&string),%qupcase(&&target&i))+%length(&&target&i);
      %if %qsubstr(&string,&start,1) EQ %str(%')
       or %qsubstr(&string,&start,1) EQ %str(%") %then %do;
         %let qtype=%qsubstr(&string,&start,1);
         %if %index(%qsubstr(&string,&start+1),%str(&qtype)) 
           %then %let len=%eval(%index(%qsubstr(&string,&start+1),%str(&qtype))+1);
         %if &len %then %let word=%qsubstr(&string,&start,&len);
         %else %let word=%qscan(%qsubstr(&string,&start),1,%str( ));
      %end;
      %else %let word=%qscan(%qsubstr(&string,&start),1,%str( ));
      %let i=9;
    %end;
  %end;

&word

%mend after;
/*<pre><b>
/ Program   : age.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : In-datastep function-style macro to calculate the age of a person
/             on a date.
/ SubMacros : none
/ Notes     : Used in a data step it calculates the age of a person, given a
/             date and a date of birth, as an integer number of years.
/
/             Use this in a data step as shown in the usage notes.
/ Usage     : data test;
/               age=%age(dob,date);
/===============================================================================
/ REQUIREMENTS SPECIFICATION:
/ --id--  ---------------------------description--------------------------------
/ REQ001: To calculate the age as an integer number of years.
/ REQ002: Should be used within a data step.
/ REQ003: Macro parameters should be positional.
/ REQ004: This macro should be a function-style macro that returns a result to
/         a data step variable.
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dob               (pos) Date of birth
/ date              (pos) Date on which age is to be calculated
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  27Mar09         Requirements specification added to header
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: age v1.0;

%macro age(dob,date);
  year(&date)-year(&dob)-1+((month(&date)>month(&dob)) 
  or ((month(&date)=month(&dob)) and (day(&date)>=day(&dob))))
%mend age;
/*<pre><b>
/ Program   : agedec.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : In-datastep function-style macro to calculate the age of a person
/             on a date as a decimal age.
/ SubMacros : none
/ Notes     : Used in a data step to calculate the age of a person as a
/             fractional number of years. The fractional part of the age will be
/             based on the number of days since last birthday compared with the
/             number of days from the past birthday to the next birthday.
/
/             Note that an assumption being made in the code is that for people
/             born on the 29th Feb on leap years and with 29th Feb recorded on 
/             their birth certificates then they are legally a year older on
/             1st March on non-leap years. This is true in the UK, presumably in
/             the US as well, but for other countries, they might legally be a 
/             year older on the 28th Feb on non-leap years. If that is the case
/             then you can set the parameter to mar1=no and 28Feb will be used
/             as the birthday for non-leap years for those born on 29Feb.
/ Usage     : data test;
/               agedec=%agedec(dob,date);
/===============================================================================
/ REQUIREMENTS SPECIFICATION:
/ --id--  ---------------------------description--------------------------------
/ REQ001: The fractional part of the age will be calculated as the number of
/         day since last birthday divided by the number of days between the last
/         birthday and the next birthday.
/ REQ002: Should be used within a data step.
/ REQ003: Date parameters should be positional.
/ REQ004: This macro should be a function-style macro that returns a result to
/         a data step variable.
/ REQ005: The user be allowed to specify mar1=no so that people born on a leap
/         year on 29FEB celebrate their birthday on 28Feb rather than Mar01
/         which is the default.
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dob               (pos) Date of birth
/ date              (pos) Date on which age is to be calculated
/ mar1=yes          Whether those born on Feb29 on a leap year are legally a
/                   year older on Mar1 on non-leap years. If set to "no" (no
/                   quotes) then Feb28 is assumed for celebrating the birth date
/                   otherwise Mar01 is assumed. It is highly recommended you
/                   keep to the default of "yes" (i.e. Mar01 is assumed) unless
/                   you have sound knowledge otherwise.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  03Apr08         mar1=yes parameter added for version 2.0
/ rrb  27Mar09         Requirements specification added to header
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: agedec v2.0;

%macro agedec(dob,date,mar1=yes);

  %local age;

  %if not %length(&mar1) %then %let mar1=yes;
  %let mar1=%substr(%upcase(&mar1),1,1);

  %let age=(
  year(&date)-year(&dob)-(month(&date)<month(&dob) or (month(&date)=month(&dob) 
  and day(&date)<day(&dob)))
  );

  %if &mar1 NE N %then %do;
    &age + 
    (
    ( &date-(intnx('year',&dob-1,&age,'S')+1) ) / 
    (
    (intnx('year',&dob-1,&age+1,'S')+1) -
  
    (intnx('year',&dob-1,&age,'S')+1)
    )
    )
  %end;
  %else %do;
    &age + 
    (
    ( &date-intnx('year',&dob,&age,'S') ) / 
    (
     intnx('year',&dob,&age+1,'S') -
 
     intnx('year',&dob,&age,'S')
    )
    )
  %end;

%mend agedec;
/*<pre><b>
/ Program   : aligndp.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : In-datastep macro to create a string from a numeric value with
/             decimal points aligned.
/ SubMacros : none
/ Notes     : This must be used in a data step. If the number can not be aligned
/             without losing digits then the alignment will not be correct.
/ Usage     : %aligndp(numvar,charvar,4);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ numvar            (pos) numeric variable
/ charvar           (pos) output character variable to contain aligned number
/ dpos              (pos) required position of decimal point
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb 04May11          Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: aligndp v1.0;

%macro aligndp(numvar,charvar,dpos);
  length _fmt $ 8;
  _fmt='best'||compress(put(min(32,vlength(&charvar)),2.))||'.';
  &charvar=putn(&numvar,_fmt);
  if index(&charvar,'.')>&dpos
    and substr(&charvar,1,index(&charvar,'.')-&dpos)=' ' 
    then &charvar=substr(&charvar,index(&charvar,'.')-&dpos+1);
  else if not index(&charvar,'.') then do;
    if substr(&charvar,1,vlength(&charvar)-&dpos+1)=' '
      then &charvar=substr(&charvar,vlength(&charvar)-&dpos+2);
    else &charvar=left(&charvar);
  end;
%mend aligndp;
/*<pre><b>
/ Program   : allafter.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 26-May-2014
/ Purpose   : Function-style macro to give you everything following a target
/             string.
/ SubMacros : none
/ Notes     : It does an "index" on a string to find the first occurrence of
/             the target string and returns all the string after the end of the
/             target. The search is case sensitive.
/ Usage     : %let rest=%allafter(&str,xx);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos) String to search
/ target            (pos) Target string (case sensitive)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26May14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: allafter v1.0;

%macro allafter(string,target);
  %local pos;
  %if %sysfunc(index(&string,&target)) %then %do;
    %let pos=%eval(%sysfunc(index(&string,&target))+%length(&target));
    %if &pos LE %length(&string) %then %qsubstr(&string,&pos);
  %end;
%mend allafter;
/*<pre><b>
/ Program   : allafterc.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 26-May-2014
/ Purpose   : Function-style macro to give you everything following any found
/             target string character.
/ SubMacros : none
/ Notes     : It does an "indexc" on a string to find the first occurrence of
/             any of the characters in the target string and returns all the
/             string after that. If none of the target characters are found then
/             a null string is returned. The search is case sensitive.
/ Usage     : %let rest=%allafterc(&str,\/);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos) String to search
/ target            (pos) Target string character(s) (case sensitive)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26May14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: allafterc v1.0;

%macro allafterc(string,target);
  %local pos;
  %if %sysfunc(indexc(&string,&target)) %then %do;
    %let pos=%sysfunc(indexc(&string,&target));
    %if &pos LT %length(&string) %then %qsubstr(&string,&pos+1);
  %end;
%mend allafterc;
/*<pre><b>
/ Program      : allfmtvals.sas
/ Version      : 1.3
/ Author       : Roland Rashleigh-Berry
/ Date         : 13-Apr-2011
/ Purpose      : Create a dataset with every start value of a format in it
/ SubMacros    : none
/ Notes        : Works for both numeric and character formats. For character
/                formats it is better if you define the correct length to the
/                length= parameter. You can also specify a decode variable in
/                the output dataset.
/ Usage        : %allfmtvals(fmt=$country,var=country,dsout=temp1,length=2)
/                %allfmtvals(fmt=site,var=site,dsout=temp2)
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ fmt               Format name (can end with a "." or not)
/ dsout             Output data set name (no modifiers)
/ var               Variable to go in output dataset containing all the start
/                   values of the format.
/ length=8          Default length for the output variable if format is a
/                   character format.
/ decodevar         Decode variable (optional)
/ decodelen         Length of decode variable
/ nmissval=.        Default missing numeric value to be excluded from the output
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  14jul05         decodevar= and decodelen= added so that the decoded
/                      version of the variable can be put in the output dataset.
/ rrb  13Feb07         "macro called" message added
/ rrb  12Apr11         Added nmissval= parameter and indented code
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: allfmtvals v1.3;

%macro allfmtvals(fmt=,dsout=,var=,length=8,decodevar=,decodelen=160,nmissval=.);

  %local errflag dummyval type err;
  %let errflag=0;
  %let err=ERR%STR(OR);


   /*----------------------*
        Check parameters
    *----------------------*/

  %if not %length(&fmt) %then %DO;
    %let errflag=1;
    %put &err: (allfmtvals) No format supplied to fmt=;
  %end;
  %else %if "%substr(&fmt,%length(&fmt),1)" NE "." %then %let fmt=&fmt..;

  %if not %length(&dsout) %then %DO;
    %let errflag=1;
    %put &err: (allfmtvals) No output dataset supplied to dsout=;
  %end;

  %if not %length(&var) %then %DO;
    %let errflag=1;
    %put &err: (allfmtvals) No variable name supplied to var=;
  %end;

  %if &errflag %then %goto exit;

  %if "%substr(&fmt,1,1)" EQ "$" %then %DO;
    %let type=CHAR;
    %if not %length(&length) %then %let length=8;
    %let dummyval=" ";
  %end;
  %else %DO;
    %let type=NUM;
    %let dummyval=&nmissval;
  %end;


   /*-----------------------*
             Process
    *-----------------------*/

  data &dsout;
    %if &type EQ CHAR %then %DO;
      length &var $ &length;
    %end;
    &var=&dummyval;
    format &var &fmt;
  run;

  proc summary nway missing completetypes data=&dsout;
    class &var / preloadfmt;
    output out=&dsout(drop=_type_ _freq_ where=(&var ne &dummyval));
  run;

  %if %length(&decodevar) %then %DO;
    data &dsout;
      length &decodevar $ &decodelen;
      set &dsout;
      &decodevar=put(&var,&fmt);
    run;
  %end;


   /*---------------------*
             Exit
    *---------------------*/

  %goto skip;
  %exit:
  %put &err: (allfmtvals) Leaving macro due to problem(s) listed;
  %skip:
%mend allfmtvals;
/*<pre><b>
/ Program   : alluniq.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To create a dataset with all unique occurences of a variable
/             throughout a library.
/ SubMacros : %hasvars
/ Notes     : The output dataset will be in sorted order if valid
/ Usage     : %alluniq(in,subject,allsubj)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ libref            (pos) Libref
/ variable          (pos) Variable name
/ dsout             (pos) Output dataset name (defaults to "alluniq")
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  16Jun03         Create null output dataset and use %hasvars
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: alluniq v1.0;

%macro alluniq(libref,variable,dsout);

  %local err;
  %let err=ERR%str(OR);

  %if not %length(&libref) %then %let libref=%sysfunc(getoption(user));
  %if not %length(&libref) %then %let libref=work;

  %if not %length(&variable) %then %do;
    %put &err: (alluniq) No variable name specified;
    %goto skip;
  %end;

  %if not %length(&dsout) %then %let dsout=alluniq;


  *- create null output dataset -;
  data &dsout;
  _u_m_b_j=.;
  run;


  data _null_;
    set sashelp.vcolumn(where=(libname="%upcase(&libref)" 
                               and upcase(name)="%upcase(&variable)"));
    if _n_=1 then do;
      call execute('proc sort nodupkey data='||trim(libname)||'.'||trim(memname)||
      "(keep=&variable) out=&dsout;by &variable;run;");
    end;
    else do;
      call execute('proc sort nodupkey data='||trim(libname)||'.'||trim(memname)||
      "(keep=&variable) out=_alluniq;by &variable;");
      call execute('proc append base=&dsout data=_alluniq;run;');
    end;
  run;


  %if %hasvars(&dsout,&variable) %then %do;
    proc sort nodupkey data=&dsout;
      by &variable;
    run;
  %end;
  %else %put &err: (alluniq) Library &libref has no instances of variable &variable;


  proc datasets nolist;
    delete _alluniq;
  run;
  quit;

  %skip:

%mend alluniq;
/*<pre><b>
/ Program   : appmvar.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 23-Aug-2012
/ Purpose   : Function-style macro to append a string onto an existing macro
/             variable.
/ SubMacros : none
/ Notes     : This macro has very limited functionality and was written to make
/             your code less messy. It is where you are accumulating messages in
/             a macro variable and when you append onto the end of it you want
/             there to be a separating string to delimit the different messages
/             such as using %str(; ). This macro takes care of the logic of
/             checking what is already there and what you want to add and will
/             only use the separating string if the macro variable being
/             appended onto has contents as well as the string you are appending
/             is non-empty.
/ Usage     : %let err_msg=%appmvar(err_msg,This is another error message);
/             %let err_msg=%appmvar(err_msg,
/             Add this comma-delimited list (%nrbquote(&list)));
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ mvar              (pos) Name of macro variable to append onto
/ append            (pos) String to append
/ sep=%str(; )      Separating string (defaults to "; ")
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  23Aug12         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: appmvar v1.0;

%macro appmvar(mvar,append,sep=%str(; ));
  %if %length(&&&mvar) and %length(&append) %then %do;
&&&mvar&sep&append
  %end;
  %else %if %length(&append) %then %do;
&append
  %end;
  %else %do;
&&&mvar
  %end;
%mend appmvar;
/*<pre><b>
/ Program   : attrc.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ SubMacros : none
/ Purpose   : Function-style macro to return a character attribute of a dataset
/ Notes     : This is a low-level utility macro that other shell macros will
/             call. About all you would use this for is to get the dataset label
/             and the variables a dataset is sorted by.
/
/             This macro will only work correctly for datasets (i.e. not views)
/             and where there are no dataset modifiers.
/
/ Usage     : %let dslabel=%attrc(dsname,label);
/             %let sortseq=%attrc(dsname,sortedby);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name (pos) (do not use views or dataset modifiers)
/ attrib            Attribute (pos)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  17Dec07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: attrc v1.0;

%macro attrc(ds,attrib);
  %local dsid rc err;
  %let err=ERR%str(OR);
  %let dsid=%sysfunc(open(&ds,is));
  %if &dsid EQ 0 %then %do;
    %put &err: (attrc) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
%sysfunc(attrc(&dsid,&attrib))
    %let rc=%sysfunc(close(&dsid));
  %end;
%mend attrc;
/*<pre><b>
/ Program   : attrn.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return a numeric attribute of a dataset
/ SubMacros : none
/ Notes     : This is a low-level utility macro that other shell macros will
/             call. The full list of attributes can be found in the SAS
/             documentation. The most common ones used will be CRDTE and MODTE
/             (creation and last modification date), NOBS and NLOBS (number of
/             observations and number of logical [i.e. not marked for deletion]
/             observations) and NVARS (number of variables).
/
/             This macro will only work correctly for datasets (i.e. not views)
/             and where there are no dataset modifiers. If you need to subset
/             the data using a where clause or subset by using other means then
/             apply the subsetting and create a new dataset before calling this
/             macro.
/
/ Usage     : %let nobs=%attrn(dsname,nlobs);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name (pos) (do not use views or dataset modifiers)
/ attrib            Attribute (pos)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  17Dec07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: attrn v1.0;

%macro attrn(ds,attrib);
  %local dsid rc err;
  %let err=ERR%str(OR);
  %let dsid=%sysfunc(open(&ds,is));
  %if &dsid EQ 0 %then %do;
    %put &err: (attrn) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
%sysfunc(attrn(&dsid,&attrib))
    %let rc=%sysfunc(close(&dsid));
  %end;
%mend attrn;
/*<pre><b>
/ Program   : attrv.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return a variable attribute
/ SubMacros : none
/ Notes     : This is a low-level utility macro that other shell macros will
/             call. The full list of variable attributes can be found in the
/             SAS documentation. The most common ones used will be VARTYPE,
/             VARLEN, VARLABEL, VARFMT and VARINFMT.
/
/             This macro will only work correctly for datasets (i.e. not views)
/             and where there are no dataset modifiers.
/
/ Usage     : %let vartype=%attrv(dsname,varname,vartype);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name (pos) (do not use views or dataset modifiers)
/ var               Variable name (pos)
/ attrib            Attribute (pos)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  17Dec07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: attrv v1.0;

%macro attrv(ds,var,attrib);
  %local dsid rc varnum err;
  %let err=ERR%str(OR);
  %let dsid=%sysfunc(open(&ds,is));
  %if &dsid EQ 0 %then %do;
    %put &err: (attrv) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let varnum=%sysfunc(varnum(&dsid,&var));
    %if &varnum LT 1 %then %put &err: (attrv) Variable &var not in dataset &ds;
    %else %do;
%sysfunc(&attrib(&dsid,&varnum))
    %end;
    %let rc=%sysfunc(close(&dsid));
  %end;
%mend attrv;
/*<pre><b>
/ Program   : bydrop.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To drop by-group residuals
/ SubMacros : none
/ Notes     : If the output dataset name is missing then the dropping of the by-
/             group residuals will be applied to the input dataset.
/             You would typically use this macro to drop the end observations
/             for a previous day.
/ Usage     : %bydrop(dsin,by1 by2)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsin              (pos) Input dataset.
/ by                (pos) By group variables. If none specified then first
/                   "sortedby" variable assumed.
/ dsout             (pos) Output dataset. If not specified then defaults to same
/                   as input dataset.
/ fraction=0.1      If this fraction or less compared with maximum by-group
/                   observation count then drop residuals.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: bydrop v1.0;

%macro bydrop(dsin,by,dsout,fraction=0.1);

  %local errflag err bymax;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&dsin) %then %do;
    %let errflag=1;
    %put &err: (bydrop) No input dataset specified;
  %end;

  %if &errflag %then %goto exit;

  %if not %length(&by) %then %let by=%scan(%sortedby(%scan(&dsin,1,%str(%())),1,%str( ));

  %if not %length(&by) %then %do;
    %let errflag=1;
    %put &err: (bydrop) No "by" variables specified and none could be assumed;
  %end;

  %if &errflag %then %goto exit;

  %if not %length(&dsout) %then %let dsout=%scan(&dsin,1,%str(%());

  proc sort data=&dsin out=_bydrop;
    by &by;
  run;

  proc summary nway data=_bydrop(keep=&by);
    class &by;
    output out=_bydropa(drop=_type_ rename=(_freq_=_count));
  run;
  proc summary nway data=_bydropa;
    id _count;
    output out=_bydropb(drop=_type_ _freq_);
  run;
  data _null_;
    set _bydropb;
    call symput('bymax',compress(put(_count,11.)));
  run;

  data _bydropa;
    set _bydropa(where=((_count/&bymax)>&fraction));
    keep &by;
  run;

  data &dsout;
    merge _bydropa(in=_by) _bydrop;
    by &by;
    if _by;
  run;

  proc datasets nolist;
    delete _bydrop _bydropa _bydropb;
  run;
  quit;

  %goto skip;
  %exit: %put &err: (bydrop) Leaving macro due to problem(s) listed;
  %skip:

%mend bydrop;
/*<pre><b>
/ Program   : bytitle.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To drop the last title if it is a "by" title and write it to the
/             global macro variable _bytitle_ instead.
/ SubMacros : %maxtitle %casestrvar
/ Notes     : A "by" title, as far as this macro is concerned, is any lastly
/             defined title that contains "#BYVAR" or "#BYVAL" in the uppercased
/             text. These keywords wil be capitalized in the text written to the
/             global macro variable _bytitle_ for convenience.
/ Usage     : %bytitle
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ 
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: bytitle v1.0;

%macro bytitle;

  %global _bytitle_;
  %let _bytitle_=;

  %maxtitle

  data _null_;
    length text $ 200;
    set sashelp.vtitle(where=(type='T' and number=&_maxtitle_));
    if index(upcase(text),'#BYVAR') or index(upcase(text),'#BYVAL') then do;
      %casestrvar(text,'#BYVAR');
      %casestrvar(text,'#BYVAL');
      call symput('_bytitle_',text);
      call execute("title&_maxtitle_;");
    end;
  run;

%mend bytitle;
/*<pre><b>
/ Program      : capmac.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 11-Jan-2013
/ Purpose      : Function-style macro to capitalise the first letter of each
/                word in a macro string.
/ SubMacros    : %words %quotelst (%qlowcase from SI supplied autocall library
/                is called so this must be on the sasautos path).
/ Notes        : You can specify words to ignore. Case must match for these.
/                If the string you supply might contain commas or unbalanced
/                quotes then you should use %nrbquote() around it. See usage.
/ Usage        : %let tidy=%capmac(%nrbquote(A, B AND C'S RESULTS));
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos) Macro string to convert
/ ignore            List of strings (separated by spaces) to ignore
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/ rrb  11Jan13         Header tidy. %lowcase removed from submacro list and
/                      use of %qlowcase documented. %nrbquote() recommended in
/                      place of %bquote() in Notes and Usage. Version number
/                      unchanged as no change made to the macro code (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: capmac v1.0;

%macro capmac(string,ignore=);

  %local i igquote bit words;

  %if %length(&ignore) %then %let igquote=%quotelst(&ignore);
  %let words=%words(&string);

  %do i=1 %to &words;
    %let bit=%qscan(&string,&i,%str( ));
    %if %length(&ignore) %then %do;
      %if %index(&igquote,"%bquote(&bit)") %then %do;
&bit
        %goto done;
      %end;
    %end;
    %let bit=%qlowcase(&bit);
  
    %*- One character word -;
    %if %length(&bit) EQ 1 %then %do;
      %if &i EQ 1 %then %do;
%qupcase(&bit)
      %end;
      %else %if "%bquote(&bit)" EQ "a" %then %do;
a
      %end;
      %else %do;
%qupcase(&bit)
      %end;
     %end;
  
    %*- Longer than one character word -;
    %else %do;
      %*- always capitalise the first word -;
      %if &i EQ 1 %then %do;
%qupcase(%substr(&bit,1,1))%qsubstr(&bit,2)
      %end;
      %*- leave join words as lower text if not the last word -;
      %else %if %index("an" "and" "as" "at" "but" "by" "for" "in" "is" "it" "of"
                       "on" "or" "so" "that" "the" "to" "when" "with",
        "%bquote(&bit)") and (&i LT &words) %then %do;
&bit
      %end;
      %*- all other cases -;
      %else %do;
%qupcase(%substr(&bit,1,1))%qsubstr(&bit,2)
      %end;
    %end;
  
  %done:
  %end;

%mend capmac;
/*<pre><b>
/ Program      : capvar.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : In-datastep macro to tidy case of text in a variable
/ SubMacros    : none
/ Notes        : Must be used inside a data step
/ Usage        : data lparmcd;
/                  set lparmcd;
/                  %capvar(put(lparmcd,lparmcd.),newvar,
/                  ignore="SGOT" "SGPT" "PTT" "LDH" "GGT" "BUN");
/                run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ invar             (pos) Input variable (but can be an expression - see usage)
/ outvar            (pos) Output variable name
/ outlen=80         Output variable length
/ ignore            List of strings to ignore (in quotes separated by spaces)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: capvar v1.0;

%macro capvar(invar,outvar,outlen=80,ignore=);

  length &outvar $ &outlen
         _capvar $ 40;

  _capvari=1;
  do while(scan(&invar,_capvari," ") NE " ");
    _capvari=_capvari+1;
  end;
  _capvarwords=_capvari-1;

  _capvari=1;
  &outvar=" ";
  do while(scan(&invar,_capvari," ") NE " ");
    _capvar=scan(&invar,_capvari," ");
    %if %length(&ignore) %then %do;
    if _capvar in (&ignore) then do;
      if &outvar=" " then &outvar=_capvar;
      else &outvar=trim(&outvar)||" "||_capvar;
      goto _done;
    end;
    %end;
    _capvar=lowcase(_capvar);
    if length(_capvar)=1 then do;
      if _capvari=1 then &outvar=upcase(_capvar);
      else if _capvar="a" then &outvar=trim(&outvar)||" a";
      else &outvar=trim(&outvar)||" "||upcase(_capvar);
    end;
    else do;
      *- always capitalise the first word -;
      if _capvari=1 then &outvar=upcase(substr(_capvar,1,1))||substr(_capvar,2);
      *- leave join words as lower text if not the last word -;
      else if _capvar in ("an" "and" "as" "at" "but" "by" "for" "in" "is" "it" "of"
                         "on" "or" "so" "that" "the" "to" "when" "with")
        and (_capvari < _capvarwords) then &outvar=trim(&outvar)||" "||_capvar;
      *- all other cases -;
      else &outvar=trim(&outvar)||" "||upcase(substr(_capvar,1,1))||substr(_capvar,2);
    end;
    %if %length(&ignore) %then %do;
  _done:
    %end;
    _capvari=_capvari+1;
  end;
  drop _capvari _capvar _capvarwords;

%mend capvar;
/*<pre><b>
/ Program   : casestrmac.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to force mixed case forms of a string into
/             the string itself for a macro expression.
/ SubMacros : none
/ Notes     : This is a function-style macro. See usage notes. If the macro
/             expression contains equals signs then enclose in %str(). If it
/             contains commas then enclose in %quote().
/ Usage     : %let newtext=%casestrvar(&oldtext,Roland);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) Original string.
/ targ              (pos) Target string (unquoted).
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: casestrmac v1.0;

%macro casestrmac(str,targ);

  %local pos res redo tempstr;
  %let tempstr=&str;

  %redo:
  %let redo=0;

  %let pos=%index(%qupcase(%quote(&tempstr)),%qupcase(&targ));
  %if &pos %then %do;
    %let redo=1;
    %if &pos GT 1 %then %let
      res=&res%qsubstr(%quote(&tempstr),1,%eval(&pos-1))&targ;
    %else %let res=&res&targ;
    %if %length(%quote(&tempstr)) GT %eval(&pos+%length(&targ)-1) 
      %then %let tempstr=%qsubstr(%quote(&tempstr),%eval(&pos+%length(&targ)));
    %else %let tempstr=;
  %end;

  %if &redo %then %goto redo;

&res&tempstr

%mend casestrmac;
/*<pre><b>
/ Program   : casestrvar.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : In-datastep macro to force mixed case forms of a string into the
/             string itself.
/ SubMacros : none
/ Notes     : This must be used in a data step as shown in the usage notes.
/             The macro version of this macro is %casestrmac. This is NOT a 
/             function-style macro.
/ Usage     : data test2;
/              set test;
/              %casestrvar(text,'Roland');
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ var               (pos) Text variable.
/ str               (pos) String (quoted) to enforce case.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: casestrvar v1.0;

%macro casestrvar(var,str);
  _casepos=1;
  do while(index(upcase(substr(&var,_casepos)),upcase(&str)));
    _casepos=_casepos-1+index(upcase(substr(&var,_casepos)),upcase(&str));
    if substr(&var,_casepos,length(&str)) NE trim(&str) 
      then substr(&var,_casepos,length(&str))=trim(&str);
    _casepos=_casepos+length(&str);
  end;
  drop _casepos;
%mend casestrvar;
/*<pre><b>
/ Program   : char2num.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 15-Mar-2013
/ Purpose   : To "effectively" convert a list of character variables to numeric
/ SubMacros : %words
/ Notes     : Converting variable types in SAS datasets is not allowed so this
/             macro will create new numeric variables having the same name as
/             the original character variables as well as the same label. You
/             might find the %numchars macro useful for identifying a list of
/             character variables with pure numeric content. All variables must
/             be specified as a space delimited list. Forms such as char: and 
/             char1-char12 are not allowed.
/
/             No modifiers in brackets are allowed against the input and output
/             data set names.
/ Usage     : %char2num(test,test2,cvar1 cvar2 cvar3 cvar4)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsin              (pos) Input data set (no modifiers in brackets allowed)
/ dsout             (pos) Output data set (no modifiers in brackets allowed)
/ vars              (pos) Character variables to convert to numeric
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/ rrb  15Mar13         "old_" replaced by "OLD_" and upcase() used in comparison
/                      of variable labels plus header update (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: char2num v1.1;

%macro char2num(dsin,dsout,vars);

  %local i w oldlist lib mem;

  %let w=%words(&vars);

  %if %length(%scan(&dsout,2,.)) %then %do;
    %let lib=%scan(&dsout,1,.);
    %let mem=%scan(&dsout,2,.);
  %end;
  %else %do;
    %let lib=;
    %let mem=&dsout;
  %end;

  %do i=1 %to &w;
    %let oldlist=&oldlist OLD_%scan(&vars,&i,%str( ));
  %end;

  data &dsout;
    length _execode $ 200;
    set &dsin(rename=(
    %do i=1 %to &w;
      %scan(&vars,&i,%str( ))=%scan(&oldlist,&i,%str( ))
    %end;
    )) end=last;
    %do i=1 %to &w;
      %scan(&vars,&i,%str( ))=input(%scan(&oldlist,&i,%str( )),comma32.);
    %end;

    if last then do;
      _execode="proc datasets nolist memtype=data ";
      call execute(_execode);
      %if %length(&lib) %then %do;
        _execode=" lib=&lib ;modify &mem;label ";
      %end;
      %else %do;
        _execode=";modify &mem;label ";
      %end;
      call execute(_execode);

      %do i=1 %to &w;
        if upcase(vlabel(%scan(&oldlist,&i,%str( )))) ne upcase("%scan(&oldlist,&i,%str( ))") then do;
          _execode=" %scan(&vars,&i,%str( ))=";
          call execute(_execode);
          _execode="'"||trim(tranwrd(vlabel(%scan(&oldlist,&i,%str( ))),"'","''"))||"'";
          call execute(_execode);
        end;
      %end;
      call execute(';run;quit;');
    end;

    drop &oldlist _execode;
  run;
  
%mend char2num;
/*<pre><b>
/ Program      : checkv6.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 11-May-2011
/ Purpose      : Check a dataset for Version 6 compatibility
/ SubMacros    : none
/ Notes        : This will check a dataset for SAS V6 compatibility issues. You
/                can use this to check a dataset you intend to convert to a SAS
/                transport file. Any detected issues will be written to the log
/                as warning messages. For variables defined with a length of
/                more than 200 characters, the length of the contents of these
/                variables will be checked and a warning issued if there is a
/                non-zero count of these.
/
/ Usage        : %checkv6(sasuser.myds);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Name of input dataset (no quotes) 
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  11May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: checkv6 v1.0;

%macro checkv6(ds);

  %let ds=%upcase(&ds);

  %local longvars longcnt i var gt200 wrn;
  %let wrn=WAR%str(NING);

  options nonotes;

  proc contents short data=&ds noprint out=_chkv6;
  run;

  data _null_;
    length longvars $ 2000;
    retain longvars;
    set _chkv6 end=_last;
    if _n_=1 then do;
      put "----- Checking dataset &ds for Version 6 transport file compatibility ----";
      if length(memname)>8 then put "&wrn: Dataset name " MEMNAME "longer than 8 characters";
      if length(memlabel)>40 then put "&wrn: Dataset label longer than 40 characters " memlabel=;
    end;
    put "-- Checking variable " name "--";
    lablen=length(label);
    if length(name)>8 then put "&wrn: Variable name " NAME "longer than 8 characters";
    if lablen>40 then put "&wrn: Label of variable longer than 40 characters " lablen=;
    if type=2 and length>200 then do;
      put "&wrn: Character variable length greater than 200 characters " length=;
      longvars=left(trim(longvars))||" "||name;
    end;
    if type=1 and length NE 8 then put "&wrn: Numeric variable length not equal to 8 bytes " length=;
    if _last then do;
      put "---- Checking of dataset &ds complete ----";
      call symput('longvars',trim(compbl(longvars)));
    end;
  run;

  proc datasets nolist;
    delete _chkv6;
  run;
  quit;

  %let longcnt=%sysfunc(countw(&longvars,%str( )));

  %if &longcnt GT 0 %then %do;
    %put;
    %put ---- Checking content length of long character variable(s) &longvars in dataset &ds ----;
    %do i=1 %to &longcnt;
      %let var=%scan(&longvars,&i,%str( ));
      %put -- Checking variable &var --;
      proc sql noprint;
        select count(&var) into :gt200 separated by " " from &ds
        where length(&var) GT 200;
      quit;
      %if &gt200 EQ 0 %then %put No obs had content length GT 200 characters;
      %else %put &wrn: &gt200 obs had a content length GT 200 characters;
    %end;
    %put ---- Checking of dataset &ds long variable content lengths complete ----;
    %put;
  %end;

  options notes;

%mend checkv6;

/*<pre><b>
/ Program   : chkuniq.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To check for uniqueness in key variables.
/ SubMacros : %eqsuff
/ Notes     : This does not sort a dataset.
/ Usage     : %chkuniq(dsname)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset
/ keyvars           (pos) Space-delimited list of key variables 
/ sevind=e          Severity indicator. Use W or E for warning or error.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: chkuniq v1.0;

%macro chkuniq(ds,keyvars,sevind=e);

  %if %upcase(%substr(&sevind,1,1)) EQ E %then %let sevind=ERR%str(OR);
  %else %if %upcase(%substr(&sevind,1,1)) EQ W %then %let sevind=WARN%str(ING);

  proc sort data=&ds(keep=&keyvars) out=_chkuniq;
    by &keyvars;
  run;

  data _null_;
    set _chkuniq;
    by &keyvars;
    if (first.%scan(&keyvars,-1,%str( ))) and not (last.%scan(&keyvars,-1,%str( )))
      then put "&sevind: Dataset &ds is not unique for keys " %eqsuff(&keyvars);
  run;

  proc datasets nolist;
    delete _chkuniq;
  run;
  quit;

%mend chkuniq;
/*<pre><b>
/ Program   : chompw.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to cut out a word from a macro string and
/             optionally cut out words before and/or after it.
/ SubMacros : %words %windex
/ Notes     : The search for the target in the string is only done once, even if
/             there are repeated instances of the target string. Note that this
/             is used as a function-style macro.
/ Usage     : %let str2=%chompw(&str1,&target,2,0,casesens=yes);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String to chomp a piece out of (unquoted)
/ target            (pos) Target string to chomp out
/ after             (pos) Number of words following target string found to chomp
/                    out. Must be an integer.
/ before            (pos) Number of words preceding target string found to chomp
/                    out. Must be an integer.
/ casesens=no       By default the matching on the target is not case sensitive.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: chompw v1.0;

%macro chompw(str,target,after,before,casesens=no);

  %local i w pos start stop;

  %if not %length(&str) %then %goto exit;
  %if not %length(&target) %then %goto exit;

  %if not %length(&after) %then %let after=0;
  %if not %length(&before) %then %let before=0;
  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));

  %if "&casesens" EQ "Y" %then %let pos=%windex(&str,&target);
  %else %let pos=%windex(%upcase(&str),%upcase(&target));

  %if not &pos %then %do;
&str
    %goto exit;
  %end;

  %let w=%words(&str);

  %let start=%sysevalf(&pos-&before);
  %if %sysevalf(&start LT 0) %then %let start=1;

  %let stop=%sysevalf(&pos+&after);
  %if %sysevalf(&stop GT &w) %then %let stop=&w;

  %do i=1 %to &w;
    %if (&i LT &start) or (&i GT &stop) %then %do;
  %scan(&str,&i,%str( ))
    %end;
  %end;

  %exit:

%mend chompw;
/*<pre><b>
/ Program   : clashlibs.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 02-Nov-2011
/ Purpose   : To identify where there is a clash of variable characteristics for
/             the specified dataset(s) in the multiple assigned libraries and to
/             output diagnostics. Case is important for variable names. To make
/             sure all variable names are created in upper case then use the 
/             system option VALIDVARNAME=UPCASE before you create the datasets.
/ SubMacros : none
/ Notes     : Output goes to the log by default but can also be sent to print
/             output or a file. All the librefs assigned in the current session
/             are searched.
/
/             If you are checking datasets across libraries for consistency then
/             it might be a good idea to create a correct version of the dataset
/             in the WORK library to use as a reference for when differences are
/             reported.
/
/ Usage     : %clashlibs(myds)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsets             (pos) (not quoted) Single level space-separated dataset
/                   name(s) for comparison of variable characteristics of
/                   identically named datasets in the assigned multiple
/                   libraries.
/ file              (pos) Output destination (default "log")
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  02Nov11         Suppress NOTEs in the log (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: clashlibs v1.1;

%macro clashlibs(dsets,file);

  %local err i dset dsetlist savopts;

  %let savopts=%sysfunc(getoption(notes));
  options nonotes;

  %let err=ERR%str(OR);

  %if not %length(&dsets) %then %do;
    %put &err: (clashlibs) No dataset list specified;
    %goto exit;
  %end;

  %let dslist=;
  %let i=1;
  %let dset=%scan(&dsets,&i,%str( ));
  %do %while(%length(&dset));
    %let dset="%upcase(%scan(&dset,-1,.))";
    %let dsetlist=&dsetlist &dset;
    %let i=%eval(&i+1);
    %let dset=%scan(&dsets,&i,%str( ));
  %end;

  proc sql noprint;
    create table _clash as 
    select * from dictionary.columns
    where memname IN (&dsetlist) and memtype='DATA'
    order by memname, name, libname, type, length, format, label;
  quit;

  proc sort nodupkey data=_clash(keep=memname name type length format label)
                      out=_clashbad;
    by memname name type length format label;
  run;

  data _clashbad;
    set _clashbad;
    by memname name;
    if last.name and not first.name then output;
    keep memname name;
  run;

  data _clash;
    merge _clashbad(in=_bad) _clash;
    by memname name;
    if _bad;
  run;

  %put;
  data _null_;
    %if not %length(&file) %then %do;
    %end;
    %else %if "%upcase(%sysfunc(dequote(&file)))" EQ "LOG" %then %do;
    %end;
    %else %if "%upcase(%sysfunc(dequote(&file)))" EQ "PRINT" %then %do;
      file print notitles noprint;
    %end;
    %else %do;
      file "%sysfunc(dequote(&file))" notitles noprint;
    %end;
    set _clash;
    put @1 memname @16 name @35 libname @44 type @49 length @54 format @69 label;
  run;
  %put;

  proc datasets nolist;
    delete _clash _clashbad;
  run;
  quit;

  %goto skip;
  %exit: %put &err: (clashlibs) Leaving macro due to problem(s) listed;
  %skip:

  options &savopts;

%mend clashlibs;
/*<pre><b>
/ Program   : clashvars.sas
/ Version   : 2.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 02-Nov-2011
/ Purpose   : To identify where there is a clash of variable characteristics for
/             datasets in a library and to output diagnostics.
/ SubMacros : none
/ Notes     : Output goes to the log by default but can also be sent to print
/             output and a file. 
/ Usage     : %clashvars(mylib)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ libname           (pos) Libref.
/ file              (pos) Output destination (default "log")
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/ rrb  30Jun11         Route output to the log by default but allow to route to
/                      print output as well as a flat file (v2.0)
/ rrb  02Nov11         Suppress NOTEs in the log (v2.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: clashvars v2.1;

%macro clashvars(libname,file);

  %local savopts;

  %let savopts=%sysfunc(getoption(notes));
  options nonotes;

  %if not %length(&libname) %then %let libname=%sysfunc(getoption(user));
  %if not %length(&libname) %then %let libname=work;

  proc sql noprint;
    create table _clash as 
    select * from dictionary.columns
    where libname="%upcase(&libname)" and memtype='DATA'
    order by name, memname, type, length, format, label;
  quit;

  proc sort nodupkey data=_clash(keep=name type length format label)
                      out=_clashbad;
    by name type length format label;
  run;

  data _clashbad;
    set _clashbad;
    by name;
    if last.name and not first.name then output;
    keep name;
  run;

  data _clash;
    merge _clashbad(in=_bad) _clash;
    by name;
   if _bad;
  run;

  %put;
  data _null_;
    %if not %length(&file) %then %do;
    %end;
    %else %if "%upcase(%sysfunc(dequote(&file)))" EQ "LOG" %then %do;
    %end;
    %else %if "%upcase(%sysfunc(dequote(&file)))" EQ "PRINT" %then %do;
      file print notitles noprint;
    %end;
    %else %do;
      file "%sysfunc(dequote(&file))" notitles noprint;
    %end;
    set _clash;
    put @1 name @20 memname @35 type @40 length @45 format @60 label;
  run;
  %put;

  proc datasets nolist;
    delete _clash _clashbad;
  run;
  quit;

  options &savopts;

%mend clashvars;
/*<pre><b>
/ Program   : clength.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To create a length statement to unify character lengths in a list
/             of data sets to the maximum variable length.
/ SubMacros : %words %nobs
/ Notes     : This is not a function-style macro. A length statement will be 
/             generated in the form "length cvar1 $ 5 cvar2 $ 12" BUT ONLY IF
/             THERE IS AN INCONSISTENCY IN THE INPUT DATASETS. Otherwise it will
/             be blank. Names, labels and other attributes will be taken from
/             the first data set in the list. The length statement string is
/             written out to a global macro variable which can then be resolved
/             in a later data step.
/ Usage     : %clength(ds1 ds2 ds3);
/             data all;
/               &_clength_;
/               set ds1 ds2 ds3;
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsets             (pos) Input datasets
/ globvar=_clength_ Name of global macro variable to write length string to
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: clength v1.0;

%macro clength(dsets,globvar=_clength_);

  %local i w;
  %let w=%words(&dsets);

  %global &globvar;
  %let &globvar=;

  %do i=1 %to &w;
    proc contents data=%scan(&dsets,&i,%str( )) noprint
    out=_clen&i(keep=name type length where=(type=2));
    data _clen&i;
      retain seq &i;
      length ucname $ 32;
      set _clen&i;
      ucname=upcase(name);
      drop type;
    run;
  %end;

  *- bring all the data sets together -;
  data _clenall;
    set
    %do i=1 %to &w;
      _clen&i
    %end;
    ;
  run;

  *- sort ready to get first form of variable name -;
  proc sort data=_clenall;
    by ucname seq;
  run;

  *- first form of variable name encountered -;
  data _clenf;
    set _clenall(keep=ucname name);
    by ucname;
    if first.ucname;
    rename name=fname;
  run;

  *- merge first form of name in with rest -;
  data _clenall(keep=fname length);
    merge _clenf _clenall;
    by ucname;
  run;

  *- get rid of duplicate lengths -;
  proc sort nodupkey data=_clenall;
    by fname length;
  run;

  *- sort in descending length order -;
  proc sort data=_clenall;
    by fname descending length;
  run;

  *- we only want the one with the longest length where there is a clash -;
  data _clenall;
    set _clenall;
    by fname;
    if first.fname and not last.fname then output;
  run;

  %if %nobs(_clenall) %then %do;
    *- gemerate the length statement and output to global macro variable -;
    data _null_;
      length str $ 32767;
      retain str 'length';
      set _clenall end=last;
      str=trim(str)||' '||trim(fname)||' $ '||compress(put(length,5.));
      if last then call symput("&globvar",trim(str));
    run;
  %end;

  *- tidy up -;
  proc datasets nolist;
    delete _clen:;
  run;
  quit;

%mend clength;
/*<pre><b>
/ Program   : cmd2ds.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To run a local system command and write the output to a dataset
/ SubMacros : none
/ Notes     : This is suitable where multiple lines of output are returned. For
/             single line output you can use %qreadpipe to write the output to a
/             macro variable stored locally.
/
/ Usage     : %cmd2ds(ls /root/usr/mylib)
/
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ cmd               (pos) Command you want to run in the local session
/ dsout             (pos) Output dataset name (defaults to _cmd2ds)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Mar14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: cmd2ds v1.0;


%macro cmd2ds(cmd,dsout);
  %if not %length(&dsout) %then %let dsout=_cmd2ds;
  filename _cmd2ds pipe "&cmd";
  data &dsout;
    length str $ 256;
    infile _cmd2ds;
    input;
    str=_infile_;
  run;
  filename _cmd2ds CLEAR;
%mend cmd2ds;
/*<pre><b>
/ Program   : cmd2sas.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To run a local system command and write the output to a dataset
/ SubMacros : %cmd2ds
/ Notes     : This is suitable where multiple lines of output are returned. For
/             single line output you can use %qreadpipe to write the output to a
/             macro variable stored locally.
/
/ Usage     : %cmd2sas(ls /root/usr/mylib)
/
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ cmd               (pos) Command you want to run in the local session
/ dsout             (pos) Output dataset name (defaults to _cmd2sas)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Mar14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: cmd2sas v1.0;

%macro cmd2sas(cmd,dsout);
  %if not %length(&dsout) %then %let dsout=_cmd2sas;
  %cmd2ds(&cmd,&dsout)
%mend cmd2sas;
/*<pre><b>
/ Program      : combine.sas
/ Version      : 2.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 14-Jun-2013
/ Purpose      : To combine datasets based on merge variables
/ SubMacros    : %dropmodifmac %words
/ Notes        : Datasets to be merged should be separated by commas. Datasets
/                to be "set" together should be separated by spaces. You can
/                combine both setting and merging.
/
/                There is no limit to the number of input datasets but only one
/                value for the merge variables can be used so you have to make
/                sure that all the datasets you are merging can be correctly
/                merged using the specified merge variables. The input datasets
/                do not have to be in the correct sorted order for the merge as
/                sorting will be done automatically.
/
/                You would normally specify a KEEP list of variables. Make sure
/                the keep list includes the merge variables and also variables
/                used in a where clause if there is one. See usage notes. Note
/                that the use of %NRBQUOTE() is required for when a macro
/                parameter value contains commas as will be the case for merging
/                datasets using this macro.
/
/                !!! IMPORTANT !!! The first dataset specified is the driver
/                dataset used for an inner join in the sense that when merging
/                data then if it is not in that first dataset then observations
/                in other datasets will be dropped. If you are merging important
/                variables in with other data then this would normally be the
/                first dataset specified.
/
/                The output dataset is given the name "_combine" by default.
/                Other work datasets of the form "_comb1-_combn" are deleted.
/
/ Usage        : %let mrgvars=study ptno;
/                %let SrcData=
/                sasuser.test(keep=&mrgvars visit vara varc), 
/                sasuser.patd(keep=&mrgvars page scrndt trtstdt where=(page=1)),
/                sasuser.patd(keep=&mrgvars page brthdt where=(page=2)),
/                sasuser.vital(keep=&mrgvars visit bmi where=(visit=1));
/
/                %combine(SourceData=%nrbquote(&SrcData),MergeVars=&mrgvars);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ SourceData=       Source datasets separated by commas for merging or separated
/                   by spaces if just concatenating data (surround argument with
/                   %nrbquote() if there are commas present).
/ MergeVars=        List of Variables separated by spaces to use for merging the
/                   input datasets by.
/ dsout=_combine    Output dataset name (defaults to _combine)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  12Nov12         New (v1.0)
/ rrb  16Dec12         dsout= parameter added (v1.1)
/ rrb  14Jun13         Enhanced to allow mixed "setting" and merging (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: combine v2.0;

%macro combine(SourceData=,MergeVars=,dsout=_combine);
  %local i bit mergecode;
  %if not %length(&dsout) %then %let dsout=_combine;
  %if %length(%qscan(%nrbquote(&SourceData),2,%str(,))) %then %do;
    %let i=2;
    %let bit=%qscan(%nrbquote(&sourcedata),&i,%str(,));
    %do %while(%length(&bit));
      %if %words(%dropmodifmac(%superq(bit))) GT 1 %then %do;
        *- we have more than one dataset so set them together -;
        data _comb&i;
          set &bit;
        run;
        *- now sort the combined datasets -;
        proc sort data=_comb&i;
          by &mergevars;
        run;
      %end;
      %else %do;
        *- we have just one dataset so sort -;
        proc sort data=&bit out=_comb&i;
          by &mergevars;
        run;
      %end;
      %let mergecode=&mergecode _comb&i;
      %let i=%eval(&i+1);
      %let bit=%qscan(%nrbquote(&SourceData),&i,%str(,));
    %end;
    %let bit=%qscan(%nrbquote(&SourceData),1,%str(,));
    %if %words(%dropmodifmac(%superq(bit))) GT 1 %then %do;
      *- we have more than one DRIVER dataset so set them together -;
      data _comb1;
        set &bit;
      run;
      *- now sort the combined DRIVER datasets -;
      proc sort data=_comb1;
        by &mergevars;
      run;
    %end;
    %else %do;
      *- we have just one DRIVER dataset so sort -;
      proc sort data=&bit out=_comb1;
        by &mergevars;
      run;
    %end;
    %let mergecode=_comb1(in=_a) &mergecode;
    data &dsout;
      merge &mergecode;
      by &mergevars;
      if _a;
    run;
    proc datasets nolist;
      delete _comb1-_comb%eval(&i-1);
    quit;
  %end;
  %else %do;
    data &dsout;
      set &SourceData;
    run;
  %end;
%mend combine;
/*<pre><b>
/ Program   : combpath.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 18-Jun-2014
/ Purpose   : Function-style macro to append a path extension onto a base path
/             translating the slashes in the extension to the majority slash
/             direction in the base path.
/ SubMacros : none
/ Notes     : You might have to surround the base path or extension path or both
/             with %nrbquote() or mask special characters another way.
/ Usage     : %let path=aaa\bbb\cc\dhh/jj;
/             %let ext=/dd/ff;
/             %let newpath=%combpath(&path,&ext);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ base              (pos) Base path
/ ext               (pos) Extension path
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  18Jun14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: combpath v1.0;

%macro combpath(base,ext);
  %local goodslash badslash;
  %let goodslash=\;
  %let badslash=/;
  %if %length(%sysfunc(compress(&base,\)))
   GT %length(%sysfunc(compress(&base,/))) %then %do;
    %let goodslash=/;
    %let badslash=\;
  %end;
&base%sysfunc(translate(&ext,&goodslash,&badslash))
%mend combpath;
/*<pre><b>
/ Program   : comma2andmac.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to replace the last comma-space in a string
/             with " and ".
/ SubMacros : none
/ Notes     : 
/ Usage     : %let newstr=%comma2andmac(&oldstr);
/
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) string with commas in to change
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  10Feb12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: comma2andmac v1.0;

%macro comma2andmac / parmbuff;
  %if %length(&syspbuff) GT 2 %then %do;
    %local buff;
    %let buff=%qsubstr(&syspbuff,2,%length(&syspbuff)-2);
%unquote(%sysfunc(prxchange(s/^(.*)(%str(, ))(.*$)/$1 and $3/,1,&buff)))
  %end;
%mend comma2andmac;

/*<pre><b>
/ Program   : comma2andvar.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : In-datastep function-style macro to replace the last comma-space
/             in a string with " and ".
/ SubMacros : none
/ Notes     : none
/ Usage     : data test;
/               length str newstr $ 40;
/               str="aa, bb, cc";
/               newstr=%comma2andvar(str);
/               put newstr=;
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) string with commas in to change
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  10Feb12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: comma2andvar v1.0;

%macro comma2andvar(str);
prxchange('s/^(.*)(, )(.*$)/$1 and $3/',1,&str)
%mend comma2andvar;
/*<pre><b>
/ Program   : commaparms.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 10-Jun-2014
/ Purpose   : Function-style macro to add back commas between macro parameters
/             where these have been deliberately omitted in a string.
/ SubMacros : none
/ Notes     : The result will be returned macro UNQUOTED so that equals signs
/             are not macro quoted.
/
/             Where a controlling macro allows the user to run other macros and
/             supply parameters values then it is common practice to not use
/             commas to separate the parameter values and to add these
/             programatically when the called macro is invoked. This is done to
/             avoid having to macro quote the whole string due to the presence
/             of commas. This macro adds back the commas to the parameter list
/             that are needed when the macro is called.
/
/             The macro removes spaces either side of the equals sign and
/             precedes the parameter name with a comma (removing the very first
/             comma).
/
/             Enclose the string for conversion inside %nrbquote() when calling
/             this macro otherwise the first parameter name in the string will
/             be interpreted as a macro parameter of the %commaparms macro.
/
/ Usage     : %let params=%commaparms(%nrbquote(&str));
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  25Mar13         New (v1.0)
/ rrb  10Jun14         Header tidy (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: commaparms v1.0;

%macro commaparms(str);
%unquote(%qsubstr(%qsysfunc(prxchange(%nrbquote(s\s*(\w+)\s*=\s*,\1=),-1,
%nrbquote(&str))),2))
%mend commaparms;

/*<pre><b>
/ Program   : commaparmsu.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 10-Jun-2014
/ Purpose   : Function-style macro to add back commas between macro parameters
/             where these have been deliberately omitted in a string and to 
/             convert parameter names to uppercase.
/ SubMacros : none
/ Notes     : The result will be returned macro UNQUOTED so that equals signs
/             are not macro quoted.
/
/             Where a controlling macro allows the user to run other macros and
/             supply parameters values then it is common practice to not use
/             commas to separate the parameter values and to add these
/             programatically when the called macro is invoked. This is done to
/             avoid having to macro quote the whole string due to the presence
/             of commas. This macro adds back the commas to the parameter list
/             that are needed when the macro is called.
/
/             The macro removes spaces either side of the equals sign and
/             precedes the parameter name with a comma (removing the very first
/             comma).
/
/             Parameter names will converted to upper case. If you do not want 
/             this then to be done then use the %comm2parms macro instead.
/
/             Enclose the string for conversion inside %nrbquote() when calling
/             this macro otherwise the first parameter name in the string will
/             be interpreted as a macro parameter of the %commaparmsu macro.
/
/ Usage     : %let params=%commaparmsu(%nrbquote(&str));
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  16Apr13         New (v1.0)
/ rrb  10Jun14         Header tidy (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: commaparmsu v1.0;

%macro commaparmsu(str);
%unquote(%qsubstr(%qsysfunc(prxchange(%nrbquote(s\s*(\w+)\s*=\s*,\U\1\E=),-1,
%nrbquote(&str))),2))
%mend commaparmsu;
/*<pre><b>
/ Program   : commas.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to separate the elements of a list with
/             commas.
/ SubMacros : %quotelst
/ Notes     : This uses %quotelst to do all the work. You would typically use 
/             this to delimit a list of variables with commas for proc sql where
/             it is not known if resolved values equate to anything.
/ Usage     : order by %commas(&var1 &var2 &var3);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               String elements to delimit with commas (pos)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: commas v1.0;

%macro commas(str);
%quotelst(&str,quote=%str(),delim=%str(, ))
%mend commas;
/*<pre><b>
/ Program   : complibs.sas
/ Version   : 3.2
/ Author    : Roland Rashleigh-Berry
/ Date      : 15-Apr-2011
/ Purpose   : To "proc compare" identically-named datasets in two libraries
/ SubMacros : %supasort %attrc %words %nvarsc %nvarsn %varlistc %missvars
/             %match %dsall %quotelst %varlist %removew %varlistn %nodup
/ Notes     : It is for comparing different versions of the data to identify
/             what has been added or deleted or changed. Each dataset is
/             compared with each identically named dataset in each library.
/             Titles will be assigned internally during macro execution.
/
/             You can either set up the librefs before calling this macro and
/             pass the pure libref names to the parameters or if you put in
/             quotes then it will assign the librefs for you and deassign on
/             completion.
/
/             If the datasets are supposed to be exactly the same then set the
/             parameter direct=yes and it will do an obs by obs comparison. If
/             not then you are recommended to supply a list of sort variables to
/             sortvars= for your datasets that you use to define uniqueness of
/             the observations. %supasort will be called to sort the datasets
/             for variables found in this variable list. This is needed since we
/             can not assume the datasets are in any particular order and we
/             need an order for comparisons. If you leave this blank then it
/             will be assumed that matching datasets are already sorted in a
/             unique order and this sort order will be used in the comparison.
/             If no such sort variables exist then the variables defined to
/             dfsortvars= will be used but failing that an error message will be
/             put out for that dataset.
/
/             If you set chardiff=yes then the differences found in character
/             fields are shown in a "proc print" so you are not limited to only
/             20 characters as shown the the standard "proc compare" output.
/             Using this option will greatly increase the size of the output.
/             Only the "id" variables plus character variables where a change
/             was found are shown in this listing.
/
/ Usage     : %complibs(base,comp)
/
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ libold            (pos) Libref of old library or path name enclosed in quotes.
/ libnew            (pos) Libref of new library or path name enclosed in quotes.
/ sortvars          (optional) List of variables separated by spaces that you
/                   would use to sort the datasets to obtain uniqueness. If left
/                   blank then the current sort order is used.
/ dfsortvars        (options) Default sort variables to use if none defined to
/                   sortvars= and no current sort variables detected for a
/                   dataset.
/ direct=no         By default, do not do a one to one obs comparison. Overrides
/                   sort variable parameters if set to yes. Use this is your
/                   datasets should be exactly the same.
/ options           Options for "proc compare". "listall" is the default.
/ chardiff=no       (unquoted) By default, do not show detailed character field
/                   differences.
/ dslist            Optional list of datasets to compare that you know exist in
/                   both libraries.
/ titlenum=1        Start title number
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  30Mar06         Use current sort variables for each dataset if nothing is
/                      supplied to sortvars= and added dfsortvars= and direct=
/                      parameters.
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  15Jul08         chardiff= parameter added for detailed analysis of
/                      character variable difference beyond the 20 character
/                      limit (v3.0)
/ rrb  12Oct09         Header tidy
/ rrb  30Jan11         titlenum= parameter added (v3.1)
/ rrb  15Apr11         dslist= parameter added (v3.2)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: complibs v3.2;

%macro complibs(libold,
                libnew,
                sortvars=,
                dfsortvars=,
                direct=no,
                options=listbase,
                chardiff=no,
                dslist=,
                titlenum=1
                );

  %local fnew fold refnew refold sortedby ds i j match cvars err;

  %let err=ERR%str(OR);
  %if not %length(&direct) %then %let direct=no;
  %let direct=%upcase(%substr(&direct,1,1));

  %if not %length(&chardiff) %then %let chardiff=no;
  %let chardiff=%upcase(%substr(&chardiff,1,1));

  %*- Set up libref if libnew is a file name (starts with a quote) -;
  %if %index(%str(%'%"),%qsubstr(&libnew,1,1)) %then %do;
    %let fnew=Y;
    %let refnew=NEW;
    libname NEW &libnew access=readonly;
  %end;
  %else %let refnew=%upcase(&libnew);


  %*- Set up libref if libold is a file name (starts with a quote) -;
  %if %index(%str(%'%"),%qsubstr(&libold,1,1)) %then %do;
    %let fold=Y;
    %let refold=OLD;
    libname OLD &libold access=readonly;
  %end;
  %else %let refold=%upcase(&libold);

  %if NOT %length(&dslist) %then %do;

    *- Get a list of datasets in the old library -;
    proc sort data=sashelp.vtable(keep=memname libname memtype
                         where=(libname="&refold" and memtype='DATA'))
               out=_baseds(drop=libname memtype);
      by memname;
    run;


    *- Get a list of datasets in the new library -;
    proc sort data=sashelp.vtable(keep=memname libname memtype
                         where=(libname="&refnew" and memtype='DATA'))
               out=_compds(drop=libname memtype);
      by memname;
    run;


    *- Select out those datasets that exist in both libraries -;
    data _both;
      merge _baseds(in=_base) _compds(in=_comp);
      by memname;
      if _base and _comp;
    run;


    *- Write list of matching datasets out to a macro variable -;
    proc sql noprint;
      select memname into :dslist separated by ' ' from _both;
    quit;

    proc datasets nolist;
      delete _baseds _compds _both;
    run;
    quit;

  %end;
  %else %let dslist=%upcase(&dslist);

  %*- For each dataset in the list, do the following -;
  %do i=1 %to %words(&dslist);
    %let ds=%scan(&dslist,&i,%str( ));

      *- Base data ready for sorting -;
    data _base;
      set &refold..&ds;
    run;

    *- Compare data ready for sorting -;
    data _comp;
      set &refnew..&ds;
    run;

    *- assign title for the output -;
    title&titlenum "Comparison of &ds dataset between &refold and &refnew libraries";


    %*- direct obs by obs comparison -;
    %if "&direct" EQ "Y" %then %do;
      proc compare base=_base compare=_comp &options;
      run;
    %end;

    %else %do;  %*- sorted comparison -;

      %*- sort base and compare data into matching variable order -;
      %if %length(&sortvars) %then %do;
        %supasort(_base _comp,&sortvars)
        %let sortedby=%attrc(_base,sortedby);
      %end;
      %else %do;
        %let sortedby=%attrc(&refold..&ds,sortedby);
        %if not %length(&sortedby) %then %let sortedby=%attrc(&refnew..&ds,sortedby);
        %if %length(&sortedby) %then %do;
          proc sort data=_base;
            by &sortedby;
          run;
          proc sort data=_comp;
            by &sortedby;
          run;
        %end;
        %else %if %length(&dfsortvars) %then %do;
          %supasort(_base _comp,&dfsortvars)
          %let sortedby=%attrc(_base,sortedby);
        %end;
      %end;


      %if %length(&sortedby) %then %do;

        *- Do the comparison between the datasets -;
        proc compare base=_base compare=_comp &options;
          id &sortedby;
        run;

  %if "&chardiff" EQ "Y" %then %do;

        *- show detailed character variable differences -;
        proc compare base=_base compare=_comp out=_result outnoequal outbase outcomp outdif noprint;
          id &sortedby;
        run;

        data _dif;
          set _result(where=(_type_="DIF"));
          drop _type_;
        run;

        %put >>>>>>>>>> ds=&ds;
        %put >>>>>>>>>> sortedby=&sortedby;

        %let cvars=%varlistc(_dif);
        %put >>>>>>>>>> cvars=&cvars;

        %if %words(&cvars) EQ 0 %then %goto skip;

        %let cvars=%removew(&cvars,&sortedby);
        %put >>>>>>>>>> cvars with sortedby removed = &cvars;


        %if %words(&cvars) EQ 0 %then %goto skip;

        data _dif;
          set _dif(keep=&sortedby &cvars);
          %do j=1 %to %words(&cvars);
            if not index(%scan(&cvars,&j,%str( )),"X")
              then %scan(&cvars,&j,%str( ))=" ";
          %end;
        run;

        %missvars(_dif);
        run;
        %put >>>>>>>>>>> all-missing variables = &_miss_;

        %if %words(&_miss_) EQ 0 %then %let match=;
        %else %let match=%match(&cvars,&_miss_);

        %if "&match" EQ "&cvars" %then %goto skip;

        data _result2;
          merge _dif(in=_dif keep=&sortedby) _result(keep=&sortedby _type_ &cvars);
          by &sortedby;
          if _dif;
          %if %length(&match) %then %do;
            drop &match;
          %end;
        run;

        proc print data=_result2 label noobs;
          id &sortedby;
        run;

        %skip:
  %end;

      %end;
      %else %do;
        %put;
        %put &err: (complibs) No sort variable list determined for dataset &ds;
        %put;
      %end;

    %end;

  %end;


  *- Tidy up temporary datasets now we are finished -;
  proc datasets nolist;
    delete _base _comp;
  run;
  quit;


  %*- Clear librefs if these were assigned internally -;
  %if "&fnew" EQ "Y" %then %do;
    libname &refnew clear;
  %end;
  %if "&fold" EQ "Y" %then %do;
    libname &refold clear;
  %end;


%mend complibs;
/*<pre><b>
/ Program   : compvars.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 08-Nov-2011
/ Purpose   : To compare the differences in variables present in two datasets
/             and report the results to global macro variables.
/ SubMacros : none
/ Notes     : Two datasets are supplied to this macro as positional parameters.
/             They should be thought of as the "left" and "right" datasets. 
/             Variables in the left dataset that are not in the right dataset
/             are written to the global macro variable named _left_. Variables
/             in the right dataset that are not in the left dataset are written
/             to the global macro variables named _right_. Variables found in
/             both datasets are written to the global macro variable named
/             _both_. The contents of these global macro variables can be
/             reported after the comparison of the two datasets. See usage
/             notes.
/ Usage     : %let ds1=dataset1;
/             %let ds2=dataset2;
/             %compvars(&ds1,&ds2)
/             options nosource;
/             %put NOTE: Variables found in &ds1 but not &ds2:;
/             %put &_left_;
/             %put NOTE: Variables found in &ds2 but not &ds1:;
/             %put &_right_;
/             %put NOTE: Variables found in both &ds1 and &ds2:;
/             %put &_both_;
/             options source;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds1               (pos) "Left" dataset for comparison
/ ds2               (pos) "Right" dataset for comparison
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/ rrb  08Nov11         Header tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: compvars v1.0;

%macro compvars(ds1,ds2);

  %global _left_ _right_ _both_;
  %let _left_=;
  %let _right_=;
  %let _both_=;

  proc contents noprint data=&ds1 out=_left(keep=name);
  proc sort data=_left;
    by name;
  run;

  proc contents noprint data=&ds2 out=_right(keep=name);
  proc sort data=_right;
    by name;
  run;
 
  data _null_;
    length _left _right _both $ 32767;
    retain _left _right _both " ";
    merge _left(in=_l) _right(in=_r) end=_last;
    by name;
    if _l and not _r then _left=trim(_left)||" "||trim(name);
    else if _r and not _l then _right=trim(_right)||" "||trim(name);
    else if _l and _r then _both=trim(_both)||" "||trim(name);
    if _last then do;
      call symput('_left_',left(trim(_left)));
      call symput('_right_',left(trim(_right)));
      call symput('_both_',left(trim(_both)));
    end;
  run;

  proc datasets nolist;
    delete _left _right;
  run;
  quit;

%mend compvars;
/*<pre><b>
/ Program   : cont2dict.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 17-Jun-2014
/ Purpose   : To change proc contents output variable characteristics to match
/             those from dictionary.columns.
/ SubMacros : %words
/ Notes     : The variables FORMAT, INFORMAT and TYPE are changed to match the
/             column characteristics in dictionary.columns. You can use the
/             _all_ notation for running proc contents on an entire library
/             (see usage notes).
/ Usage     : %cont2dict(_mydset,_mycont);
/             %cont2dict(mylib._all_,_mycont);
/             %cont2dict(%suffix(._all_,&liblist),_mybigcont);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsin              (pos) Dataset(s) (separated by spaces) to run proc contents
/                   on. Using the _all_ notation is allowed.
/ dsout             (pos) Output dataset containing proc contents output but
/                   with variable characteristics changed.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26May14         New (v1.0)
/ rrb  17Jun14         Multiple input datasets allowed (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: cont2dict v2.0;

%macro cont2dict(dsin,dsout);

  %local i savopts ndsets dset;
  %let savopts=%sysfunc(getoption(notes));

  options nonotes;

  %let ndsets=%words(%superq(dsin));

  %do i=1 %to &ndsets;
    %let dset=%scan(&dsin,&i,%str( ));
    proc contents data=&dset out=_cont&i noprint;
    run;
  %end;

  data &dsout;
    length format2 informat2 $ 49 type2 $ 4;
    set
    %do i=1 %to &ndsets;
      _cont&i
    %end;
    ;
    if type=1 then type2='char';
    else type2='num';
    format2=' ';
    if format NE ' ' then do;
      format2=cats(format,formatl,'.');
      if formatd>0 then format2=cats(format2,formatd);
    end;
    informat2=' ';
    if informat NE ' ' then do;
      informat2=cats(informat,informl,'.');
      if informd>0 then informat2=cats(informat2,informd);
    end;
    drop format formatl formatd type
         informat informl informd;
    rename type2=type format2=format informat2=informat;
  run;

  proc datasets nolist memtype=data;
    delete
    %do i=1 %to &ndsets;
      _cont&i
    %end;
    ;
  quit;

  options &savopts;

%mend cont2dict;
/*<pre><b>
/ Program   : crdte.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the creation datetime stamp of a
/             dataset.
/ SubMacros : %attrn
/ Notes     : This is a shell macro that calls %attrn
/ Usage     : %let crdte=%crdte(dsname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name
/ format            (pos) Format to use for output. This will default to nothing
/                   giving you the decimal fraction of the number of thousandths
/                   of a second since 01jan1960 but you can supply the usual
/                   formats if you like.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: crdte v1.0;

%macro crdte(ds,format);
  %local crdte;
  %let crdte=%attrn(&ds,crdte);
  %if %length(&format) %then %do;
    %if %index(%upcase(&format),DATE) 
    and not %index(%upcase(&format),DATETIME) %then %do;
%sysfunc(putn(%sysfunc(datepart(&crdte)),&format))
    %end;
    %else %do;
  %sysfunc(putn(&crdte,&format))
    %end;
  %end;
  %else %do;
&crdte
  %end;
%mend crdte;
/*<pre><b>
/ Program   : cvarlens.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 01-May-2014
/ Purpose   : Function-style macro to return a list of character variables with
/             their lengths that can be used in a LENGTH statement.
/ SubMacros : none
/ Notes     : Dataset modifiers are not allowed. The character variables are
/             listed in the same order as they exist in the input dataset. If
/             there are no character variables in the dataset then a null string
/             is returned which will not cause a syntax problem if used in a
/             LENGTH statement. If the cvars= parameter is used then no checking
/             will be done to make sure any of the variables actually exist in
/             the input dataset. No action is taken for variables in the list
/             that are numeric.
/ Usage     : data test;
/               length %cvarlens(sashelp.class,name weight);
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name (no modifiers)
/ cvars             (pos) Optional limiting list of character variables you want
/                   the LENGTH attributes for (separated by spaces - case is not
/                   important).
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  01May14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: cvarlens v1.0;

%macro cvarlens(ds,cvars);
  %local dsid rc nvars i cvarlens err varname vartype varlen;
  %let err=ERR%str(OR);
  %let cvars=%upcase(&cvars);
  %let dsid=%sysfunc(open(&ds,is));
  %if &dsid EQ 0 %then %do;
    %put &err: (cvarlens) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let nvars=%sysfunc(attrn(&dsid,nvars));
    %if &nvars LT 1 %then %put &err: (cvarlens) No variables in dataset &ds;
    %else %do;
      %let cvarlens=;
      %do i=1 %to &nvars;
        %let varname=%sysfunc(varname(&dsid,&i));
        %let vartype=%sysfunc(vartype(&dsid,&i));
        %let varlen=%sysfunc(varlen(&dsid,&i));
        %if &vartype EQ C %then %do;
          %if not %length(&cvars) or %sysfunc(indexw(&cvars,%upcase(&varname)))
            %then %let cvarlens=
            %sysfunc(strip(%sysfunc(compbl(&cvarlens &varname $ &varlen))));
        %end;
      %end;
    %end;
    %let rc=%sysfunc(close(&dsid));
  %end;
&cvarlens
%mend cvarlens;
/*<pre><b>
/ Program   : datanulldemo.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 28-Sep-2008
/ Purpose   : Clinical reporting sample code to do a stacked-column report using
/             data _null_ that does not leave line gaps like proc report does.
/ SubMacros : %titlelen %maxtitle %splitvar %titlegen
/ Notes     : This is an example of using data _null_ to produce a
/             stacked-column report without the weakness of proc report in
/             leaving line gaps. It can handle #byval and #byvar entries in the
/             titles, will generate or not a "by" line depending on the options
/             setting and will center or left-align depending on the "center"
/             option setting. The positioning of the report and titles is
/             dependent on the line size. Report titles are stored in arrays to
/             speed up multi-page reports.
/
/             This report shows subject/invid in the first column and
/             age/race/sex/weight in the second column. These will repeat if 
/             values flow onto a following page as will the current parameter
/             identifier which in many cases is so long that you are required to
/             "flow" it on a further line. There is a call to %titlegen at the
/             end to restore the titles that had to be nullified. This is an
/             educational tool, rather than a recommendation. Once you
/             understand how it works you should be able to handle data _null_
/             reports of any degree of complexity. 
/
/ Usage     : Ordinary SAS code.
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ N/A
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Header tidy
/ rrb  31Jul07         Renamed to datanulldemo.sas from fullmonty.sas
/ rrb  28Sep08         This is now classed as a "Clinical reporting" macro
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

options ls=90 ps=40 center nobyline;
title1 'First title';
title3 'Third title';
title5 '#byvar1 = #byval1';
footnote1 'First footnote';
footnote3 'Third footnote';

%titlelen(dsout=titles(where=(type='T')));

%maxtitle


         /*--------------------------------------------------*
                        Generate the dummy data
          *--------------------------------------------------*/

data test;
  length sex $ 6 param $ 80 race $ 10;
  year=2002;

  subj=1001;invid=10001;age=21;race='Asian';sex='Male';weight=60;
  param='AA This is a very long parameter and you will have to flow it';
  value=11;output;
  param='BB This is a short parameter';
  value=21;output;
  value=22;output;
  param='CC This is a very long parameter and you will have to flow it';
  do value=30 to 38;
    output;
  end;

  subj=2001;invid=20001;age=32;race='White';sex='Female';weight=55;
  param='AA This is a very long parameter and you will have to flow it';
  value=51;output;
  param='BB This is a short parameter';
  value=61;output;
  value=62;output;
  param='CC This is a very long parameter and you will have to flow it';
  do value=70 to 78;
    output;
  end;

  subj=3001;invid=30001;age=42;race='Black';sex='Female';weight=65;
  param='AA This is a very long parameter and you will have to flow it';
  value=51;output;
  /*
  param='BB This is a short parameter';
  value=61;output;
  */
run;


         /*--------------------------------------------------*
                          Produce the report
          *--------------------------------------------------*/

title1;

data _null_;
  length tempstr $ 200;
  retain ls 0 startcol titlestart 0 repwidth 60 count 0 byline 0 center 1;
  array ttext {&_maxtitle_} $ 200 _temporary_;
  array tlength {&_maxtitle_} 8 _temporary_;
  file print titles footnotes header=header linesleft=ll;
  set test end=last;
  by subj param;
  if _n_=1 then do;
    do tptr=1 to &_maxtitle_;
      set titles point=tptr;
      ttext(tptr)=text;
      tlength(tptr)=length;
    end;
    ls=getoption('ls');
    startcol=floor((ls-repwidth)/2)+1;
    if getoption('center')='NOCENTER' then do;
      startcol=1;
      center=0;
    end;
    if getoption('byline')='BYLINE' then byline=1;
  end;
  if ll<2 then put _page_;
  if first.subj then do;
    count=0;
    if ll<5 then put _page_;
  end;
  count=count+1;
  %splitvar(param,38,split='*');
  link flow;
  if first.param or count=1 then do;
    tempstr=scan(param,1,'*');
    put @startcol+18 tempstr @startcol+57 value 4.;
    i=2;
    do while(scan(param,i,'*') NE ' ');
      count=count+1;
      link flow;
      tempstr=scan(param,i,'*');
      put @startcol+18 tempstr;
      i=i+1;
    end;
  end;
  else put @startcol+57 value 4.;
  if last.param then do;
    count=count+1;
    link flow;
    if not last or count<5 then put;
  end;
  if last.subj then link lastsubj;
return;

header:
  do t=1 to &_maxtitle_;
    if ttext(t) EQ ' ' then put;
    else do;
      oldlen=length(ttext(t));
      if vlabel(year) ne ' ' then newtitle=tranwrd(ttext(t),'#BYVAR1',trim(vlabel(year)));
      else newtitle=tranwrd(ttext(t),'#BYVAR1','year');
      newtitle=tranwrd(newtitle,'#BYVAL1',left(year));
      newlen=length(newtitle);
      length=tlength(t)+newlen-oldlen;
      if length>ls then length=ls;
      titlestart=floor((ls-length)/2)+1;
      if not center then titlestart=1;
      put @ (titlestart+length(newtitle)-length(left(newtitle))) newtitle;
    end;
  end;
  if byline then do;
    put;
    _file_=repeat('-',ls-1);
    if vlabel(year) ne ' ' then newtitle=trim(vlabel(year))||'='||left(year);
    else newtitle='year='||left(year);
    substr(_file_,floor((ls-(length(newtitle)+2))/2)+1,length(newtitle)+2)=' '||trim(newtitle)||' ';
    put;
  end;
  put;
  put @startcol '           age/';
  put @startcol '          race/';
  put @startcol 'subject/   sex/';
  put @startcol 'invid.   weight   Lab parameter                          value';
  *              0         10        20        30        40        50        60;
  *              01234567890123456789012345678901234567890123456789012345678901;
  put @startcol '--------------------------------------------------------------';
  if _n_ ne 1 then count=0;
return;

flow:
  if count=1 then put @startcol subj 6. '/' @startcol+8 age 2. ' yrs/' @;
  else if count=2 then put @startcol invid 6. @startcol+8 race $char6. +(-1) '/' @;
  else if count=3 then put @startcol+8 sex $char6.  '/' @;
  else if count=4 then put @startcol+8 weight 3. ' kg' @;
return;

lastsubj:
  if count<4 then do;
    do count=(count+1) to 4;
      link flow;
      put;
    end;
    if not last then put;
  end;
return;

run;


%titlegen(titles)
/*<pre><b>
/ Program   : delhex.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To delete occurrences of a specified hex character in a flat file.
/ SubMacros : none
/ Notes     : Hex characters must be specified in quoted form such as 'FE'x. 
/             The target character does not have to be hex.
/             You can use the %hexchars macro to show up what non-printable hex
/             characters are in a flat file.
/ Usage     : %delhex(infile,outfile,'FE'x)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ infile            (pos) Input file
/ file              (pos) Output file
/ target            (pos) Target character (quoted)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  15jun03         Use _file_ and _infile_
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: delhex v1.0;

%macro delhex(infile,file,target);

  %local errflag err;
  %let err=ERR%str(OR);
  %let errflag=0;


       /*--------------------------------------*
            Check we have all parameters set
        *--------------------------------------*/

  %if not %length(&infile) %then %do;
    %let errflag=1;
    %put &err: (delhex) No input file specified;
  %end;

  %if not %length(&file) %then %do;
    %let errflag=1;
    %put &err: (delhex) No output file specified;
  %end;

  %if not %length(&target) %then %do;
    %let errflag=1;
    %put &err: (delhex) No target character specified;
  %end;

  %if &errflag %then %goto exit;



       /*--------------------------------------*
               Start processing the data
        *--------------------------------------*/

  data _null_;
    infile "&infile";
    file "&file" notitles noprint;
    input;
    if _infile_ ne ' ' then _file_=compress(_infile_,&target);
    put;
  run;


  %goto skip;
  %exit: %put &err: (delhex) Leaving macro due to problem(s) listed;
  %skip:

%mend delhex;
/*<pre><b>
/ Program   : delifexist.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 05-Apr-2011
/ Purpose   : To delete a dataset if it exists
/ SubMacros : none
/ Notes     : none
/ Usage     : %delifexist(sasuser.myds)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsname            (pos) One or two level dataset name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: delifexist v1.0;

%macro delifexist(dsname);

  %if %sysfunc(exist(&dsname)) %then %do;
    %if %length(%scan(&dsname,2,.)) %then %do;
      proc datasets nolist lib=%scan(&dsname,1,.);
        delete %scan(&dsname,2,.);
      run;
      quit;
    %end;
    %else %do;
      proc datasets nolist;
        delete &dsname;
      run;
      quit;
    %end;
  %end;

%mend delifexist;
/*<pre><b>
/ Program   : delmac.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Jul-2012
/ Purpose   : Macro to delete macros from the work.sasmacr catalog based on an
/             SQL "find" pattern.
/ SubMacros : none
/ Notes     : Note that this expects a "like" pattern and this has syntax rules.
/             For example, the character "_" represents any character. You can
/             "escape" this character by placing a "\" in front. 
/             Any ":" in the "like" pattern will get replaced by "%".
/ Usage     : %delmac(m:);  *- delete all macros starting with "m" -;
/             %delmac(_:);  *- delete every single macro -;
/             %delmac(\_:); *- delete all macros starting with an underscore -;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ like              "like" pattern (no quotes) for macro deletion
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Jul12         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: delmac v1.0;

%macro delmac(like);
  %local delmac err savopts;

  %let err=ERR%str(OR);
  %let savopts=%sysfunc(getoption(notes));

  options nonotes;

  %if not %length(&like) %then %goto exit;

  %let like=%upcase(%sysfunc(translate(&like,%,:)));

  proc catalog catalog=work.sasmacr entrytype=macro;
    contents out=_listmac;
  quit;

  proc sql noprint;
    select name into :delmac separated by " " from _listmac
    where name like "&like" escape '\';
  quit;

  proc datasets nolist;
    delete _listmac;
  quit;

  %if %length(&delmac) %then %do;
    proc catalog catalog=work.sasmacr entrytype=macro;
      delete &delmac;
    quit;
  %end;

  %goto skip;
  %exit: %put &err: (delmac) No "like" string supplied;
  %skip:

  options &savopts;

%mend delmac;
/*<pre><b>
/ Program   : delzero.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To delete all datasets in a library with zero observations. This
/             macro was written for illustration purposes and is of limited use.
/ SubMacros : %dslist %words %nlobs
/ Notes     : Datasets will be deleted if they have zero logical observations.
/ Usage     : %delzero(work)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ libref            (pos) Libref of library.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: delzero v1.0;

%macro delzero(libref);
  %local del;
  %dslist(&libref)
  %do i=1 %to %words(&_dslist_);
    %if not %nlobs(&libref..%scan(&_dslist_,&i,%str( ))) 
      %then %let del=&del %scan(&_dslist_,&i,%str( ));
  %end;
  %if %length(&del) %then %do;
    proc datasets nolist lib=&libref;
      delete &del;
    run;
    quit;
  %end;
%mend delzero;
/*<pre><b>
/ Program      : dequote.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : Function-style macro to remove front and end matching quotes
/                from a macro string and return the result.
/ SubMacros    : %qdequote
/ Notes        : This is a function-style macro that calls %qdequote and uses
/                %unquote to remove the macro quoting so that you can use it in
/                ordinary sas code.
/ Usage        : %let str=%dequote(%qreadpipe(echo '%username%'));
/                
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) Macro string to dequote
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dequote v1.0;

%macro dequote(str);
%unquote(%qdequote(&str))
%mend dequote;
/*<pre><b>
/ Program   : dir.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 25-Apr-2013
/ Purpose   : Function-style macro to return a list of members of a directory
/             on a WINDOWS platform according to the file pattern you supply.
/             If you supply just the directory name then all members are 
/             listed. This runs the MSDOS command in the form "dir /B mydir"
/ SubMacros : %qreadpipe
/ Notes     : Just the file names are returned unquoted. If you need the full
/             path name in double quotes then use the %dirfpq macro instead
/             which will correctly handle file names containing spaces.
/ Usage     : %let dirlist=%dir(C:\utilmacros);
/             %let dirlist=%dir(C:\utilmacros\*.sas);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dir               (pos) Directory path name (no quotes but if it contains "&"
/                   or "%" then enclose in %nrstr() ).
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jun11         Remove quotes if supplied (v1.1)
/ rrb  25Apr13         Reinstate the noquotes condition and allow for spaces,
/                      "&" and "%" in the path name (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dir v2.0;

%macro dir(dir);
  %unquote(%qreadpipe(dir /B """&dir"""))
%mend dir;

/*<pre><b>
/ Program   : dir2ds.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To write a list of windows file names to a sas dataset
/ SubMacros : %dir2sas
/ Notes     : The command "DIR /B" is used to list the members that fit the
/             file pattern you specify. The output dataset will contain a field
/             "filename" that is the name of the file as listed and "lcfname"
/             which is a lower case version of "filename" that is convenient for
/             checking purposes.
/
/             The file pattern must not be quoted.
/
/             If your file pattern contains "&" or "%" then enclose in %nrstr().
/
/ Usage     : %dir2ds(\\Client\C$\MYLIB\*.txt);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ filepattern       (pos) File pattern (no quotes but if it contains "&" or "%"
/                   then enclose in %nrstr() ).
/ dsout             (pos) Output dataset name (defaults to _dir2ds)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Mar14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dir2ds v1.0;

%macro dir2ds(filepattern,dsout);
  %if not %length(&dsout) %then %let dsout=_dir2ds;
  %dir2sas(&filepattern,&dsout)
%mend dir2ds;
/*<pre><b>
/ Program   : dir2sas.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 25-Apr-2013
/ Purpose   : To write a list of windows file names to a sas dataset
/ SubMacros : none
/ Notes     : The command "DIR /B" is used to list the members that fit the
/             file pattern you specify. The output dataset will contain a field
/             "filename" that is the name of the file as listed and "lcfname"
/             which is a lower case version of "filename" that is convenient for
/             checking purposes.
/
/             The file pattern must not be quoted.
/
/             If your file pattern contains "&" or "%" then enclose in %nrstr().
/
/ Usage     : %dir2sas(\\Client\C$\MYLIB\*.txt);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ filepattern       (pos) File pattern (no quotes but if it contains "&" or "%"
/                   then enclose in %nrstr() ).
/ dsout             (pos) Output dataset name (defaults to _dir2sas)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  22Apr13         new (v1.0)
/ rrb  25Apr13         Code changed to allow for spaces, ampersands and percent
/                      signs in the path name and quoted pattern names no longer
/                      allowed (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dir2sas v2.0;

%macro dir2sas(filepattern,dsout);

  %local savopts;
  %let savopts=%sysfunc(getoption(NOTES));

  %if not %length(&dsout) %then %let dsout=_dir2sas;

  options nonotes;

  filename _dir2sas pipe "dir /B ""&filepattern"" ";

  data &dsout;
    length filename lcfname $ 200;
    infile _dir2sas;
    input;
    filename=trim(_infile_);
    lcfname=lowcase(scan(filename,-1,"\"));
  run;

  filename _dir2sas CLEAR;

  options &savopts;

%mend dir2sas;
/*<pre><b>
/ Program   : dirfp2ds.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To write a list of windows full path file names to a sas dataset
/ SubMacros : %dirfp2sas
/ Notes     : Full path file names will be listed that fit the file pattern you
/             specify. The output dataset will contain a field "filename" that
/             is the full path file name as listed and "lcfname" which is a
/             lower case version of "filename" without the path prefix that is
/             convenient for checking purposes.
/ Usage     : %dirfp2ds(\\Client\C$\MYLIB\*.txt);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ filepattern       (pos) File pattern (no quotes but if the file pattern
/                   contains "&" or "%" then enclose in %nrstr() ).
/ dsout             (pos) Output dataset name (defaults to _dirfp2ds)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Mar14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dirfp2ds v1.0;

%macro dirfp2ds(filepattern,dsout);
  %if not %length(&dsout) %then %let dsout=_dirfp2ds;
  %dirfp2sas(&filepattern,&dsout)
%mend dirfp2ds;
/*<pre><b>
/ Program   : dirfp2sas.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 25-Apr-2013
/ Purpose   : To write a list of windows full path file names to a sas dataset
/ SubMacros : none
/ Notes     : Full path file names will be listed that fit the file pattern you
/             specify. The output dataset will contain a field "filename" that
/             is the full path file name as listed and "lcfname" which is a
/             lower case version of "filename" without the path prefix that is
/             convenient for checking purposes.
/ Usage     : %dirfp2sas(\\Client\C$\MYLIB\*.txt);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ filepattern       (pos) File pattern (no quotes but if the file pattern
/                   contains "&" or "%" then enclose in %nrstr() ).
/ dsout             (pos) Output dataset name (defaults to _dirfp2sas)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  22Apr13         new (v1.0)
/ rrb  25Apr13         Disallow use of quotes to enclose filepattern and changed
/                      to cope with "&" and "%" in file pattern (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dirfp2sas v2.0;

%macro dirfp2sas(filepattern,dsout);

  %local savopts;
  %let savopts=%sysfunc(getoption(NOTES));

  %if not %length(&dsout) %then %let dsout=_dirfp2sas;

  options nonotes;

  filename _dirfp pipe
  "echo off & for %nrstr(%f) in (""&filepattern"") do echo %nrstr(%f)";

  data &dsout;
    length filename $ 300 lcfname $ 200;
    infile _dirfp;
    input;
    filename=trim(_infile_);
    lcfname=lowcase(scan(filename,-1,"\"));
  run;

  filename _dirfp CLEAR;

  options &savopts;

%mend dirfp2sas;
/*<pre><b>
/ Program   : dirfpq.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 25-Apr-2013
/ Purpose   : Function-style macro to return a list of full-path quoted members
/             of a directory on a Windows platform according to the file pattern
/             you supply.
/ SubMacros : %qreadpipe
/ Notes     : Members are shown with the full path names in double quotes. If a
/             file name contains spaces then this will be correctly quoted. You
/             MUST give the full file pattern and not just the directory as this
/             does not use the DIR command to act on the directory but rather
/             expands the file pattern.
/ Usage     : %let dirlist=%dirfpq(C:\utilmacros);     %*- NO GOOD -;
/             %let dirlist=%dirfpq(C:\utilmacros\*);      %*- GOOD -;
/             %let dirlist=%dirfpq(C:\utilmacros\*.sas);  %*- GOOD -;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dir               (pos) Directory path name with file pattern (no quotes but
/                   if the file path contains "&" or "%" then enclose in
/                   %nrstr() ).
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jun11         Remove quotes if supplied (v1.1)
/ rrb  25Apr13         Reinstate noquotes condition and allow for "%" and "&" in
/                      the directory name (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dirfpq v2.0;

%macro dirfpq(dir);
%unquote(%qreadpipe(echo off & for %nrstr(%f) in ("&dir") do echo "%nrstr(%f)"))
%mend dirfpq;
/*<pre><b>
/ Program   : dlm2sas.sas
/ Version   : 1.4
/ Author    : Roland Rashleigh-Berry
/ Date      : 02-May-2013
/ Purpose   : To read in a delimited flat file and convert it to a sas dataset
/ SubMacros : none
/ Notes     : This will only work on SIMPLE files where the delimiter is never
/             included in a valid text field so you should not use this on comma
/             delimited files as a comma might be part of a valid text string.
/             All the columns in the output dataset will be CHARACTER so you
/             should convert the fields you want to numeric in a subsequent data
/             step. All the character fields are the number of bytes long that
/             is specified to colw=. If you want to shorten these fields to more
/             suitable lengths then this must be done in a subsequent data step.
/             The %optlength macro might be useful for this. If you use
/             getnames=yes (default) then any text found is converted to make it
/             a valid syntax uppercase variable name.
/ Usage     : %dlm2sas(C:\Mylib\myfile.csv,mydset)
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ infile            (pos) (unquoted) Full path name of input file. Enclose in
/                   %nrstr() if the path name contains spaces, "&" or "%".
/ dsout             (pos) Output dataset name (defaults to _dlm2sas) (modifiers
/                   are allowed)
/ delimiter="09"x   Delimiter character (defaults to horizontal tab)
/ colw=256          Number of bytes to allocate to each column
/ getnames=yes      By default, use the first row as the source of the column
/                   names otherwise columns are named C1, C2 etc..
/ termstr=CRLF      Terminating characters for each line. CRLF is for Windows
/                   platforms where the file is a pure ascii file. LF is for
/                   Unix platforms or utf-8 encoded files. You can use the
/                   %termstr macro to help you decide this value.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  02Jul11         Add checking of input parameters (v1.1)
/ rrb  21Mar13  rrb001 Algorithm changed for deriving variable name from string
/                      containing invalid characters for variable naming so that
/                      multiple adjacent invalid characters are replaced by a
/                      single underscore instead of multiple underscores as
/                      used to be the case (v1.2)
/ rrb  29Apr13         %nrbquote(), %superq() and %nrstr() used to mask file
/                      name and file path must be unquoted (v1.3)
/ rrb  02May13         termstr=CRLF parameter added (v1.4)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dlm2sas v1.4;

%macro dlm2sas(infile,
               dsout,
               delimiter="09"x,
               colw=256,
               getnames=yes,
               termstr=CRLF
               );

  %local maxcol colnames err;
  %let err=ERR%str(OR);

  %if not %length(&infile) %then %do;
    %put &err: (dlm2sas) No file path specified;
    %goto exit;
  %end;
  %else %do;
    %if not %sysfunc(fileexist(%nrbquote(&infile))) %then %do;
      %put &err: (dlm2sas) File "&infile" can not be found;
      %goto exit;
    %end;
  %end;

  %if not %length(&dsout) %then %let dsout=_dlm2sas;
  %if not %length(&colw) %then %let colw=256;
  %if not %length(&delimiter) %then %let delimiter="09"x;

  %if not %length(&getnames) %then %let getnames=yes;
  %let getnames=%upcase(%substr(&getnames,1,1));

  data _null_;
    length name $ 32 colnames $ 1024;
    infile "%nrstr(%superq(infile))" pad lrecl=32767 termstr=&termstr;
    input;
    maxcol=countc(_infile_,&delimiter)+1;
    call symput('maxcol',put(maxcol,best.));
    %if &getnames EQ Y %then %do;
      i=1;
      name=trim(scan(_infile_,i,&delimiter));
      do while(name ne "");
        *- make sure name syntax is valid -;
        *----- rrb001: the line directly below is the old method no longer used -----;
        ****name=upcase(translate(trim(name),"____________________"," '&%+()@/\#?=$!.,:-"));
        name=upcase(prxchange('s[^a-zA-Z0-9]+_',-1,trim(name)));
        colnames=trim(colnames)||" "||name;
        i=i+1;
        name=trim(scan(_infile_,i,&delimiter));
      end;
    %end;
    %else %do;
      name="";
      do i=1 to maxcol;
        colnames=trim(colnames)||" C"||compress(put(i,3.));
      end;
    %end;
    call symput('colnames',trim(colnames));
    stop;
  run;

  data &dsout;
    informat &colnames $&colw.. ;
    format &colnames $&colw.. ;
    infile "%nrstr(%superq(infile))" delimiter=&delimiter 
           MISSOVER DSD lrecl=32767 termstr=&termstr
    %if &getnames EQ Y %then %do;
      firstobs=2 
    %end;
    ;
    input &colnames;
  run;

  %goto skip;
  %exit: %put &err: (dlm2sas) Leaving macro due to problem(s) listed;
  %skip:

%mend dlm2sas;
/*<pre><b>
/ Program   : doallitem.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 09-Jun-2011
/ Purpose   : To execute code for each item in a space-delimited list
/ SubMacros : %words
/ Notes     : The code must be enclosed in single quotes. This can either be
/             macro code or SAS code. You can use this inside or outside a data
/             step. Refer to the elements as "&item". Do not worry that this is
/             surrounded by single quotes. These will be stripped inside the
/             macro.
/ Usage     : %doallitem(dsa dsb dsc,'proc sort data=&item;by var;run;');
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ __dolist          (pos) List of things (separated by spaces) to run code on
/ code              (pos) Code to run for each item. ENCLOSE IN SINGLE QUOTES.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/ rrb  09Jun11         First parameter name changed to "__dolist" from "list" in
/                      case the user is using a macro variable of that name in
/                      a call to this macro.
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: doallitem v1.1;

%macro doallitem(__dolist,code);
  %local i item err;
  %let err=ERR%str(OR);
  %if %qsubstr(&code,1,1) NE %str(%') 
  or %qsubstr(&code,%length(&code),1) NE %str(%') %then 
  %put &err: (doallitem) Code supplied to second parameter must be enclosed in single quotes; 
  %else %do i=1 %to %words(&__dolist); 
    %let item=%scan(&__dolist,&i,%str( )); 
  %substr(&code,2,%length(&code)-2) 
  %end; 
%mend doallitem; 

  /*<pre><b>
/ Program   : dosfdasize.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 15-Nov-2011
/ Purpose   : Function-style macro to check a dataset size and obs count against
/             FDA guideline limits.
/ SubMacros : %dosfilesize %nlobs
/ Notes     : This is to check the dataset size before it gets converted to a
/             sas transport file for sending to the FDA. If the dataset is too
/             large then it will need to be split into smaller files. How you do
/             that is up to you but normally it will need to be split in a
/             logical fashion and the files numbered or named logically as well.
/
/             This is a function-style macro that returns "OK" or "NOTOK" and
/             optionally issues warnings if size limits are broken.
/
/             The limits are taken from guidelines but may not be up to date so
/             you should recode the defaults in this macro if need be.
/ Usage     : %if %dosfdasize(dset) EQ NOTOK %then %do;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) dataset to check
/ maxmb=50          Megabyte limit (defaults to 50)
/ maxobs=125999     Observations limit (defaults to 1259999)
/ warn=yes          Whether to issue warnings or not
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  15Nov11         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: dosfdasize v1.0;

%macro dosfdasize(ds,maxmb=50,maxobs=125999,warn=yes);
  %local wrn size obs bytes maxsize;
  %let wrn=WAR%str(NING);
  %let bytes=%eval(&maxmb*1024*1024);
  %let obs=%nlobs(&ds);
  %let size=%dosfilesize(&ds);
  %let maxsize=%eval(&maxmb*1024*1024);
  %if not %length(&warn) %then %let warn=yes;
  %let warn=%upcase(%substr(&warn,1,1));
  %if &size GT &maxsize or &obs GT &maxobs %then %do;
NOTOK
    %if &warn EQ Y %then %do;
      %if &size GT &maxsize %then
%put &wrn: (dosfdasize) &ds byte size &size exceeds maximum allowed size &maxsize;
      %if &obs GT &maxobs %then
%put &wrn: (dosfdasize) &ds obs count &obs exceeds maximum allowed obs &maxobs;
    %end;
  %end;
  %else %do;
OK
  %end;
%mend dosfdasize;
/*<pre><b>
/ Program      : dosfilesize.sas
/ Version      : 2.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 15-Nov-2011
/ Purpose      : Function-style macro to return a DOS file size or a sas dataset
/                size in bytes.
/ SubMacros    : %qdosfileinfo
/ Notes        : This is a shell macro for calling the %qdosfileinfo macro to
/                get a DOS file size (in bytes). See the %qdosfileinfo macro for
/                other information you can extract about a DOS file.
/
/                You can supply a one or two level dataset name in which case it
/                will construct the full path name internally before calling the
/                %qdosfileinfo macro.
/
/ Usage        : %let filesize=%dosfilesize(C:\spectre\unistats.html);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dosfile           (pos) DOS file full path name or one/two level dataset name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  30Jul07         Header tidy
/ rrb  12Oct09         Call to %dosfileinfo changed to call to %qdosfileinfo due
/                      to macro renaming plus the %unquote() function used
/                      (v1.1)
/ rrb  04May11         Code tidy
/ rrb  15Nov11         Allow for a one or two level dataset name (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dosfilesize v2.0;

%macro dosfilesize(dosfile);
  %local lib ds filename;
  %if %length(%qscan(&dosfile,3,/\.)) %then %do;
%unquote(%qdosfileinfo(&dosfile,z))
  %end;
  %else %do;
    %if %length(%scan(&dosfile,2,.)) %then %do;
      %let lib=%scan(&dosfile,1,.);
      %let ds=%scan(&dosfile,2,.);
    %end;
    %else %do;
      %let ds=&dosfile;
      %let lib=%sysfunc(getoption(USER));
      %if not %length(&lib) %then %let lib=WORK;
    %end;
    %let filename=%sysfunc(pathname(&lib))\&ds..sas7bdat;
%unquote(%qdosfileinfo(&filename,z))
  %end;
%mend dosfilesize;
/*<pre><b>
/ Program   : dq2sq.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 27-May-2014
/ Purpose   : Function-style macro to translate double quotes to single quotes
/ SubMacros : none
/ Notes     : This assumes your quotes are balanced in the string you are
/             converting. Use this macro to ensure that any values you are
/             resolving within a double quoted string do not mess up the syntax
/             due to unknown double quotes being present in the values. A 
/             typical use of this would be to convert any possible double quotes
/             to single quotes in the sasautos option content when invoking a 
/             remote session as a double quoted string and passing your sasautos
/             option setting to that session. See usage notes.
/
/             If there might be commas in the string and you are happy to
/             convert those commas to spaces then use the %dq2sqnc macro which
/             is the ---nc = "no commas" equivalent of this macro. This will
/             also be applicable to the example in the usage notes since
/             sasautos libraries can be separated by commas.
/
/ Usage     : rsubmit wait=no process1 inheritlib=(work=lwork) 
/             sascmd="!sascmd -sasuser work -noautoexec 
/             -sasautos %dq2sq(%sysfunc(getoption(sasautos)))";
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String to translate double quotes to single quotes
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  27May14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dq2sq v1.0;

%macro dq2sq(str);
%sysfunc(translate(&str,%str(%'),%str(%")))
%mend dq2sq;
/*<pre><b>
/ Program   : dq2sqnc.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 27-May-2014
/ Purpose   : Function-style macro to translate double quotes to single quotes
/             after replacing commas in a string with spaces.
/ SubMacros : %dq2sq
/ Notes     : This assumes your quotes are balanced in the string you are
/             converting. Use this macro to ensure that any values you are
/             resolving within a double quoted string do not mess up the syntax
/             due to unknown double quotes being present in the values. A 
/             typical use of this would be to convert any possible double quotes
/             to single quotes in the sasautos option content when invoking a 
/             remote session as a double quoted string and passing your sasautos
/             option setting to that session. It also replaces all commas with
/             spaces which would be very applicable to the example in the usage
/             notes since sasautos libraries can be separated by commas when
/             they are not needed.
/
/             This macro should not use the parameter= convention. It should be
/             used with a purely positional parameter value only.
/
/ Usage     : rsubmit wait=no process1 inheritlib=(work=lwork) 
/             sascmd="!sascmd -sasuser work -noautoexec 
/             -sasautos %dq2sqnc(%sysfunc(getoption(sasautos)))";
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (only positional) String to translate double quotes to
/                   single quotes after replacing commas with spaces.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  27May14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dq2sqnc v1.0;

%macro dq2sqnc/parmbuff;
%dq2sq(%qsubstr(%sysfunc(translate(&syspbuff,%str( ),%str(,))),2,%length(&syspbuff)-2))
%mend dq2sqnc;
/*<pre><b>
/ Program   : dropend.sas
/ Version   : 1.2
/ Author    : Roland Rashleigh-Berry
/ Date      : 16-Apr-2013
/ Purpose   : Function-style macro to drop the end of a string along with the
/             specified delimiter.
/ SubMacros : none
/ Notes     : You would typically run this on a path name where you want to drop
/             the last segment and perhaps replace the last segment with another
/             string (see usage notes).
/
/             prxchange is used but your delimiter will be automatically 
/             escaped if required.
/
/             If the delimiter is a round bracket then you will both have to use
/             %nrbqoute() on the string and macro quote the round bracket
/             delimiter using %str(%() or %str(%)).
/
/             If the delimiter is a comma then you will have to use %nrbquote()
/             on the string and macro quote the comma delimiter using %str(,) .
/
/ Usage     : %let str=aaa\bbb\cccc\ddddd\eeee\pgm;
/             %put >>>>> %dropend(&str,\)\data;
/       >>>>> aaa\bbb\cccc\ddddd\eeee\data
/
/             %let str=aaa/bbb/cccc/ddddd/eeee/pgm;
/             %put >>>>> %dropend(&str,/)/data;
/       >>>>> aaa/bbb/cccc/ddddd/eeee/data
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/ delim             (pos) Delimiter
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  08Apr13         new (v1.0)
/ rrb  09Apr13         Changed so that if the delimiter is the last character in
/                      the string then the dropped end will act on the next to
/                      last delimiter (v1.1)
/ rrb  16Apr13         A delimiter character that need escaping for regular
/                      expression purposes will be automatically escaped by
/                      having a backslash put in front of it (v1.2)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dropend v1.2;

%macro dropend(str,delim);
%if %index(\.$^[]*+%str(,%(%)),&delim) %then %let delim=\&delim;
%sysfunc(prxchange(s|(^.*)&delim..+$|\1|,-1,%nrbquote(&str)))
%mend dropend;
/*<pre><b>
/ Program   : dropmodifiers.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 11-Jun-2013
/ Purpose   : In-datastep macro to remove the dataset modifiers from a variable
/             that contains single or multiple dataset names with possible
/             modifiers.
/ SubMacros : none
/ Notes     : Use this to strip out modifiers so you can identify datasets so
/             that you can run checks on them like check that they exist in
/             dictionary.tables . The result gets written back into the source
/             variable.
/ Usage     : data test;
/               set dset(keep=sourcedata domain);
/               %dropmodifiers(sourcedata);
/               *- now process the pure dataset names in sourcedata -;
/               put sourcedata=;
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) Variable containing dataset names with modifiers
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  11Jun13         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: dropmodifiers v1.0;

%macro dropmodifiers(str);
  *- non-greedy replace stuff in double quotes with "" -;
  &str=prxchange('s/".*?"/""/',-1,&str);
  *- non-greedy replace stuff in single quotes with '' -;
  &str=prxchange("s/'.*?'/''/",-1,&str);
  *- repeat until we have no more left round brackets   -;
  do while(index(&str,'('));
    *- Non-greedy replace stuff inside "( )" that does  -;
    *- not include a left round bracket with null.      -;
    &str=prxchange('s/\([^\(]*?\)//',-1,&str);
  end;
%mend dropmodifiers;
/*<pre><b>
/ Program   : dropmodifmac.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 14-Jun-2013
/ Purpose   : Function-style macro to return a string with dataset modifiers
/             removed from a macro variable string containing single or multiple
/             dataset names with possible modifiers.
/ SubMacros : none
/ Notes     : Use this to strip out modifiers so you can find out how many
/             datasets there are in the string and what the datasets are called.
/
/             !!!! IMPORTANT !!!!   Always pass the string to this macro using
/             %SUPERQ() as shown in the usage notes otherwise right round
/             brackets that are part of the modifiers might get dropped duing
/             processing when they should not be.
/
/ Usage     : %let str=ds1(where=(a=:")" and b=:')')) lib.ds2(drop = v1 v2);
/             %put >>> %dropmodifmac(%superq(str));
/             >>> ds1 lib.ds2
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) string containing dataset names with modifiers
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  14Jun13         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: dropmodifmac v1.0;

%macro dropmodifmac(str);
  %local tempstr;
  %*- non-greedy replace stuff in double quotes with "" -;
  %let tempstr=%sysfunc(prxchange(s!%str(%").*?%str(%")!""!,-1,
    %superq(str)));
  %*- non-greedy replace stuff in single quotes with '' -;
  %let tempstr=%sysfunc(prxchange(s!%str(%').*?%str(%')!''!,-1,
    %superq(tempstr)));
  %*- repeat until we have no more left round brackets   -;
  %do %while( %index(%superq(tempstr),%str(%()) );
    %*- Non-greedy replace stuff inside "( )" that does  -;
    %*- not include a left round bracket with null.      -;
    %let tempstr=%sysfunc(prxchange(s!\%str(%()[^\%str(%()]*?\%str(%))!!,-1,
      %superq(tempstr)));
  %end;
&tempstr
%mend dropmodifmac;

/*<pre><b>
/ Program   : dropvars.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To drop a list of unwanted variables in a list of datasets.
/ SubMacros : %dsall %words %varlist %quotelst
/ Notes     : You can use the _all_ notation to refer to all the datasets in a
/             library.
/ Usage     : %dropvars(work._all,x1 x2)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ list              (pos) List of datasets. The _all_ notation can be used.
/ drop              (pos) List of variables to drop.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dropvars v1.0;

%macro dropvars(list,drop);

  %local dropvars varlist i j;
  %dsall(&list)
  %let drop=%quotelst(%upcase(&drop));

  %do i=1 %to %words(&_dsall_);
    %let dropvars=;
    %let varlist=%varlist(%scan(&_dsall_,&i,%str( )));
    %do j=1 %to %words(&varlist);
      %if %index(&drop,"%upcase(%scan(&varlist,&j,%str( )))") 
        %then %let dropvars=&dropvars %scan(&varlist,&j,%str( ));
    %end;
    %if %length(&dropvars) %then %do;
      data %scan(&_dsall_,&i,%str( ));
        set %scan(&_dsall_,&i,%str( ));
        drop &dropvars;
      run;
    %end;
  %end;

%mend dropvars;
/*<pre><b>
/ Program   : ds2tabdlm.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To write the contents of a sas dataset to a tab-delimited file
/ SubMacros : %varlist %words %sas2tabdlm
/ Notes     : If a variable is formatted then that format is applied to the 
/             value.
/
/             If you do not specify a destination file then the contents will
/             be written to the log but the tab characters will not be seen.
/
/             You can use the %dlm2sas macro to convert the output file back
/             into a sas dataset but all columns will be treated as character.
/
/ Usage     : %ds2tabdlm(sashelp.cars,,yes)
/             %ds2tabdlm(sashelp.cars,C:\mylib\myfile.txt,yes)
/             %ds2tabdlm(sashelp.cars,"C:\mylib\myfile.txt",no)
/             %ds2tabdlm(sashelp.cars,"C:\mylib\myfile.txt")
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name (no modifiers)
/ dest              (pos) Destination file (quoted or unquoted)
/ varnames          (pos) By default, show the variable names in the first row.
/                   Set to no to suppress this.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Mar14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: ds2tabdlm v1.0;

%macro ds2tabdlm(ds,dest,varnames);
  %sas2tabdlm(&ds,&dest,&varnames)
%mend ds2tabdlm;
/*<pre><b>
/ Program   : dsall.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To expand out the _all_ in a dataset list into all datasets in the
/             library.
/ SubMacros : %words %dslist
/ Notes     : This is NOT a function-style macro. See usage notes.
/             The list of datasets will be written to the global macro variable
/             _dsall_.
/ Usage     : %dsall(sasuser.test work._all_);
/             %let dsall=&_dsall_;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ list              (pos) List of datasets some of which may be referred to 
/                   using the _all_ notation.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  05May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: dsall v1.0;

%macro dsall(list);
  %global _dsall_;
  %let _dsall_=;
  %local i;
  %do i=1 %to %words(&list);
    %if "%upcase(%scan(%scan(&list,&i,%str( )),2,.))" NE "_ALL_" %then 
      %let _dsall_=&_dsall_ %scan(&list,&i,%str( ));
    %else %do;
      %dslist(%scan(%scan(&list,&i,%str( )),1,.),yes)
      %let _dsall_=&_dsall_ &_dslist_;
    %end;
  %end;
%mend dsall;
/*<pre><b>
/ Program   : dsattr.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 02-Apr-2013
/ Purpose   : Extract attributes for a dataset from dictionary.columns
/ SubMacros : none
/ Notes     : This is a simple macro to extract dataset attributes from
/             dictionary.columns and write them to an output dataset in variable
/             name order. Variables present will be name, length, type, format,
/             informat, label and varnum. The dataset created is suitable for
/             the dsattr= parameter for the %lstattrib macro and is also
/             suitable to be updated by the dataset coming out of the %optlength
/             macro.
/
/             See also the %dsattrib macro.
/
/ Usage     : %dsattr(sashelp.class,classattr);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsin              (pos) (unquoted) One-level or two-level input dataset name
/ dsout             (pos) (unquoted) One-level or two-level output dataset name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  02Apr13         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: dsattr v1.0;

%macro dsattr(dsin,
              dsout
             );

  %local lib dsname errflag err savopts;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&dsin) %then %do;
    %let errflag=1;
    %put &err: (dsattr) No input dataset specified as first positional parameter;
  %end;

  %if &errflag %then %goto exit;

  %if not %length(&dsout) %then %let dsout=_dsattr;

  %let savopts=%sysfunc(getoption(notes));


  %if not (%sysfunc(exist(&dsin)) OR %sysfunc(exist(&dsin,VIEW))) %then %do;
    %let errflag=1;
    %put &err: (dsattr) Specified dataset &dsin does not exist;
  %end;
  %if &errflag %then %goto exit;

  %if not %length(%scan(&dsin,2,.)) %then %do;
    %let lib=%sysfunc(getoption(user));
    %if not %length(&lib) %then %let lib=work;
    %let lib=%upcase(&lib);
    %let dsname=%upcase(&dsin);
  %end;
  %else %do;
    %let lib=%upcase(%scan(&dsin,1,.));
    %let dsname=%upcase(%scan(&dsin,2,.));
  %end;

  options nonotes;

  proc sql noprint;
    create table &dsout as
    select name, length, type, format, informat, label, varnum
    from dictionary.columns
    where libname="&lib" and memname="&dsname"
    order by name;
  quit;

  options &savopts;

  %goto skip;
  %exit: %put &err: (dsattr) Leaving macro due to problem(s) listed;
  %skip:

%mend dsattr;
/*<pre><b>
/ Program   : dsattrib.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 08-May-2011
/ Purpose   : To force a set of attributes, held in a template dataset,
/             on another dataset.
/ SubMacros : %sortedby %dslabel %varlist %nvarsc %nvarsn %missvars %misscnt
/ Notes     : The template dataset can either have observations or not. None of
/             its observations will be carried forward to the output dataset.
/             See also the %lstattrib macro.
/ Usage     : %dsattrib(template,inds,outds)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ template          Template dataset (pos). Please do not rename any sortby
/                   variables on the dataset statement.
/ dsin              Input dataset (pos)
/ dsout             Output dataset (pos) (No drop, keep, rename or where)
/ misscnt           Will display a count of missing values by default. Set this
/                   to "no" to stop this (pos - unquoted)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  18Oct09         Header update
/ rrb  08May11
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dsattrib v1.0;

%macro dsattrib(template,dsin,dsout,misscnt);

  %local sortedby dslabel varlist nvarsc nvarsn err wrn;

  %let err=ERR%str(OR);
  %let wrn=WAR%str(NING);
  %if %length(&misscnt) EQ 0 %then %let misscnt=yes;
  %let misscnt=%upcase(%substr(&misscnt,1,1));


  *- get the label and sortedby list from the template dataset -;
  %let sortedby=%sortedby(%scan(&template,1,%str(%()));
  %let dslabel=%dslabel(%scan(&template,1,%str(%()));


  *- drop all observations from the template dataset -;
  options obs=0;
  data _templ;
    set &template;
  run;
  options obs=max;


  *- get the variable list from the template dataset -;
  %let varlist=%varlist(_templ);


  *- allow where/keep/drop/rename to apply to input dataset -;
  data _dsin;
    set &dsin;
  run;


  *- find out the number of character and numeric variables --;
  %let nvarsc=%nvarsc(_dsin);
  %let nvarsn=%nvarsn(_dsin);


  *- nullify any formats and informats -;
  data _dsin;
    set _dsin;
    %if &nvarsc GT 0 %then %do;
      informat _character_ ;
      format _character_ ;
    %end;
    %if &nvarsn GT 0 %then %do;
      informat _numeric_ ;
      format _numeric_ ;
    %end;
  run;


  *- create the corrected output dataset -;
  data &dsout(label="&dslabel");
    set _templ _dsin(keep=&varlist);
  run;


  *- sort the output dataset if the template dataset was sorted -;
  %if %length(&sortedby) GT 0 %then %do;
    proc sort data=&dsout;
      by &sortedby;
    run;
  %end;


  *- report all-missing variables as an error -;
  %missvars(&dsout,globvar=_miss_);
  run;
  %if %length(&_miss_) GT 0 %then %do;
    %put &err: (dsattrib) The following variables in the input dataset were all-missing;
    %put &err: (dsattrib) &_miss_;
  %end;


  *- optionally report missing value count (excluding all-missing variables) -;
  *- as a warning.;
  %if "&misscnt" EQ "Y" %then %do;
    %misscnt(&dsout,&_miss_,globvar=_miss_);
    run;
    %if %length(&_miss_) GT 0 %then %do;
      %put &wrn: (dsattrib) The following variables have a missing value count as shown;
      %put &wrn: (dsattrib) &_miss_;
    %end; 
  %end;


  *- tidy up temporary datasets -;
  proc datasets nolist;
    delete _templ _dsin;
  run;
  quit;

%mend dsattrib;
/*<pre><b>
/ Program   : dslabel.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return a dataset label
/ SubMacros : %attrc
/ Notes     : This is a shell macro that calls %attrc
/ Usage     : %let dslabel=%dslabel(dsname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dslabel v1.0;

%macro dslabel(ds);
%attrc(&ds,label)
%mend dslabel;
/*<pre><b>
/ Program   : dslist.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To list all the datasets in a libref.
/ SubMacros : none
/ Notes     : This is NOT a function-style macro. See usage notes.
/             You can set an option to prefix the dataset names with the libref.
/             The list of datasets will be written to the global macro variable
/             _dslist_.
/ Usage     : %dslist(work);
/             %let dslist=&_dslist_;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ libref            (pos) Libref name for which all datasets are to be listed
/ prefix            (pos) Set this to anything at all and all dataset names will
/                   be prefixed with the libref name.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dslist v1.0;

%macro dslist(libref,prefix);
  %global _dslist_;
  %let _dslist_=;
  %if not %length(&libref) %then %let libref=%sysfunc(getoption(user));
  %if not %length(&libref) %then %let libref=work;
  %let libref=%upcase(&libref);

  proc sql noprint;
    select distinct memname into :_dslist_ separated by
    %if %length(&prefix) %then %do;
      " &libref.."
    %end;
    %else %do;
      ' '
    %end;
    from dictionary.tables
    where memtype='DATA'
    and libname="&libref";
  quit;

  %if %length(&prefix) %then %let _dslist_=&libref..&_dslist_;
  run;
%mend dslist;
/*<pre><b>
/ Program   : dsplit.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 06-May-2013
/ Purpose   : To split up a space delimited list of datasets (with possible
/             complex modifiers involving nested and quoted brackets) into
/             individual datasets with their corresponding modifiers and write
/             them to global macro variables.
/ SubMacros : none
/ Notes     : Global macro variables _dsplit1_, _dsplit2_ etc. will be created 
/             to receive the dataset names and the total will be written to the
/             global macro variable _dsplitnum_ .
/
/             The idea of using a parmbuff macro to get sas to recognise
/             balanced brackets came from Jim Groeneveld from a SAS-L thread on
/             the subject entitled "Programmatically matching parentheses. How?"
/
/ Usage     : %let str=dset1  dset2( keep= aa bb cc ) dset3( drop = dd ee )
/             dset4;
/             %dsplit(%nrbquote(&str));
/             %put _dsplitnum_=&_dsplitnum_;
/             %put _dsplit1_=&_dsplit1_;
/             %put _dsplit2_=&_dsplit2_;
/             %put _dsplit3_=&_dsplit3_;
/             %put _dsplit4_=&_dsplit4_;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) List of dataset names seperated by spaces (enclose in
/                   %nrbquote() if it contains modifiers).
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  06May13         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dsplit v1.0;

%macro dsplit(str);

  %local i numds strseg pos len1 len2 num dlm1 dlm2 matchbr dummy;
  %global _dsplitnum_;

  %*- The following macro is used to get a matching bracket -;
  %*- string which will be the value of &syspbuff. SAS will -;
  %*- know if any brackets are in quotes or nested and will -;
  %*- give you a correct balanced string in brackets.       -;

  %macro _dsplit / parmbuff;
    %let matchbr=&syspbuff;
  %mend _dsplit;

  %let strseg=&str;
  %let numds=0;
  %let pos=0;
  %let len1=88;
  %let len2=99;
  %let num=1;
  %let dlm1=%str(%();
  %let dlm2=%str(%));

  %do %while(&len1 NE &len2 AND %superq(strseg) NE );
    %syscall scan(strseg,num,pos,len1,dlm1);
    %syscall scan(strseg,num,pos,len2,dlm2);
    %let words=%words(%sysfunc(subpad(%nrbquote(&strseg),1,&len1)));
    %do i=1 %to &words;
      %let numds=%eval(&numds+1);
      %global _dsplit&numds._;
      %let _dsplit&numds._=%scan(%sysfunc(subpad(%nrbquote(&strseg),
      1,&len1)),&i,%str( ));
    %end;
    %if &len1 NE &len2 %then %do;
      %*- get ready to call the _dsplit macro -;
      %let dummy=%nrstr(%_dsplit) %substr(%nrbquote(&strseg),&len1+1);
      %*- call the _dplit macro for real to get the matching bracket string -;
      %let dummy=%unquote(&dummy);
      %*- add the matching bracket string on the end of the dataset name -;
      %let _dsplit&numds._=&&&_dsplit&numds._&matchbr;
      %*- go to the next part of the input string -;
      %let strseg=%sysfunc(subpad(%nrbquote(&strseg),&len1+%length(&matchbr)+1));
    %end;
  %end;

  %let _dsplitnum_=&numds;

%mend dsplit;

/*<pre><b>
/ Program   : dtscale.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To generate a date scale for sas/graph
/ SubMacros : none
/ Notes     : If you get the min and max date the wrong way round then the macro
/             will swap them over. Values will be written to the global macro
/             variables _from_, _to_ and _by_. They will be pure numbers. It is
/             up to you to use a suitable format.
/ Usage     : %dtscale(&min,&max);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ min               (pos) Minimum date (text numeric)
/ max               (pos) Maximum date (text numeric)
/ ticks=7           Number of major tick marks on the axis
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: dtscale v1.0;

%macro dtscale(min,max,ticks=7);

  %global _from_ _to_ _by_;
  %local swap;

  %if %sysevalf(&max < &min) %then %do;
    %let swap=&max;
    %let max=&min;
    %let min=&swap;
  %end;

  data _null_;
    _to=&max;
    _by=ceil((&max-&min)/(&ticks-1));
    _from=_to-(_by*(&ticks-1));
    call symput('_from_',compress(put(_from,11.)));
    call symput('_to_',compress(put(_to,11.)));
    call symput('_by_',compress(put(_by,11.)));  
  run;

%mend dtscale;
/*<pre><b>
/ Program   : duplvars.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to create a list of duplicate variables in a
/             second dataset so that they can be dropped before a merge.
/ SubMacros : %varlist %quotelst %words %remove
/ Notes     : The variables to ignore as duplicates will be the "by" variables
/             the datasets are being merged on, most usually.
/ Usage     : data newds;
/               merge ds1 ds2(drop=%duplvars(ds1,ds2,&bylist));
/               by &bylist;
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds1               (pos) Primary dataset to merge (no keep/drop/rename etc.)
/ ds2               (pos) Secondary dataset to merge (no keep/drop/rename etc.)
/                   for which you want to identify duplicate variables.
/ ignore            (pos) List of variables to ignore from the duplicate list
/                   (variable list separated by spaces - no quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: duplvars v1.0;

%macro duplvars(ds1,ds2,ignore);

  %local varlist1 varlist2 duplvars bylist i;

  %let varlist1=%quotelst(%varlist(&ds1));
  %let varlist2=%quotelst(%varlist(&ds2));
  %let bylist=%quotelst(&ignore);

  %do i=1 %to %words(&bylist);
    %let varlist2=%remove(&varlist2,%scan(&bylist,&i,%str( )),no);
  %end;

  %do i=1 %to %words(&varlist2);
    %if %index(%upcase(&varlist1),%upcase(%scan(&varlist2,&i,%str( )))) 
      %then %let duplvars=&duplvars %scan(&varlist2,&i,%str( ));
  %end;

%sysfunc(compress(&duplvars,%str(%")))

%mend duplvars;
/*<pre><b>
/ Program   : editlist.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 01-Nov-2012
/ Purpose   : Function-style macro to allow you to edit a list of space 
/             delimited items.
/ SubMacros : none
/ Notes     : This macro is for tasks like generating rename statements where a
/             repeat of items in a list is required (see usage notes). The edit
/             string must be enclosed in single quotes. Elements of the list
/             are written to the macro variable "item" which can be referenced
/             in the edit string. If semicolons form part of the edit string
/             then for certain uses these can be protected using %nrstr().
/
/             If used in sas code you might need to %unquote() the final string.
/
/             This macro is essentially the same as the %doallitem macro but
/             giving a different usage emphasis and with no submacros.
/
/ Usage     : %put >>> %editlist(aa bb cc dd,'&item=mr_&item');
/             %put >>> %editlist(xx_aa xx_bb xx_cc,
/             '&item=%substr(&item,4)');
/             %put >>> %editlist(xx_aa xx_bb xx_cc,
/             '%substr(&item,4)=&item%nrbquote(;)');
/
/             (will write to log:)
/             >>> aa=mr_aa bb=mr_bb cc=mr_cc dd=mr_dd
/             >>> xx_aa=aa xx_bb=bb xx_cc=cc
/             >>> aa=xx_aa; bb=xx_bb; cc=xx_cc;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ list              (pos) List of space delimited items
/ editstr           (pos) Edit string (in single quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  31Oct12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: editlist v1.0;

%macro editlist(list,editstr);
  %local i item;
  %let i=1;
  %let item=%scan(&list,&i,%str( ));
  %do %while(%length(&item));
%sysfunc(dequote(&editstr))
    %let i=%eval(&i + 1);
    %let item=%scan(&list,&i,%str( ));
  %end;
%mend editlist;
/*<pre><b>
/ Program   : endwith.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to ensure any non-null value assigned to a
/             macro variable ends with the specified character.
/ SubMacros : none
/ Notes     : This was originally written to ensure that directories assigned to
/             macro variables end with the directory slash, if indeed anything
/             had been assigned. This is difficult to do in open code and so
/             this macro was written.
/ Usage     : filename outfile "%endwith(&outdir,/)output.txt";
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ value             (pos) Contents of macro variable.
/ char              (pos) Character to make sure it ends with if not null.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: endwith v1.0;

%macro endwith(value,char); 
  %if %length(&value) %then %do; 
    %if "%qsubstr(&value,%length(&value),1)" NE "&char" %then %do; 
%superq(value)&char 
    %end; 
    %else %do; 
&value 
    %end; 
  %end; 
  %else %do; 
&value 
  %end; 
%mend endwith;
/*<pre><b>
/ Program   : env2ds.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 25-Jul-2011
/ Purpose   : To write system and user environment variables to a dataset.
/ SubMacros : none
/ Notes     : By default, the output dataset will be named _env2ds. The name of
/             the environment variables will be held in the variable "name" with
/             length 40 and the value will be held in the variable "value" with
/             length 1000. A temporary file reference is used named "_env2ds"
/             that will be cleared after use.
/
/             This version is for non-specifc operating systems but might not
/             work on the Windows 7 operating system due to unnamed pipes not
/             working. If you are running on Windows 7 and this macro does not 
/             work then use %env2dsw7 instead.
/
/             For later version of SAS software then this information might be
/             held in the sashelp library as a view in which case this macro
/             will be withdrawn.
/
/ Usage     : %env2ds;
/             %env2ds(OutputDatasetName);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsout             (pos) Name of output dataset (defaults to _env2ds)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  25Jul11         Test for missing value added (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: env2ds v1.1;

%macro env2ds(dsout);

  %if not %length(&dsout) %then %let dsout=_env2ds;

  filename _env2ds pipe 'set';

  data &dsout;
    length name $ 40 value $ 1000;
    infile _env2ds;
    input;
    name=scan(_infile_,1,"=");
    if scan(_infile_,2,"=") NE " " then value=substr(_infile_,index(_infile_,"=")+1);
    label name="Environment Variable Name"
         value="Environment Variable Value"
    ;
  run;

  filename _env2ds clear;
  run;

%mend;
/*<pre><b>
/ Program   : env2dsw7.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 25-Jul-2011
/ Purpose   : To write system and user environment variables to a dataset for
/             the Windows 7 operating system.
/ SubMacros : none
/ Notes     : By default, the output dataset will be named _env2ds. The name of
/             the environment variables will be held in the variable "name" with
/             length 40 and the value will be held in the variable "value" with
/             length 1000. A temporary file reference is used named "_env2ds"
/             that will be cleared after use.
/
/             This is a version specifically written for the Windows 7 operating
/             system where using unnamed pipes does not work in the way %env2ds
/             (the non-specific operating system version) uses it. However, it
/             should work for all versions of the Windows operating system.
/
/             For later version of SAS software then this information might be
/             held in the sashelp library as a view in which case this macro
/             will be withdrawn.
/
/ Usage     : %env2dsw7;
/             %env2dsw7(OutputDatasetName);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsout             (pos) Name of output dataset (defaults to _env2ds)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  25Jul11         Test for missing value added (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: env2dsw7 v1.1;

%macro env2dsw7(dsout);

  %if not %length(&dsout) %then %let dsout=_env2ds;

  x 'set > C:\Windows\Temp\_env2dsw7.tmp';

  filename _env2ds 'C:\Windows\Temp\_env2dsw7.tmp';

  data &dsout;
    length name $ 40 value $ 1000;
    infile _env2ds;
    input;
    name=scan(_infile_,1,"=");
    if scan(_infile_,2,"=") NE " " then value=substr(_infile_,index(_infile_,"=")+1);
    label name="Environment Variable Name"
         value="Environment Variable Value"
    ;
  run;

  filename _env2ds clear;
  run;

  x 'del C:\Windows\Temp\_env2dsw7.tmp';
  run;

%mend;
/*<pre><b>
/ Program   : env2sas.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To write system and user environment variables to a dataset.
/ SubMacros : %env2ds
/ Notes     : By default, the output dataset will be named _env2sas. The name of
/             the environment variables will be held in the variable "name" with
/             length 40 and the value will be held in the variable "value" with
/             length 1000. A temporary file reference is used named "_env2ds"
/             that will be cleared after use.
/
/             This version is for non-specifc operating systems but might not
/             work on the Windows 7 operating system due to unnamed pipes not
/             working. If you are running on Windows 7 and this macro does not 
/             work then use %env2dsw7 instead.
/
/             For later version of SAS software then this information might be
/             held in the sashelp library as a view in which case this macro
/             will be withdrawn.
/
/ Usage     : %env2sas;
/             %env2sas(OutputDatasetName);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsout             (pos) Name of output dataset (defaults to _env2sas)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Mar14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: env2sas v1.0;

%macro env2sas(dsout);
  %if not %length(&dsout) %then %let dsout=_env2sas;
  %env2ds(&dsout)
%mend env2sas;
/*<pre><b>
/ Program   : env2sasw7.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To write system and user environment variables to a dataset for
/             the Windows 7 operating system.
/ SubMacros : %env2dsw7
/ Notes     : By default, the output dataset will be named _env2sas. The name of
/             the environment variables will be held in the variable "name" with
/             length 40 and the value will be held in the variable "value" with
/             length 1000. A temporary file reference is used named "_env2ds"
/             that will be cleared after use.
/
/             This is a version specifically written for the Windows 7 operating
/             system where using unnamed pipes does not work in the way %env2ds
/             (the non-specific operating system version) uses it. However, it
/             should work for all versions of the Windows operating system.
/
/             For later version of SAS software then this information might be
/             held in the sashelp library as a view in which case this macro
/             will be withdrawn.
/
/ Usage     : %env2sasw7;
/             %env2sasw7(OutputDatasetName);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsout             (pos) Name of output dataset (defaults to _env2sas)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Mar14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: env2sasw7 v1.0;

%macro env2sasw7(dsout);
  %if not %length(&dsout) %then %let dsout=_env2sas;
  %env2dsw7(&dsout)
%mend env2sasw7;
/*<pre><b>
/ Program   : eqsuff.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to suffix a list of words (usually variables)
/             with an equals sign.
/ SubMacros : %words %quotelst
/ Notes     : Use this when you want to "put" the values of a list of variables
/             out to the log.
/ Usage     : put %eqsuff(&varlist);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ list              (pos) List of items to end with an equals sign
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: eqsuff v1.0;

%macro eqsuff(list);
  %if %words(&list) %then %quotelst(&list,quote=,delim=%str(= ))=;
%mend eqsuff;
/*<pre><b>
/ Program   : equals.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : In-datastep function-style macro to compare two numeric values to
/             find if they are equal or very nearly equal.
/ SubMacros : none
/ Notes     : This technique was copied from the SAS Technical Support site but
/             amended slightly. You use it in a data step. You can get very
/             slight differences in values depending how a value was arrived at
/             but they will be very close. This code will compare them but allow
/             for tiny differences.
/ Usage     : if %equals(val1,7.3) then ...
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ val1              (pos) First value for comparison (can be text or a variable)
/ val2              (pos) Second value for comparison (text or a variable)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: equals v1.0;

%macro equals(val1,val2);
(abs(&val1-&val2) LE 1E-15*max(abs(&val1),abs(&val2)))
%mend equals;
/*<pre><b>
/ Program   : fencoding.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 17-Jun-2014
/ Purpose   : To determine the encoding of a text file
/ SubMacros : none
/ Notes     : This macro checks the first few bytes of a text file and best
/             guesses the file encoding from this and displays it in the log
/             along with the start of the file as text.
/ Usage     : %fencoding(full-file-path);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ filepath          (pos) File path (quoted or unquoted)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  17Jun14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: fencoding v1.0;


%macro fencoding(filepath);

  %local savopts;
  %let savopts=%sysfunc(getoption(notes));

  options nonotes;

  %let filepath=%sysfunc(dequote(&filepath));

  data _null_;
    length filestart $ 16;
    rc=filename('fref1',"&filepath");
    fid1=fopen('fref1','I',32767,'B');
    if fid1<=0 then put "ERR" "OR: (fencoding) File &filepath could not be opened";
    else do;
      put;
      eof1=fread(fid1);
      get1=fget(fid1,filestart,16);
      if 31<rank(subpad(filestart,1,1))<127
       and 31<rank(subpad(filestart,2,1))<127
       then put "Plain ascii (ANSI)";
      else if subpad(filestart,1,3)='EFBBBF'X then put "UTF-8";
      else if subpad(filestart,1,2)='FEFF'X then put "UTF-16 (BE)";
      else if subpad(filestart,1,2)='FFFE'X then put "UTF-16 (LE)";
      else if subpad(filestart,1,4)='0000FEFF'X then put "UTF-32 (BE)";
      else if subpad(filestart,1,4)='0000FFFE'X then put "UTF-32 (LE)";
      else if subpad(filestart,1,3)='2B2F76'X then put "UTF-7";
      else if subpad(filestart,1,3)='F7644C'X then put "UTF-1";
      else if subpad(filestart,1,4)='DD736673'X then put "UTF-EBCDIC";
      else if subpad(filestart,1,3)='0EFEFF'X then put "SCSU";
      else if subpad(filestart,1,3)='FBEE28'X then put "BOCU-1";
      else if subpad(filestart,1,4)='84319533'X then put "GB-18030";
      else put "Binary (maybe)";
      put filestart=;
      put;
      rc=fclose(fid1);
    end;
    rc=filename('fref1',' ');
  run;

  options &savopts;

%mend fencoding;
/*<pre><b>
/ Program   : findinhash.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 29-Apr-2014
/ Purpose   : In-datastep macro to call a hash object
/ SubMacros : none
/ Notes     : This macro should be used in a data step along with the
/             %makehash macro as shown in the usage notes. A numeric variable
/             named "_rc" that receives the return code is created and can be
/             dropped from the output dataset using a DROP statement.
/ Usage     : data test2;
/               %findinhash(class,sashelp.class,name age,sex height weight);
/               set test;
/               %findinhash(class);
/               DROP _rc;
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ hashname          (pos) Name of the hash object to call (unquoted)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Apr14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: findinhash v1.0;

%macro findinhash(hashname);
_rc=&hashname..find();
%mend findinhash;
/*<pre><b>
/ Program   : fixiso8601.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 27-Feb-2014
/ Purpose   : In-datastep macro to give ranges for partial ISO 8601 dates
/ SubMacros : none
/ Notes     : This accepts as a parameter the name of a text variable that
/             contains an ISO 8601 datetime of the form YYYY-MM-DDThh:mm:ss.ss
/             or an ISO 8601 date of the form YYYY-MM-DD . This is the only
/             pattern this macro can work with at present.
/
/             The macro has to be used as part of a data step. See usage notes.
/
/             This macro takes the ISO date string and creates the numeric
/             variables DATELO, DATEHI, TIMELO, TIMEHI, DTTMLO and DTTMHI which
/             have suitable formats that follow the pattern of the input ISO
/             date string. You must make sure that your input dataset does not
/             contain variables of the same name.
/
/             This macro uses the following working variables: _yy _mm _dd _hh
/             _min _ss _nmiss so you must make sure that your input dataset does
/             not contain variables of the same name. These working variables
/             will be dropped in the data step. A variable named _obsno which is
/             set equal to _n_ is also created and kept.
/
/             The main purpose of this macro is to fix partial dates. This is
/             reflected by the --LO and --HI variables. If the input date is not
/             partial then the --LO and --HI values will be the same. If the
/             input date is a pure date of the form YYYY-MM-DD and the date is
/             not partial then DATELO = DATEHI but since the time is not present
/             then this will be regarded as partial with the time missing and so
/             you will have a difference in the TIMELO, TIMEHI, DTTMLO and DTTMHI
/             values.
/
/             Where the input date or datetime is partial then this macro does
/             not impute a value but rather gives you the range of values that
/             is covered as the difference between the --LO and --HI values. You
/             use these as part of an algorithm to impute a "fixed" value if you
/             need to. You can also use these high and low values to match on
/             time periods if you need to. In this last case you might get
/             multiple matches on time period and you may need to select on one
/             of these.
/
/             If there is an overlap with a time period then the following
/             condition will be true, which you could use as part of a 
/             "left join", "on" condition using SQL:
/                   (a.start<=b.end) and (b.start<=a.end)
/
/             You can use date low and high values to compare with period low
/             and high values using the formula above to find overlapping
/             periods. If you are imputing a date then you would identify the
/             periods that are overlapped, choose which of those period is the
/             more important one and the imputed date would normally be the
/             highest of the two start values. You may also wish not to assign
/             to a period if there is more than one overlapping period.
/
/ Usage     : data mydset2;
/               set mydset;
/               %fixiso8601(isodtc);
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ datestr           (pos) Name of the character variable that contains the
/                   ISO 8601 date of the form YYYY-MM-DDThh:mm:ss.ss
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  02Aug13         New (v1.0)
/ rrb  27Feb14         Add _obsno variable (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: fixiso8601 v1.1;

%macro fixiso8601(datestr);

  *===== assign values to working variables =====;
  _yy=input(substr(&datestr,1,4),?? 4.);
  _mm=input(subpad(&datestr,6,2),?? 2.);
  _dd=input(subpad(&datestr,9,2),?? 2.);
  _hh=input(subpad(&datestr,12,2),?? 2.);
  _min=input(subpad(&datestr,15,2),?? 2.);
  _ss=input(subpad(&datestr,18),?? BEST5.);
  _obsno=_n_;

  *========= do the date part ==========;
  _nmiss=nmiss(_yy,_mm,_dd);
  if _nmiss=0 then do;
    datelo=mdy(_mm,_dd,_yy);
    datehi=datelo;
  end;
  else if missing(_dd) and not missing(_mm) then do;
    datelo=mdy(_mm,1,_yy);
    datehi=intnx('month',datelo,0,'end');
  end;
  else if missing(_mm) and not missing(_dd) then do;
    datelo=mdy(1,_dd,_yy);
    datehi=mdy(12,_dd,_yy);
  end;
  else if not missing(_yy) then do;
    datelo=mdy(1,1,_yy);
    datehi=intnx('year',datelo,0,'end');
  end;
  else do;
    datelo=.;
    datehi=.;
  end;

  *========= do the time part ==========;
  _nmiss=nmiss(_hh,_min,_ss);
  if _nmiss=0 then do;
    timelo=hms(_hh,_min,_ss);
    timehi=timelo;
  end;
  else if _nmiss=3 then do;
    timelo=hms(0,0,0);
    timehi=hms(23,59,59.9);
  end;
  else if missing(_hh) then do;
    if not missing(_min) and not missing(_ss) then do;
      timelo=hms(0,_min,_ss);
      timehi=hms(23,_min,_ss);
    end;
    else if not missing(_min) then do;
      timelo=hms(0,_min,0);
      timehi=hms(23,_min,59.9);
    end;
    else if not missing(_ss) then do;
      timelo=hms(0,0,_ss);
      timehi=hms(23,59,_ss);
    end;
  end;
  else if missing(_min) then do;
    if not missing(_hh) and not missing(_ss) then do;
      timelo=hms(_hh,0,_ss);
      timehi=hms(_hh,59,_ss);
    end;
    else if not missing(_hh) then do;
      timelo=hms(_hh,0,0);
      timehi=hms(_hh,59,59.9);
    end;
    else if not missing(_ss) then do;
      timelo=hms(_hh,0,_ss);
      timehi=hms(_hh,59,_ss);
    end;
  end;
  else if missing(_ss) then do;
    timelo=hms(_hh,_min,0);
    timehi=hms(_hh,_min,59.9);
  end;

  *==== create the datetime part ======;
  dttmlo=dhms(datelo,0,0,timelo);
  dttmhi=dhms(datehi,0,0,timehi);

  format datelo datehi yymmdd10. 
         timelo timehi time11.2
         dttmlo dttmhi E8601DT23.2
  ;
  drop _yy _mm _dd _hh _min _ss _nmiss;

%mend fixiso8601;
/*<pre><b>
/ Program   : fixnames.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : In-datastep macro to fix UTF-8 characters in a person's name by
/             converting the UTF-8 character pairs back to ascii.
/ SubMacros : none
/ Notes     : This is only intended to work on people's names and is only
/             intended for the spelling of European and Scandinavian names. It
/             should also work for South American names. You should use it when
/             you have received data from a UTF-8 system and you are working on
/             an ascii system and you notice that one or more dataset variables
/             contain corruptions to peoples names due to UTF-8 characters. This
/             macro is used in a data step to convert these UTF-8 character
/             pairs back into a single ascii character. This is a problem
/             sometimes encountered with investigator names for multinational,
/             multi-centre clinical trials. You should be warned that if a
/             genuine name contains a capital "A" topped with a tilde then this
/             macro will likely corrupt that name.
/ Usage     : data newpatinfo;
/               set patinfo;
/               %fixnames(invname)
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ namevar           (pos) Name of the variable containing possibly corrupted
/                   names.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: fixnames v1.0;

%macro fixnames(namevar);
  &namevar=tranwrd(&namevar,"C380"x,"C0"x); *- large a grave -;
  &namevar=tranwrd(&namevar,"C381"x,"C1"x); *- large a acute -;
  &namevar=tranwrd(&namevar,"C382"x,"C2"x); *- large a circumflex -;
  &namevar=tranwrd(&namevar,"C383"x,"C3"x); *- large a tilde -;
  &namevar=tranwrd(&namevar,"C384"x,"C4"x); *- large a diaeresis -;
  &namevar=tranwrd(&namevar,"C385"x,"C5"x); *- large a ring -;
  &namevar=tranwrd(&namevar,"C386"x,"C6"x); *- large ae -;
  &namevar=tranwrd(&namevar,"C387"x,"C7"x); *- large c cedilla -;
  &namevar=tranwrd(&namevar,"C388"x,"C8"x); *- large e grave -;
  &namevar=tranwrd(&namevar,"C389"x,"C9"x); *- large e acute -;
  &namevar=tranwrd(&namevar,"C38A"x,"CA"x); *- large e circumflex -;
  &namevar=tranwrd(&namevar,"C38B"x,"CB"x); *- large e diaeresis -;
  &namevar=tranwrd(&namevar,"C38C"x,"CC"x); *- large i grave -;
  &namevar=tranwrd(&namevar,"C38D"x,"CD"x); *- large i acute -;
  &namevar=tranwrd(&namevar,"C38E"x,"CE"x); *- large i circumflex -;
  &namevar=tranwrd(&namevar,"C38F"x,"CF"x); *- large i diaeresis -;
  &namevar=tranwrd(&namevar,"C390"x,"D0"x); *- large eth -;
  &namevar=tranwrd(&namevar,"C391"x,"D1"x); *- large n tilde -;
  &namevar=tranwrd(&namevar,"C392"x,"D2"x); *- large o grave -;
  &namevar=tranwrd(&namevar,"C393"x,"D3"x); *- large o acute -;
  &namevar=tranwrd(&namevar,"C394"x,"D4"x); *- large o circumflex -;
  &namevar=tranwrd(&namevar,"C395"x,"D5"x); *- large o tilde -;
  &namevar=tranwrd(&namevar,"C396"x,"D6"x); *- large o diaeresis -;
  &namevar=tranwrd(&namevar,"C398"x,"D8"x); *- large o stroke -;
  &namevar=tranwrd(&namevar,"C399"x,"D9"x); *- large u grave -;
  &namevar=tranwrd(&namevar,"C39A"x,"DA"x); *- large u acute -;
  &namevar=tranwrd(&namevar,"C39B"x,"DB"x); *- large u circumflex -;
  &namevar=tranwrd(&namevar,"C39C"x,"DC"x); *- large u diaeresis -;
  &namevar=tranwrd(&namevar,"C39D"x,"DD"x); *- large y acute -;
  &namevar=tranwrd(&namevar,"C39E"x,"DE"x); *- large thorn -;
  &namevar=tranwrd(&namevar,"C39F"x,"DF"x); *- sharp s -;
  &namevar=tranwrd(&namevar,"C3A1"x,"E1"x); *- small a acute -;
  &namevar=tranwrd(&namevar,"C3A2"x,"E2"x); *- small a circumflex -;
  &namevar=tranwrd(&namevar,"C3A3"x,"E3"x); *- small a tilde -;
  &namevar=tranwrd(&namevar,"C3A4"x,"E4"x); *- small a diaeresis -;
  &namevar=tranwrd(&namevar,"C3A5"x,"E5"x); *- small a ring -;
  &namevar=tranwrd(&namevar,"C3A6"x,"E6"x); *- small ae -;
  &namevar=tranwrd(&namevar,"C3A7"x,"E7"x); *- small c cedilla -;
  &namevar=tranwrd(&namevar,"C3A8"x,"E8"x); *- small e grave -;
  &namevar=tranwrd(&namevar,"C3A9"x,"E9"x); *- small e acute -;
  &namevar=tranwrd(&namevar,"C3AA"x,"EA"x); *- small e circumflex -;
  &namevar=tranwrd(&namevar,"C3AB"x,"EB"x); *- small e diaeresis -;
  &namevar=tranwrd(&namevar,"C3AC"x,"EC"x); *- small i grave -;
  &namevar=tranwrd(&namevar,"C3AD"x,"ED"x); *- small i acute -;
  &namevar=tranwrd(&namevar,"C3AE"x,"EE"x); *- small i circumflex -;
  &namevar=tranwrd(&namevar,"C3AF"x,"EF"x); *- small i diaeresis -;
  &namevar=tranwrd(&namevar,"C3B0"x,"F0"x); *- small eth -;
  &namevar=tranwrd(&namevar,"C3B1"x,"F1"x); *- small n tilde -;
  &namevar=tranwrd(&namevar,"C3B2"x,"F2"x); *- small o grave -;
  &namevar=tranwrd(&namevar,"C3B3"x,"F3"x); *- small o acute -;
  &namevar=tranwrd(&namevar,"C3B4"x,"F4"x); *- small o circumflex -;
  &namevar=tranwrd(&namevar,"C3B5"x,"F5"x); *- small o tilde -;
  &namevar=tranwrd(&namevar,"C3B6"x,"F6"x); *- small o diaeresis -;
  &namevar=tranwrd(&namevar,"C3B8"x,"F8"x); *- small o stroke -;
  &namevar=tranwrd(&namevar,"C3B9"x,"F9"x); *- small u grave -;
  &namevar=tranwrd(&namevar,"C3BA"x,"FA"x); *- small u acute -;
  &namevar=tranwrd(&namevar,"C3BB"x,"FB"x); *- small u circumflex -;
  &namevar=tranwrd(&namevar,"C3BC"x,"FC"x); *- small u diaeresis -;
  &namevar=tranwrd(&namevar,"C3BD"x,"FD"x); *- small y acute -;
  &namevar=tranwrd(&namevar,"C3BE"x,"FE"x); *- small thorn -;
  &namevar=tranwrd(&namevar,"C3BF"x,"FF"x); *- small y diaeresis -;
%mend fixnames;
/*<pre><b>
/ Program   : fixvars.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To "fix" variables in a library so they are consistent
/ SubMacros : none
/ Notes     : WARNING - USE OF THIS MACRO IN "WRITE" MODE COULD DAMAGE YOUR
/             DATASETS. YOU SHOULD BE VERY CAREFUL IN USING THIS MACRO.
/
/             This works in "read" mode and "write" mode. In "read" mode it
/             writes variable information to a flat file, highlighting any
/             inconsistencies. You can edit this file to remove these
/             inconsistencies. In "write" mode it will read this edited file
/             and apply the variable values to all the variables in the library.
/
/             YOU SHOULD BACK UP DATASETS BEFORE RUNNING THIS IN "WRITE" MODE
/             and carefully check that everything is correct before you delete
/             the backups.
/
/             Note that if you set a character variable length to a common
/             smaller length then you could be losing characters off the end of
/             the variable in some datasets.
/
/             You can not change a variable's name or type using this method.
/
/             Do not change the positioning of any fields in the flat file.
/
/             If a numeric variable has its format changed then an "F" might
/             appear in front of it. This is just a feature of "proc datasets"
/             and makes no difference and can be ignored.
/
/             Use the %clash macro if you need to know the source datasets of
/             some of the variables.
/
/             Variables will only be candidates for updating if the variable
/             name matches exactly (it is case sensitive) as does the variable
/             type.
/
/ Usage     : fixvars(mylib,w);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ libname           (pos) Library name.
/ mode              (pos) Whether in "read" or "write" mode. W or R will do.
/ flatfile="fixvars.txt"   Name of the flat file.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: fixvars v1.0;

%macro fixvars(libname,mode,flatfile="fixvars.txt");

  %local errflag err user;
  %let err=ERR%str(OR);
  %let errflag=0;

  %let user=%upcase(%sysfunc(getoption(user)));
  %if not %length(&user) %then %let user=WORK;

  %if not %length(&libname) %then %let libname=&user;
  %else %let libname=%upcase(%sysfunc(compress(&libname,%str(%'%"))));

  %if not %length(&flatfile) %then %do;
    %let errflag=1;
    %put &err: (fixvars) No flatfile name specified;
  %end;
  %else %let flatfile="%sysfunc(compress(&flatfile,%str(%'%")))";

  %if not %length(&mode) %then %let mode=read;
  %let mode=%sysfunc(compress(&mode,%str(%'%")));
  %let mode=%upcase(%substr(&mode,1,1));

  %if %sysfunc(verify(&mode,RW)) %then %do;
    %let errflag=1;
    %put &err: (fixvars) Second positional "mode" parameter must be either R(ead) or W(rite);
  %end;

  %if &errflag %then %goto exit;



  %if "&mode" EQ "R" %then %do;

    /*----------------------------------------*
                    READ MODE
     *----------------------------------------*/

    *- get existing information about dataset variables -;
    proc sql noprint;
      create table _fixvars as
      select name, type, length, format, label from dictionary.columns
      where libname="&libname" and memtype='DATA';
    quit;

    *- get rid of duplicates -;
    proc sort nodupkey data=_fixvars;
      by name type length format label;
    run;

    *- write to flat file alerting where there is more than one entry per variable -;
    data _null_;
      file &flatfile;
      set _fixvars;
      by name;
      if not (first.name and last.name) then put @1 '+' @;
      put @3 name @36 type @41 length @45 format @62 label;
    run;

    *- tidy up -;
    proc datasets nolist;
      delete _fixvars;
    run;
    quit;

  %end;


  %else %if "&mode" EQ "W" %then %do;

    /*----------------------------------------*
                     WRITE MODE
     *----------------------------------------*/

    *- get existing information about dataset variables -;
    proc sql noprint;
      create table _fixvarsold as
      select name, type, memname, length as oldlength, format as oldformat, label as oldlabel
      from dictionary.columns
      where libname="&libname" and memtype='DATA'
      order by name, type;
    quit;

    *- read in the flat file containing corrected variable information -;
    data _fixvars;
      length name $ 32 type $ 4 length 8 format $ 16 label $ 256 newlabel $ 266;
      infile &flatfile;
      input;
      if _infile_ NE ' ' then do;
        name=substr(_infile_,3,32);
        type=substr(_infile_,36,4);
        if length(_infile_) GT 42 then length=input(substr(_infile_,41,3),3.);
        else length=input(substr(_infile_,41),3.);
        format=' ';
        if length(_infile_) GT 44 then do;
          if length(_infile_) GT 61 then format=substr(_infile_,45,16);
          else format=substr(_infile_,45);
        end;
        label=' ';
        if length(_infile_) GT 61 then label=substr(_infile_,62);
        *- replace single double quotes in label with double double quotes since -;
        *- we will be enclosing the label in double quotes when in proc datasets -;
        newlabel=tranwrd(label,'"','""');
        if name EQ ' ' then do;
          call symput('errflag','1');
          put '&err: (fixvars) Variable name missing in flat file';
        end;
        if type not in ('char' 'num') then do;
          call symput('errflag','1');
          put '&err: (fixvars) Type of "' type +(-1) '" not recognised in flat file for variable "' name +(-1) '"';
        end;
        if length EQ . then do;
          call symput('errflag','1');
          put '&err: (fixvars) Variable length not recognised in flat file for variable "' name +(-1) '"';
        end;
        output;
      end;
    run;
  
    *- sort just in case the order was changed -;
    proc sort data=_fixvars;
      by name type length format label;
    run;

    *- ensure there are no duplicates in this corrected list -;
    data _null_;
      set _fixvars;
      by name type;
      if not (first.type and last.type) then do;
        if first.type then do;
          put '&err: (fixvars) You have a duplicate entry for variable "' 
              name +(-1) '" type "' type +(-1) '"';
          call symput('errflag','1');
        end;
      end;
    run;

    *- if a duplicate was found then exit after tidying up -;
    %if &errflag %then %do;
      proc datasets nolist;
        delete _fixvarsold;
      run;
      quit;

      %goto exit;
    %end;

    *- merge corected and old variable information together -;
    data _fixvars;
      merge _fixvars(in=_fix) _fixvarsold(in=_old);
      by name type;
      if _fix and _old;
    run;


    /*----------------------------------------*
                    Fix labels
     *----------------------------------------*/

    *- sort into dataset name order for labels that need changing -;
    proc sort data=_fixvars(where=(label NE oldlabel)) out=_fixlabel;
      by memname name;
    run;

    *- generate "proc datasets" code to fix the labels -;
    data _null_;
      set _fixlabel;
      by memname;
      if _n_=1 then call execute("proc datasets nolist lib=&libname;");
      if first.memname then call execute('modify '||trim(memname)||'; label ');
      call execute(trim(name)||'="'||trim(newlabel)||'" ');
      if last.memname then call execute(';run;');
    run;


    /*----------------------------------------*
                    Fix formats
     *----------------------------------------*/

    *- Sort into dataset name order for formats that need changing. -;
    *- Missing formats must be last so that they are nullified.     -;
    proc sort data=_fixvars(where=(format NE oldformat)) out=_fixformat;
      by memname descending format;
    run;

    *- generate "proc datasets" code to fix the formats -;
    data _null_;
      set _fixformat;
      by memname;
      if _n_=1 then call execute("proc datasets nolist lib=&libname;");
      if first.memname then call execute('modify '||trim(memname)||'; format ');
      call execute(trim(name)||' '||trim(format)||' ');
      if last.memname then call execute(';run;');
    run;


    /*----------------------------------------*
                    Fix lengths
     *----------------------------------------*/

    *- sort into dataset name order for lengths that need changing -;
    proc sort data=_fixvars(where=(length NE oldlength)) out=_fixlength;
      by memname name;
    run;

    *- generate the data step code to fix the lengths -;
    data _null_;
      length dollar $ 1;
      set _fixlength;
      by memname;    
      if type='char' then dollar='$';
      else dollar=' ';
      if first.memname then call execute("data &libname.."||trim(memname)||';length ');
      call execute(trim(name)||' '||dollar||' '||put(length,3.)||' ');
      if last.memname then call execute(";set &libname.."||trim(memname)||';run;');
    run;


    *- tidy up -;
    proc datasets nolist;
      delete _fixvars _fixvarsold _fixlabel _fixformat _fixlength;
    run;
    quit;

  %end;


  %goto skip;
  %exit: %put &err: (fixvars) Leaving macro due to problem(s) listed;
  %skip:

%mend fixvars;
  /*<pre><b>
/ Program   : flatten.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To "flatten" data so there is only one observation per "by group"
/ SubMacros : %words %varnum
/ Notes     : This calls proc transpose repeatedly for each variable you specify.
/             You must have sorted on what you define to the bygroup= parameter
/             plus any other variables required to put the data in the correct
/             sorted order. Typically, you will have sorted by the bygroup=
/             variables plus date or time (or both) variables. A variable is
/             added that contains the count of the number of observations in
/             each by group. Variables will be given the suffix 1, 2, etc.
/ Usage     : %flatten(dsin=test,bygroup=by1 by2,vars=str num)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsin=             Input dataset
/ vars=             Variables you want transposing
/ dsout=            Output dataset
/ bygroup=          The "by group" variables
/ nobs=nobs         Name of the variable to contain the number of observation
/                   per "by group"
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  25Jun03         Make nobs= a mandatory parameter and write highest value
/                      out to global macro variable _maxn_. Now version 2
/ rrb  13Feb07         "macro called" message added
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: flatten v2.0;

%macro flatten(dsin=,
               vars=,
              dsout=,
            bygroup=,
               nobs=nobs
              );

  %local errflag i var err;
  %let err=ERR%str(OR);
  %let errflag=0;

  %global _maxn_;
  %let _maxn_=0;


         /*-----------------------------------------*
             Check we have enough parameters set
          *-----------------------------------------*/

  %if not %length(&dsin) %then %do;
    %let errflag=1;
    %put &err: (flatten) No input dataset defined to dsin=;
  %end;

  %if not %length(&vars) %then %do;
    %let errflag=1;
    %put &err: (flatten) No transpose variables defined to vars=;
  %end;

  %if not %length(&bygroup) %then %do;
    %let errflag=1;
    %put &err: (flatten) No by group variables defined to bygroup=;
  %end;

  %if &errflag %then %goto exit;

  %if not %length(&dsout) %then %let dsout=%scan(&dsin,1,%str(%());

  %if not %length(&nobs) %then %let nobs=nobs;



         /*-----------------------------------------*
                  Start processing the data
          *-----------------------------------------*/

  data _flatten;
    set &dsin;
    keep &bygroup &vars;
  run;



         /*-----------------------------------------*
                   Add the observation count
          *-----------------------------------------*/

  proc summary nway missing data=_flatten;
    class &bygroup;
    output out=_flatnobs(drop=_type_ rename=(_freq_=&nobs));
  run;

  proc summary nway data=_flatnobs;
    id &nobs;
    output out=_flatn(drop=_type_ _freq_);
  run;

  data _null_;
    set _flatn;
    call symput('_maxn_',compress(put(&nobs,13.)));
  run;

  data _flatten;
    merge _flatnobs _flatten;
    by &bygroup;
  run;



         /*-----------------------------------------*
               Transpose each variable in turn
          *-----------------------------------------*/

  %do i=1 %to %words(&vars);

    %let var=%scan(&vars,&i,%str( ));

    proc transpose data=_flatten prefix=&var
                   out=_flatten&i(drop=_name_);
      by &bygroup &nobs;
      var &var;
    run;

  %end;



         /*-----------------------------------------*
                  Create final output dataset
          *-----------------------------------------*/

  data _flatout;
    merge
    %do i=1 %to %words(&vars);
      _flatten&i
    %end;
    ;
    by &bygroup;
  run;

  data &dsout;
    set _flatout;
    %if %varnum(_flatout,_label_) %then %do;
      drop _label_;
    %end;
  run;


         /*-----------------------------------------*
                        Tidy up and exit
          *-----------------------------------------*/

  proc datasets nolist;
    delete _flat:
    ;
  run;
  quit;


  %goto skip;
  %exit: %put &err: (flatten) Leaving macro due to problem(s) listed;
  %skip:
%mend flatten;
/*<pre><b>
/ Program      : fmtord.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : To create a numeric informat that maps a format label to its
/                order position.
/ SubMacros    : %words %fmtpath %verifyb
/ Notes        : The informat will be called fmtord. by default.
/ Usage        : %fmtord(agernge);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ format            (pos) format name to create informat from
/ infmtname=fmtord  Name of the informat created. Do not end with a period.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: fmtord v1.0;

%macro fmtord(format,infmtname=fmtord);

  %local ext i cat catlist gotit err fmtname;
  %let err=ERR%str(OR);

  %*- drop the "." ending and any numbers immediately preceding it -;
  %let fmtname=%upcase(%substr(&format,1,%verifyb(&format,0123456789.)));
  %let format=&fmtname;

  %let ext=FORMAT;
  %if "%substr(&fmtname,1,1)" EQ "$" %then %do;
    %let ext=FORMATC;
    %let fmtname=%substr(&fmtname,2);
  %end;

  %let catlist=%fmtpath;

  %let gotit=0;
  %do i=1 %to %words(&catlist);
    %let cat=%scan(&catlist,&i,%str( ));
    %if %sysfunc(cexist(&cat..&fmtname..&ext)) %then %do;
      %let gotit=1;
      proc format lib=&cat cntlout=_fmtord;
        select &format;
      run;
      quit;
      data _fmtord;
        length label $ 6;
        retain fmtname "&infmtname" type 'I';
        set _fmtord(keep=label rename=(label=start));
        label=left(put(_n_,6.));
      run;
      proc format cntlin=_fmtord;
      run;
      proc datasets nolist;
        delete _fmtord;
      run;
      quit;
      %let i=99;
    %end;
  %end;

  %if not &gotit %then %put &err: (fmtord) Format "&format" not found;

%mend fmtord;
/*<pre><b>
/ Program      : fmtpath.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 13-Apr-2011
/ Purpose      : Function-style macro to get the full fmtsearch path
/ SubMacros    : %words
/ Notes        : All single-named catalogs will be completed with .FORMATS
/                and WORK.FORMATS and LIBRARY.FORMATS will be added if missing.
/                This macro will not check whether the catalogs actually exist.
/                It just prepares the list for later processing and it is at
/                that later stage that the existence of the catalogs must be
/                checked.
/ Usage        : %let path=%fmtpath;
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ N/A
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  22Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  13Apr11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: fmtpath v1.0;

%macro fmtpath;

  %local i cat cats catlist;

  %let cats=%sysfunc(compress(%sysfunc(getoption(fmtsearch)),%(%)));
  %let cats=%sysfunc(translate(%quote(&cats),%str( ),%str(,)));

  %do i=1 %to %words(&cats);
    %let cat=%qscan(&cats,&i,%str( ));
    %if not %index(&cat,.) %then %let cat=&cat..FORMATS;
    %let catlist=&catlist &cat;
  %end;

  %if not %index(&catlist,LIBRARY.FORMATS) %then %let catlist=LIBRARY.FORMATS &catlist;
  %if not %index(&catlist,WORK.FORMATS) %then %let catlist=WORK.FORMATS &catlist;

&catlist
%mend fmtpath;

/*<pre><b>
/ Program   : fmts2fda.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To create sas code to generate formats as found in your data
/ SubMacros : %quotelst
/ Notes     : The FDA sometimes requests the user-defined formats you are using
/             in your datasets. You can either send them the full format catalog
/             members or use this utility so that the formats can be generated.
/             This will only give you the codes and their formatted values as it
/             occurs in your data. It will NOT give all codes defined to the
/             formats. If you want all possible codes mapped then send them the
/             format catalogs and do not use this utility.
/
/             Note that this utility is weak on numeric formats. These can be
/             very long lists of values. You should just use this to identify
/             what numeric formats are being used and replace the generated code
/             with the original code for the numeric format.
/
/ Usage     : %fmts2fda(mylib1 mylib2)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ libname           (pos) Libref of the library where your datasets are stored.
/                   More than one can be specified (separated by spaces).
/ file=fdaformats.sas    Name of the flat file that will hold the formats code
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: fmts2fda v1.0;

%macro fmts2fda(libname,file=fdaformats.sas);

  %local wrn;
  %let wrn=WAR%str(NING);

  %if NOT %length(&libname) %then %let libname=%sysfunc(getoption(user));
  %if NOT %length(&libname) %then %let libname=work;


  *- find all datasets and variables in the library that have -;
  *- user-defined formats and output to a dataset -;
  proc sql noprint;
    create table _fmts as
    select libname, memname, name, type, format
    from dictionary.columns
    where libname in (%quotelst(%upcase(&libname)))
    and memtype='DATA'
    and compress(format,'F$0123456789.') 
      not in (' ' 'DATE' 'TIME' 'DATETIME' 'CHAR' 'BEST' 'Z');
  quit;


  %*- warn if no user formats and exit -;
  %if NOT %nobs(_fmts) %then %do;
    %put &wrn: (fmts2fda) No user-defined formats are used in library=&libname;
    data _null_;
      file "&file";
      put "No user-defined formats are used in library=&libname";
    run;
    %goto skip;
  %end;


  *- delete base dataset if it already exists -;
  %if %sysfunc(exist(_fmtbase)) %then %do;
    proc datasets nolist;
      delete _fmtbase;
    run;
    quit;
  %end;


  *- for each dataset, sort nodupkey, add the format name and type, -;
  *- assign the variable contents to variable "start" and append on -;
  *- to the base dataset. -;
  data _null_;
    set _fmts;
    call execute('proc sort nodupkey data='||trim(libname)||'.'||trim(memname)||'(keep='||
      trim(name)||') out=_fmtbit;by '||trim(name)||';run;');
    call execute('data _fmtbit;length type $ 4 format start $ 20;retain format "'||
      trim(format)||'" type "'||type||'";set _fmtbit;');
    if type='char' then call execute('start='||trim(name)||';drop '||trim(name)||';run;');
    else call execute('start=trim(left(put('||trim(name)||',best16.)));drop '||trim(name)||';run;');
    call execute('proc append base=_fmtbase data=_fmtbit;run;');
  run;


  *- get rid of duplicates from the base dataset -;
  proc sort nodupkey data=_fmtbase;
    by format type start;
  run;


  *- write the "proc format" code out to the flat file -;
  data _null_;
    length fmt $ 20 label $ 40;
    file "&file" noprint notitles;
    set _fmtbase end=last;
    by format;
    if _n_=1 then put 'proc format;';
    fmt=compress(format,'.');
    if first.format then put @3 'value ' fmt;
    if type='char' then do;
      label=putc(start,format);
      put @5 '"' start +(-1) '"="' label +(-1) '"';
    end;
    else do;
      label=putn(input(start,best16.),format);
      put @5 start +(-1) '="' label +(-1) '"';
    end;
    if last.format then put @3 ';';
    if last then put 'run;';
  run;


  *- tidy up -;
  proc datasets nolist;
    delete _fmts _fmtbase _fmtbit;
  run;
  quit;

  %skip:

%mend fmts2fda;
/*<pre><b>
/ Program      : getfmts.sas
/ Version      : 3.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-Jul-2013
/ Purpose      : To get details of a list of user formats defined in a dataset
/ SubMacros    : %words %fmtpath %nobs %getvalue %varnum
/ Notes        : The dataset produced will be the usual style created by proc
/                format cntlout. The format catalogs are searched in the order
/                defined to fmtsearch. 
/
/                Formats that can not be found are written to the global macro
/                variable _badfmts_ and reported in the log. If none of the
/                formats can be found then an error message is written to the
/                log.
/
/                You should make sure your input dataset contains a unique list
/                of user-only formats. You can get this with a "proc contents"
/                and drop format names of " " "$" "DATE" "TIME" "DATETIME"
/                "BEST" and perhaps some more and sort NODUPKEY on "format".
/
/                You can use the libref= parameter to automatically give you a
/                dataset of unique user formats named "_getcont" that the macro
/                will use internally. This dataset will not be deleted so that
/                you can inspect it for possible problems. You can then edit it
/                if need be and use it as input to this macro in a second run.
/
/                The output dataset is in a format that can be used directly by
/                "proc format" as a cntlin= dataset to create formats. If you
/                are sending data offsite then this is a convenient way to
/                supply the formats that go with the datasets you are sending.
/                The receiver of this dataset can recreate the formats by
/                running this simple code:
/                       proc format cntlin=_getfmts;
/                       run;
/
/ Usage        : %getfmts(dsin=fmtlist,fmtvar=format,dsout=allfmts);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ libref            Use this as an alternative to dsin= and fmtvar= and it will
/                   run proc contents to create a dataset that is a unique list
/                   of user formats as input. Note that this is done for _all_
/                   datasets in the library.
/ dsin              One or two part dataset name containing a unique list of
/                   user formats.
/ fmtvar            Name of the variable in the input dataset containing the
/                   format name (character formats should start with a "$")
/ dsout=_getfmts    Name of the dataset to contain all the format information
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13May11         libref= parameter added (v2.0)
/ rrb  15Sep12         Call to %getvalue simplified for new version (v2.1)
/ rrb  04Jul13         Check for input dataset view as well as dataset and
/                      improved instructions in the header regarding use of the
/                      library parameter. Format names in the dsin= dataset
/                      get the ending period and numbers dropped and not in the
/                      macro code for greater efficiency. Duplicate format names
/                      are dropped. Major changes hence (v3.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: getfmts v3.0;

%macro getfmts(dsin=,
               libref=,
               fmtvar=,
               dsout=_getfmts,
               debug=no
              );

  %local i j ext cat catlist gotit err errflag 
         format fmtname first done savopts;
  %let err=ERR%STR(OR);
  %let errflag=0;

  *-- first time through flag --;
  %let first=1;

  *-- to store list of unresolved formats --;
  %global _badfmts_;
  %let _badfmts_=;

  %if NOT %length(&debug) %then %let debug=no;
  %let debug=%upcase(%substr(&debug,1,1));

  %let savopts=%sysfunc(getoption(notes));

  %if &debug NE Y %then %do;
    options nonotes;
  %end;


  /***********************************
           libref handling
   ***********************************/

  %if %length(&libref) %then %do;
    proc contents noprint data=&libref.._all_ out=_getcont(keep=format);
    run;
    proc sort nodupkey 
       data=_getcont(where=(format not in (" " "$" "DATE" "TIME" "DATETIME" "BEST")))
       out=_getcont;
      by format;
    run;
    %let dsin=_getcont;
    %let fmtvar=format;
  %end;


  /***********************************
      Check the parameter settings
   ***********************************/

  %else %do;

    %if NOT %length(&dsout) %then %let dsout=_getfmts;

    %if NOT %length(&dsin) %then %do;
      %let errflag=1;
      %put &err: (getfmts) No input dataset assigned to dsin=;
    %end;
    %else %do;
      %if NOT %sysfunc(exist(&dsin)) 
       and NOT %sysfunc(exist(&dsin,VIEW)) %then %do;
        %let errflag=1;
        %put &err: (getfmts) Dataset or view dsin=&dsin does not exist;
      %end;
      %else %do;
        %if NOT %varnum(&dsin,&fmtvar) %then %do;
          %let errflag=1;
          %put &err: (getfmts) Variable fmtvar=&fmtvar does not exist in dataset dsin=&dsin;
        %end;
        %else %do;
          data _getcont(keep=&fmtvar);
            set &dsin;
            if &fmtvar=" " then delete;
            &fmtvar=upcase(prxchange('s\d*\.\s*$',1,&fmtvar));
            if &fmtvar in (" " "$" "DATE" "TIME" "DATETIME" "BEST") then delete;
          run;
          proc sort nodupkey data=_getcont;
            by &fmtvar;
          run;
          %let dsin=_getcont;
        %end;
      %end;
    %end;

  %end;

  %if &errflag %then %GOTO exit;


  /*********************************************
     Store the format search path catalog list
   *********************************************/

  %let catlist=%fmtpath;


  /*********************************************
        Loop through the formats dataset
   *********************************************/

  %do i=1 %TO %nobs(&dsin);

    *-- get the next format name from the input dataset --;
    %let format=%getvalue(&dsin,&fmtvar,&i);

    %put NOTE: (getfmts) Working on format &format;

    %let ext=FORMAT;
    %let fmtname=&format;

    %if "%substr(&format,1,1)" EQ "$" %then %do;
      %let ext=FORMATC;
      %let fmtname=%substr(&format,2);
    %end;

    /***********************************
        Loop through the catalog list
     ***********************************/

    %let gotit=0;
    %do j=1 %TO %words(&catlist);
      %let cat=%scan(&catlist,&j,%STR( ));
      %if %sysfunc(cexist(&cat..&fmtname..&ext)) %then %do;
        %let gotit=1;
        %let done=&done &format;
        proc format lib=&cat cntlout=_fmtemp;
          select &format;
        run;
        quit;

        /*****************************************
            Enforce consistent variable lengths
         *****************************************/

        data _fmtemp2;
          length start end $ 50 label $ 148;
          set _fmtemp(rename=(start=start_x end=end_x label=label_x));
          start=left(start_x);
          end=left(end_x);
          label=left(label_x);
          drop start_x end_x label_x;
          label start="Starting value for format"
                  end="Ending value for format"
                label="Format value label"
                ;
        run;

          /**********************
              Append the data
           **********************/

        %if &first EQ 1 %then %do;
          data &dsout;
            set _fmtemp2;
          run;
          %let first=0;
        %end;
        %else %do;
          proc append base=&dsout data=_fmtemp2;
          run;
        %end;

          /**********************
                  Tidy up
           **********************/
        proc datasets nolist;
          delete _fmtemp _fmtemp2;
        run;
        quit;

          /**********************
               Leave the loop
           **********************/
        %let j=99;
      %end;
    %end;

    %if NOT &gotit %then %let _badfmts_=&_badfmts_ &format;

  %end;

  %if "&dsin" EQ "_getcont" %then %do;
    proc datasets nolist;
      delete _getcont;
    quit;
  %end;

  options notes;

  %put NOTE: (getfmts) The following format search path was assumed:;
  %put NOTE: (getfmts) &catlist;
  %put;

  %if NOT %length(&done) %then %do;
    %put &err: (getfmts) None of the formats could be found on the format search path;
    %put &err: (getfmts) and the list is stored in the global macro variable _badfmts_ :;
    %put &err: (getfmts) &_badfmts_;
    %goto exit;
  %end;
  %else %do;
    %put NOTE: (getfmts) The following formats were found and processed and the;
    %put NOTE: (getfmts) format information was written to the dataset &dsout :;
    %if NOT %length(&_badfmts_) %then
      %put NOTE: (getfmts) (All the specified formats were found);
    %put NOTE: (getfmts) &done;
  %end;

  %if %length(&_badfmts_) %then %do;
    %put;
    %put NOTE: (getfmts) The following formats could not be found on the format search path;
    %put NOTE: (getfmts) and the list is stored in the global macro variable _badfmts_ :;
    %put NOTE: (getfmts) &_badfmts_;
  %end;

  options &savopts;

  %goto skip;
  %exit: %put &err: (getfmts) Leaving macro due to problem(s) listed;
  %skip:

%mend getfmts;
/*<pre><b>
/ Program   : gettitles.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 19-Sep-2011
/ Purpose   : To read the title lines of an LST file and write them to a global
/             macro variable _titles_ .
/ SubMacros : none
/ Notes     : This macro reads up to ten lines of an LST file or up to a blank
/             line and writes the result to the global macro variable _titles_ .
/             Multiple title lines will be joined into a single line.
/
/             The purpose of this macro is to allow you to check the titles
/             against those defined in another source to ensure no changes have
/             been made or that any differences are acceptable.
/
/             If the file does not exist then _titles_ will be given the value
/             DNE. If the file is empty then _titles_ will be set to EMPTY. If
/             an error message is issued then _titles_ will be null (i.e. blank)
/             (the %scanfile macro works the same way).
/
/             Since the text written to _titles_ might exceed 262 characters
/             then if you wish to retrieve its contents in a later data step you
/             should use symget("_titles_") rather than resolve "&_titles_" to
/             avoid a syntax error.
/
/             The logic that determines when the titles have stopped will vary
/             with your site standards. The coded solution below is only a
/             suggested solution. You are free to change the code to suit your
/             site standards.
/
/ Usage     : %gettitles(C:\temp\myfile.lst)
/
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ file              (pos) Full file path of file you wish to search (quoted or
/                   unquoted).
/ compbl=yes        By default, compress the titles for multiple blanks
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  19Sep11         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: gettitles v1.0;

%macro gettitles(file,compbl=yes);

  %local err errflag savopts;
  %let savopts=%sysfunc(getoption(notes));

  options nonotes;

  %let err=ERR%str(OR);
  %let errflag=0;

  %global _titles_;
  %let _titles_=;


  %if not %length(&file) %then %do;
    %let errflag=1;
    %put &err: (gettitles) No file specified;
  %end;
  %else %do;
    %let file=%sysfunc(dequote(&file));
    %if not %sysfunc(fileexist(&file)) %then %do;
      %let _titles_=DNE;
      %goto skip;
    %end;
  %end;


  %if &errflag %then %goto exit;


  %if not %length(&compbl) %then %let compbl=yes;
  %let compbl=%upcase(%substr(&compbl,1,1));


  data _null_;
    length keeptitles $ 2000;
    retain keeptitles " " i 0;
    infile "&file" eof=eof;
    input;
    i=i+1;
    *- what logic you put here will depend on your site standards -;
    if i>10 then goto eof;
    else if _infile_ EQ " " then goto eof;
    else if _n_>1 and substr(_infile_,1,1) NE " " then goto eof;
    else do;
      %if &compbl EQ N %then %do;
        if keeptitles EQ " " then keeptitles=trim(left(_infile_));
        else keeptitles = trim(keeptitles)||" "||trim(left(_infile_));
      %end;
      %else %do;
        if keeptitles EQ " " then keeptitles=compbl(trim(left(_infile_)));
        else keeptitles = trim(keeptitles)||" "||compbl(trim(left(_infile_)));
      %end;
    end;
  return;
  eof:
    if _n_=1 and _infile_=" " then call symput('_titles_',"EMPTY");
    else call symput('_titles_',trim(keeptitles));
    stop;
  return;
  run;

  %goto skip;
  %exit: %put &err: (gettitles) Leaving macro due to problem(s) listed;
  %skip:

  options &savopts;

%mend gettitles;
/*<pre><b>
/ Program   : getvalue.sas
/ Version   : 1.2
/ Author    : Roland Rashleigh-Berry
/ Date      : 15-Sep-2012
/ Purpose   : Function-style macro to return a variable's value
/ SubMacros : none
/ Notes     : Use the macro %getvalueq if you want character strings returned
/             in double quotes by default.
/ Usage     : %let value=%getvalue(dsname,varname,1);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name (pos)
/ var               Variable name (pos)
/ obs               Observation number (pos). Defaults to 1.
/ usequotes=no      By default, do not put character string in double quotes.
/                   Set to "yes" (no quotes) to return characters quoted or use
/                   the %getvalueq macro which by default quotes strings.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  29Aug10         usequotes= parameter added
/ rrb  20Jan11         Code layout tidy
/ rrb  05May11         Code tidy
/ rrb  15Sep12         Default changed to usequotes=no (v1.2)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: getvalue v1.2;

%macro getvalue(ds,var,obs,usequotes=no);

  %local dsid rc varnum value err;
  %let err=ERR%str(OR);

  %if not %length(&usequotes) %then %let usequotes=no;
  %let usequotes=%upcase(%substr(&usequotes,1,1));

  %if not %length(&obs) %then %let obs=1;


  %let dsid=%sysfunc(open(&ds,is));
  %if &dsid EQ 0 %then %do;
    %put &err: (getvalue) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let varnum=%sysfunc(varnum(&dsid,&var));
    %if &varnum LT 1 %then %put &err: (getvalue) Variable &var not in dataset &ds;
    %else %do;
      %let rc=%sysfunc(fetchobs(&dsid,&obs));
      %if &rc = -1 %then %put &err: (getvalue) Observation &obs is beyond dataset end;
      %else %do;
        %if "%sysfunc(vartype(&dsid,&varnum))" EQ "C" %then %do;
          %let value=%sysfunc(getvarc(&dsid,&varnum));
          %if "&usequotes" EQ "N" %then %do;
&value
          %end;
          %else %do;
"&value"
          %end;
        %end;
        %else %do;
          %let value=%sysfunc(getvarn(&dsid,&varnum));
&value
        %end;
      %end;
    %end;
    %let rc=%sysfunc(close(&dsid));
  %end;

%mend getvalue;
/*<pre><b>
/ Program   : getvaluems.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 29-Jan-2014
/ Purpose   : Function-style macro to return a variable's value or a single
/             quoted space if a character value is missing.
/ SubMacros : none
/ Notes     : Use the macro %getvalueq if you want character strings returned
/             in double quotes by default.
/ Usage     : %let value=%getvaluems(dsname,varname,1);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name (pos)
/ var               Variable name (pos)
/ obs               Observation number (pos). Defaults to 1.
/ usequotes=no      By default, do not put character string in double quotes.
/                   Set to "yes" (no quotes) to return characters quoted or use
/                   the %getvalueq macro which by default quotes strings.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Jan14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: getvaluems v1.0;

%macro getvaluems(ds,var,obs,usequotes=no);

  %local dsid rc varnum value err;
  %let err=ERR%str(OR);

  %if not %length(&usequotes) %then %let usequotes=no;
  %let usequotes=%upcase(%substr(&usequotes,1,1));

  %if not %length(&obs) %then %let obs=1;


  %let dsid=%sysfunc(open(&ds,is));
  %if &dsid EQ 0 %then %do;
    %put &err: (getvalue) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let varnum=%sysfunc(varnum(&dsid,&var));
    %if &varnum LT 1 %then %put &err: (getvalue) Variable &var not in dataset &ds;
    %else %do;
      %let rc=%sysfunc(fetchobs(&dsid,&obs));
      %if &rc = -1 %then %put &err: (getvalue) Observation &obs is beyond dataset end;
      %else %do;
        %if "%sysfunc(vartype(&dsid,&varnum))" EQ "C" %then %do;
          %let value=%sysfunc(getvarc(&dsid,&varnum));
          %if not %length(%superq(value)) %then %do;
' '
          %end;
          %else %do;
            %if "&usequotes" EQ "N" %then %do;
&value
            %end;
            %else %do;
"&value"
            %end;
          %end;
        %end;
        %else %do;
          %let value=%sysfunc(getvarn(&dsid,&varnum));
&value
        %end;
      %end;
    %end;
    %let rc=%sysfunc(close(&dsid));
  %end;

%mend getvaluems;
/*<pre><b>
/ Program   : getvalueq.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 15-Sep-2012
/ Purpose   : Function-style macro to return a variable's value
/ SubMacros : none
/ Notes     : By default, character strings are returned in double quotes.
/             Use the macro %getvalue if you do not want character strings
/             returned in double quotes by default.
/ Usage     : %let value=%getvalueq(dsname,varname,1);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name (pos)
/ var               Variable name (pos)
/ obs               Observation number (pos). Defaults to 1.
/ usequotes=yes     By default, put character string in double quotes. Use the
/                   %getvalue macro if you do not want strings to be quoted.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  15Sep12         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: getvalueq v1.0;

%macro getvalueq(ds,var,obs,usequotes=yes);

  %local dsid rc varnum value err;
  %let err=ERR%str(OR);

  %if not %length(&usequotes) %then %let usequotes=yes;
  %let usequotes=%upcase(%substr(&usequotes,1,1));

  %if not %length(&obs) %then %let obs=1;


  %let dsid=%sysfunc(open(&ds,is));
  %if &dsid EQ 0 %then %do;
    %put &err: (getvalue) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let varnum=%sysfunc(varnum(&dsid,&var));
    %if &varnum LT 1 %then %put &err: (getvalue) Variable &var not in dataset &ds;
    %else %do;
      %let rc=%sysfunc(fetchobs(&dsid,&obs));
      %if &rc = -1 %then %put &err: (getvalue) Observation &obs is beyond dataset end;
      %else %do;
        %if "%sysfunc(vartype(&dsid,&varnum))" EQ "C" %then %do;
          %let value=%sysfunc(getvarc(&dsid,&varnum));
          %if "&usequotes" EQ "N" %then %do;
&value
          %end;
          %else %do;
"&value"
          %end;
        %end;
        %else %do;
          %let value=%sysfunc(getvarn(&dsid,&varnum));
&value
        %end;
      %end;
    %end;
    %let rc=%sysfunc(close(&dsid));
  %end;

%mend getvalueq;
/*<pre><b>
/ Program   : globexist.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return true if all the global macro
/             variables listed exist.
/ SubMacros : %match %globlist
/ Notes     : Non-matching global macro variable names will be returned in the 
/             global macro variable _nomatch_ .
/ Usage     : %if %globexist(globvar) %then %do ....
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ globvars          (pos) List of global macro variables
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: globexist v1.0;

%macro globexist(globvars);
  %local globmatch;
  %let globmatch=%match(%globlist,%upcase(&globvars));
  %if NOT %length(&_nomatch_) %then 1;
  %else 0;
%mend globexist;



  /*<pre><b>
/ Program   : globlist.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return a list of current global macro
/             variable names.
/ SubMacros : %mvarlist
/ Notes     : All global macro variable names will be in uppercase.
/ Usage     : %let glist=%globlist;
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ N/A
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  10Jun09         Changed to a shell macro that calls %mvarlist for v2.0
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: globlist v2.0;

%macro globlist;
%mvarlist
%mend globlist;
/*<pre><b>
/ Program   : hasvars.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return true if a dataset has all the
/             variables defined to a list.
/ SubMacros : %match %varlist
/ Notes     : Non-matching variables will be returned in the global macro
/             variable _nomatch_ .
/ Usage     : %if not %hasvars(dsname,aa bb cc) %then %do ....
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset
/ varlist           (pos) Space-delimited list of variables to check
/ casesens=no       By default, case is not important
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  19Mar07         Macro called message added plus header tidy
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: hasvars v1.1;

%macro hasvars(ds,varlist,casesens=no);
  %local varmatch;
  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));

  %let varmatch=%match(%varlist(&ds),&varlist,casesens=&casesens);

  %if not %length(&_nomatch_) %then 1;
  %else 0;
%mend hasvars;



  /*<pre><b>
/ Program   : hasvarsc.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 21-Jun-2013
/ Purpose   : Function-style to return true if a dataset has all the character
/             variables defined to a list.
/ SubMacros : %match %varlistc
/ Notes     : Non-matching variables will be returned in the global macro
/             variable _nomatch_ .
/ Usage     : %if not %hasvarsc(dsname,aa bb cc) %then %do ....
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset
/ varlist           (pos) Space-delimited list of variables to check
/ casesens=no       By default, case is not important
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  19Mar07         Macro called message added plus header tidy
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/ rrb  21Jun13         Diagnostics added for when there are no character
/                      variables in the input dataset (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: hasvarsc v2.0;

%macro hasvarsc(ds,varlist,casesens=no);
  %local varmatch varlistc;
  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));
  %let varlistc=%varlistc(&ds);
  %if not %length(&varlistc) %then %do;
%put NOTE: (hasvarsc) There are no character variables in the input dataset therefore;
%put NOTE: (hasvarsc) the character variable(s) you are testing for will not be found.;
    %let varmatch=%match(,&varlist,casesens=&casesens);
0
  %end;
  %else %do;
    %let varmatch=%match(&varlistc,&varlist,casesens=&casesens);
    %if not %length(&_nomatch_) %then 1;
    %else 0;
  %end;
%mend hasvarsc;
/*<pre><b>
/ Program   : hasvarsn.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 21-Jun-2013
/ Purpose   : Function-style macro to return true if a dataset has all the
/             numeric variables defined to a list.
/ SubMacros : %match %varlistn
/ Notes     : Non-matching variables will be returned in the global macro
/             variable _nomatch_ .
/ Usage     : %if not %hasvarsn(dsname,aa bb cc) %then %do ....
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset
/ varlist           (pos) Space-delimited list of variables to check
/ casesens=no       By default, case is not important
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  19Mar07         Macro called message added plus header tidy
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/ rrb  21Jun13         Diagnostics added for when there are no numeric
/                      variables in the input dataset (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: hasvarsn v2.0;

%macro hasvarsn(ds,varlist,casesens=no);
  %local varmatch varlistn;
  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));
  %let varlistn=%varlistn(&ds);
  %if not %length(&varlistn) %then %do;
%put NOTE: (hasvarsn) There are no numeric variables in the input dataset therefore;
%put NOTE: (hasvarsn) the numeric variable(s) you are testing for will not be found.;
    %let varmatch=%match(,&varlist,casesens=&casesens);
0
  %end;
  %else %do;
    %let varmatch=%match(&varlistn,&varlist,casesens=&casesens);
    %if not %length(&_nomatch_) %then 1;
    %else 0;
  %end;
%mend hasvarsn;
  /*<pre><b>
/ Program   : hexchars.sas
/ Version   : 2.2
/ Author    : Roland Rashleigh-Berry
/ Date      : 02-May-2013
/ Purpose   : To show up ascii non-printables characters in a flat file by
/             displaying their ascii codes as hexadecimal numbers in "< >"
/             symbols.
/ SubMacros : none
/ Notes     : Files path can be quoted or unquoted. If you are using this to
/             look for invisible delimiters in a ".csv" file then these
/             invisible delimiters are almost certainly the horizontal tab
/             character "09"x. To find out then use this macro as in the first
/             example usage notes and you will see "<09>" (or a different value)
/             in the log and once you know you can use "proc import" to read in
/             the file using this syntax:
/                PROC IMPORT DATAFILE="myfile.ext" OUT=mydset DBMS=DLM REPLACE;
/                  DELIMITER="09"x;
/                  GETNAMES=YES;
/                RUN;
/             Alternately, you can use the %dlm2sas macro to read in a file and
/             create a dataset but that macro can only read simple files and
/             will create only character fields of a uniform length.
/ Usage     : %hexchars(infile.ext)
/             %hexchars(infile.ext,"outfile.ext")
/             %hexchars(infile.ext,outfile.ext)
/             %hexchars("infile.ext")
/             %hexchars("infile.ext",print)
/             %hexchars("infile.ext","log")
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ infile            (pos) Input file (quoted or unquoted)
/ file              (pos) Output file (quoted or unquoted) (can be "print" or
/                   "log"). Written to the log by default.
/ termstr=CRLF      Terminating characters for each line. CRLF is for Windows
/                   platforms where the file is a pure ascii file. LF is for
/                   Unix platforms or utf-8 encoded files. You can use the
/                   %termstr macro to help you decide this value.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/ rrb  25Jun11         Renamed from %asciinonp and changed to enable output to
/                      be written to print output or the log and made more
/                      friendly for file quoting  (v2.0)
/ rrb  02Jul11         Added check on input file existence (v2.1)
/ rrb  02May13         termstr=CRLF parameter added (v2.2)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: hexchars v2.2;

%macro hexchars(infile,file,termstr=CRLF);

  %local err;
  %let err=ERR%str(OR);

  %if not %length(&infile) %then %do;
    %put &err: (hexchars) No file path specified;
    %goto exit;
  %end;
  %else %do;
    %let infile=%sysfunc(dequote(&infile));
    %if not %sysfunc(fileexist(&infile)) %then %do;
      %put &err: (hexchars) File "&infile" can not be found;
      %goto exit;
    %end;
  %end;

  %if %length(&file) %then %let file=%sysfunc(dequote(&file));

  data _null_;
    length linein $ 256 newline $ 400 char $ 1;
    retain outpos 0 ;
    infile "&infile" pad termstr=&termstr;
    %if not %length(&file) %then %do;
    %end;
    %else %if "%upcase(&file)" EQ "LOG" %then %do;
    %end;
    %else %if "%upcase(&file)" EQ "PRINT" %then %do;
      file print notitles noprint;
    %end;
    %else %do;
      file "&file" notitles noprint;
    %end;
    input linein $char256.;
    outpos=1;
    if linein ne ' ' then do;
      do i=1 to length(linein);
        char=substr(linein,i,1);
        rank=rank(char);
        if 32 <= rank <= 126 then do;
          substr(newline,outpos,1)=char;
          outpos=outpos+1;
        end;
        else do;
          substr(newline,outpos,4)='<'||put(rank,hex2.)||'>';
          outpos=outpos+4;
        end;
      end;
      put @(length(newline)-length(left(newline))+1) newline;
    end;
    else put;
  run;

  %goto skip;
  %exit: %put &err: (hexchars) Leaving macro due to problem(s) listed;
  %skip:

%mend hexchars;
/*<pre><b>
/ Program   : hexcnt.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To count the strange hex character in character variables
/ SubMacros : %nvarsc
/ Notes     : It is not possible to implement this as a function-style macro due
/             to the data step boundary so the results will be written out to a
/             global macro variable. What you do with the list created is
/             entirely up to you. The variable will be directly followed by an
/             equal sign followed directly by the hex value count. Variables
/             with zero hex count values will not be shown.
/ Usage     : %hexcnt(dsname,droplist,globcnt=_hexcnt_,globvars=_hexvars_);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset (pos) (must be pure dataset name and have no keep,
/                   drop, where or rename associated with it).
/ drop              List of variables (pos - unquoted and separated by spaces)
/                   to drop from the analysis.
/ globcnt=_hexcnt_    Name of the global macro variable to set up to contain the
/                   list of variables and their hex count.
/ globvars=_hexvars_  Name of the global macro variable to set up to contain the
/                   list of variables with a detected hex count.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: hexcnt v1.0;

%macro hexcnt(ds,drop,globcnt=_hexcnt_,globvars=_hexvars_);

  %local dsname nvarsc;
  %global &globcnt &globvars;
  %let &globcnt=;
  %let &globvars=;
  %let dsname=&ds;

  %if %length(&drop) GT 0 %then %do;
    %let dsname=_hexcnt;
    data _hexcnt;
      set &ds(drop=&drop);
    run;
  %end;

  %let nvarsc=%nvarsc(&dsname);

  %if &nvarsc %then %do;
    data _null_;
      array _chex {&nvarsc} 8 _temporary_ (&nvarsc*0);
      set &dsname end=last;
      array _char {*} _character_;
      do i=1 to &nvarsc;
        len=length(_char(i));
        do j=1 to len;
          rank=rank(substr(_char(i),j,1));
          if rank<0020x or rank>00FFx then do;
          *if rank<0020x or (007Ex < rank < 00C0x) 
          and rank not in (00B0x, 00B4x, 00B5x, 00AEx) then do;
            _chex(i)=_chex(i)+1;
            j=len;
          end;
        end;
      end;
      if last then do;
        do i=1 to &nvarsc;
          if _chex(i) GT 0 then do;
            call execute('%let &globcnt=&&&globcnt '||
            trim(vname(_char(i)))||'='||compress(put(_chex(i),11.))||';');
            call execute('%let &globvars=&&&globvars '||trim(vname(_char(i)))||';');
          end;
        end;
      end;
    run;
  %end;


  %if %length(&drop) GT 0 %then %do;
    proc datasets nolist;
      delete _hexcnt;
    run;
  %end;

%mend hexcnt;
/*<pre><b>
/ Program      : int2num.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 27-Nov-2012
/ Purpose      : To convert variables to numeric where you know they should be
/                integer variables.
/ SubMacros    : %editlist
/ Notes        : Especially when importing from spreadsheets, it can sometimes
/                happen that columns you know should be numeric turn out to be
/                character. This macro accepts a list of variables you want to
/                be numeric and transforms them into numeric variables of the
/                same name. They must all be variables you expect to be
/                integers. For non-integer variables use the %vars2num macro.
/
/ Usage        : data test2;
/                  set test1;
/                  %int2num(vara varb varc vard)
/                run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ varlist           (pos) List of variables separated by spaces that you want to
/                   ensure are numeric integer variables.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  27Nov12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: int2num v1.0;

%macro int2num(varlist); 
%editlist(&varlist,'__&item=input(put(&item,32.),32.);drop &item;rename __&item=&item;') 
%mend int2num;
/*<pre><b>
/ Program   : isodatepart.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 14-Dec-2012
/ Purpose   : In-datastep function-style macro for extracting the date part of a
/             standard ISO 8601 datetime text value.
/ SubMacros : none
/ Notes     : Text to the left of the "T" is assumed to be in yymmdd10. form but
/             if it is not in this valid form then a missing value results.
/ Usage     : data test;
/               set test;
/               date=%isodatepart(isodttmvar);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ isodttmvar        (pos) ISO 8601 text datetime variable           
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  14Dec12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: isodatepart v1.0;

%macro isodatepart(isodttmvar);
input(scan(&isodttmvar,1,"T"),??yymmdd10.)
%mend isodatepart;
/*<pre><b>
/ Program   : isodttm.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 14-Dec-2012
/ Purpose   : In-datastep function-style macro for generating a standard ISO
/             8601 datetime value from a numeric date and time value.
/ SubMacros : none but assumes %isoformats has been run
/ Notes     : This macro uses the two formats isodate. and isotime. created by
/             the %isoformats macro (which you should have already called).
/ Usage     : data test;
/               length dtc $ 20;
/               set test;
/               dtc=%isodttm(datevar,timevar);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ datevar           (pos) sas numeric date variable
/ timevar           (pos) sas numeric time variable
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  14Dec12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: isodttm v1.0;

%macro isodttm(datevar,timevar);
put(&datevar,isodate.)||"T"||put(&timevar,isotime.)
%mend isodttm;
/*<pre><b>
/ Program   : isoformats.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 14-Dec-2012
/ Purpose   : Macro to define the ISO 8601 formats used by the %isodttm macro
/             for generating an ISO 8601 datetime string.
/ SubMacros : none
/ Notes     : This macro creates the two formats isodate. and isotime. used in
/             creating a text ISO 8601 datetime string. The main purpose is to
/             represent a missing date as xxxx-xx-xx and a missing time as
/             xx:xx:xx in the ISO 8601 text.
/ Usage     : %isoformats;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ N/A
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  14Dec12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: isoformats v1.0;

%macro isoformats;

  proc format;
    value isodate
    .="xxxx-xx-xx"
    OTHER=[yymmdd10.]
    ;
    value isotime
    .="xx:xx:xx"
    OTHER=[time8.]
    ;
  run;

%mend isoformats;
/*<pre><b>
/ Program   : isotimepart.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 14-Dec-2012
/ Purpose   : In-datastep function-style macro for extracting the time part of a
/             standard ISO 8601 datetime text value.
/ SubMacros : none
/ Notes     : Text to the right of the "T" is assumed to be in time8. form but
/             if it is not in this valid form then a missing value results.
/ Usage     : data test;
/               set test;
/               time=%isotimepart(isodttmvar);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ isodttmvar        (pos) ISO 8601 text datetime variable           
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  14Dec12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: isotimepart v1.0;

%macro isotimepart(isodttmvar);
input(scan(&isodttmvar,2,"T"),??time8.)
%mend isotimepart;
/*<pre><b>
/ Program   : killsas.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 26-Jul-2011
/ Purpose   : To kill any user's SAS session except the one running this macro
/ SubMacros : none
/ Notes     : This will close all other sas sessions for a user except the one
/             running this macro. This is a slightly easier macro to call than
/             %killsess where you have only two sas session and you need to
/             close the other one due to some problem. It only closes sas
/             sessions run by the user - not other peoples. It works on a
/             Windows platform only.
/ Usage     : %killsas
/
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ N/A
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: killsas v1.0;

%macro killsas;
x taskkill /f /fi "IMAGENAME eq sas.exe" /fi "USERNAME eq &sysuserid" /fi "PID ne &sysjobid" ;
%mend killsas;

/*<pre><b>
/ Program   : killsess.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 26-Jul-2011
/ Purpose   : To kill a Windows SAS session
/ SubMacros : none
/ Notes     : This macro is for when your SAS session is running on a Windows
/             platform and you can not close it down so you use another session
/             to close it. This would be typical for SAS running on a Citrix
/             server. It assumes you have the "taskkill" utility. You might have
/             to tailor this macro if your windowtitle is shown differently.
/ Usage     : %killsess
/             %killsess(2)
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ sessno            (pos) Session number (default 1)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jul11         Do not allow the user to close the sas session running
/                      this macro (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: killsess v1.1;

%macro killsess(sessno);
  %local err;
  %let err=ERR%str(OR);

  %if not %length(&sessno) %then %let sessno=1;
  %else %if %length(%sysfunc(compress(&sessno,1234567890))) %then %do;
    %put &err: (killsess) You must specify an integer for the session number sessno=&sessno;
    %goto exit;
  %end;

  x taskkill /f /fi "USERNAME eq &sysuserid" /fi "PID ne &sysjobid" /fi "WINDOWTITLE eq SAS Session &sessno.*";

  %goto skip;
  %exit: %put &err: (killsess) Leaving macro due to problem(s) listed;
  %skip:
%mend killsess;
/*<pre><b>
/ Program   : ksplitvar.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 06-Mar-2012
/ Purpose   : In-datastep macro to insert split characters into a utf-8 string
/             variable.
/ SubMacros : none
/ Notes     : A split character will normally be placed in a blank space. If
/             there is no suitable space then it will be inserted after a hyphen
/             or a comma but if there is no suitable space and no hyphen or
/             comma then it will be inserted at the end. Searches for spaces
/             and hyphens or commas are only done for half the column width so
/             that the number of lines used for overflow is kept to a limit.
/
/             The string with the split characters added will normally be
/             assigned to a new variable whose name you choose. If left blank
/             then the new string in reassigned to the input variable.
/
/             Indentation is maintained such that if you had to split a string
/             which was indented two spaces then the next segment of the string
/             will also be indented two spaces. You can add to this indentation
/             to create a "hanging indent" using the hindent= parameter to make
/             it clearer that following line segments are a continuation of the
/             first one.
/
/             Note that this is not a function-style macro. It must be used in a
/             data step as shown in the usage notes.
/
/ Usage     : data aaa;
/               set aaa;
/               %ksplitvar(oldvar,newvar,10,split=/,hindent=0);
/             run;
/=============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ oldvar            (pos) Variable to split.
/ newvar            (pos) New variable created with split characters added.
/ width             (pos) The maximum width of the column as displayed.
/ split=@           Split character. Must be a single character (quoted or
/                   unquoted).
/ spliton=",-"      Characters to split after (quoted)
/ splitat=" "       Preferred character to split at (quoted - the split
/                   character will replace this character).
/ colon=": "        Colon character string for indented splits (quoted)
/ hindent=0         By default, do not show following string segments with a 
/                   hanging indent. Set to a positive integer to indent the
/                   following line segments by that number of spaces.
/ usecolon=yes      By default, if ": " occurs in the string start within 30% of
/                   the defined width then use this to align following line
/                   segments.
/ biglen=8040       Default large working length
/===============================================================================
/ TEST CODE FOLLOWS:
/===============================================================================
options nocenter nonumber nodate;
title;

%let width=30;
%let split=/;
%let hindent=4;

data test;
length term $ 200;
term="SOC short term";
output;
term="  PT short 1";
output;
term="  PT short 2";
output;
term=" ";
output;
term="System Organ Class long term that is going to flow to more lines";
output;
term="  PT short 1";
output;
term="  PT short 2";
output;
term="  Preferred term code that is also long and is going to flow to more lines";
output;
term="  Indented: preferred term code that is also long and is going to flow to more lines";
output;
term="  Indented comma-delimited list of patient numbers 1234,1234,1234,1234,1234,1234,1234";
output;
run;

data test2;
  set test;
  %ksplitvar(term,term2,&width,split=&split,hindent=&hindent);
run;

proc report nowd data=test2 split="&split" headline headskip;
columns term2;
define term2 / "SOC" "  Preferred Term" display flow width=&width spacing=0;
run;
/===============================================================================
/ TEST OUTPUT FOLLOWS:
/===============================================================================
SOC
  Preferred Term
______________________________

SOC short term
  PT short 1
  PT short 2

System Organ Class long term
    that is going to flow to
    more lines
  PT short 1
  PT short 2
  Preferred term code that is
      also long and is going
      to flow to more lines
  Indented: preferred term
            code that is also
            long and is going
            to flow to more
            lines
  Indented comma-delimited
      list of patient numbers
      1234,1234,1234,1234,
      1234,1234,1234
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  06Mar12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: ksplitvar v1.0;

%macro ksplitvar(oldvar,
                 newvar,
                 width,
                 split=@,
                 hindent=0,
                 usecolon=yes,
                 biglen=8040,
                 spliton=",-",
                 splitat=" ",
                 colon=": ",
                 debug=n);

  %local err errflag lenvar;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&debug) %then %let debug=n;
  %let debug=%upcase(%ksubstr(&debug,1,1));

  %if not %length(&usecolon) %then %let usecolon=yes;
  %let usecolon=%upcase(%ksubstr(&usecolon,1,1));

  %if not %length(&newvar) %then %let newvar=&oldvar;
  %else %let lenvar=&newvar;

  %if not %length(&split) %then %let split=@;
  %else %let split=%sysfunc(dequote(&split));

  %if not %length(&width) %then %do;
    %put &err: (ksplitvar) No width specified as third parameter;
    %let errflag=1;
  %end;
  %else %do;
    %if %length(%sysfunc(compress(&width,0123456789))) %then %do;
      %put &err: (ksplitvar) You must supply a positive integer value to width=&width;
      %let errflag=1;
    %end;
  %end;

  %if not %length(&hindent) %then %let hindent=0;
  %if %length(%sysfunc(compress(&hindent,0123456789))) %then %do;
    %put &err: (ksplitvar) You must supply a positive integer value to hindent=&hindent;
    %let errflag=1;
  %end;

  %if not %length(&biglen) %then %let biglen=8040;

  %if &errflag %then %goto exit;

  length __newstr __rest $ &biglen ;

  if klength(&oldvar) LE &width then __newstr=&oldvar;
  else do;
    __hindent=&hindent;
    __newstr=" ";
    __rest=&oldvar;
    %if "&usecolon" NE "N" %then %do;
      if 0 LT kindex(kleft(__rest),&colon) LE (&width*0.3) 
       then __hindent=kindex(kleft(__rest),&colon)+klength(&colon)-1;
    %end;
    __indent=verify(__rest," ")-1;
    do while(__rest NE " ");
      __minw=max(__indent+__hindent+1,floor(&width/2));
      %if &debug EQ Y %then %do;
        put __minw= __indent= __hindent=;
        put __rest=;
      %end;
      do __i=(&width+1) to __minw by -1;
        __break=0;
        if (ksubstr(__rest,__i,1) EQ &splitat) 
         or (kindex(&spliton,ksubstr(__rest,__i,1)) and __i LE &width) then do;
          __break=1;
          if ksubstr(__rest,__i,1) EQ &splitat then do;
            if __newstr=" " then __newstr=ktrim(ksubstr(__rest,1,__i-1))||"&split";
            else __newstr=ktrim(__newstr)||ktrim(ksubstr(__rest,1,__i-1))||"&split";
            __rest=ktrim(kleft(ksubstr(__rest,__i+1)));
          end;
          else do;
            *- we have a split-on character that we need to show and keep -;
            if __newstr=" " then __newstr=ktrim(ksubstr(__rest,1,__i))||"&split";
            else __newstr=ktrim(__newstr)||ktrim(ksubstr(__rest,1,__i))||"&split";
            __rest=ktrim(kleft(ksubstr(__rest,__i+1)));
          end;
          __i=1;
        end;
      end;
      if not __break then do;
        %if &debug EQ Y %then %do;
          put "NO BREAK FOUND in __rest last half";
          put __newstr=;
          put __rest=;
        %end;
        if __newstr=" " then __newstr=ktrim(ksubstr(__rest,1,&width))||"&split";
        else __newstr=ktrim(__newstr)||ktrim(ksubstr(__rest,1,&width))||"&split";
        __rest=ktrim(kleft(ksubstr(__rest,&width+1)));
      end;
      __repspace=__indent+__hindent-1;
      if __repspace GE 0 then do;
        __rest=repeat(" ",__repspace)||__rest;
      end;
      %if &debug EQ Y %then %do;
        put __newstr=;
        put __rest=;
      %end;
    end;
  end;
  &newvar=__newstr;
  DROP __newstr __rest __i __break __minw __repspace __indent __hindent;

  %goto skip;
  %exit: %put &err: (ksplitvar) Leaving macro due to problem(s) listed;
  %skip:

%mend ksplitvar;
/*<pre><b>
/ Program      : lafootnote.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : To create a left-aligned footnote
/ SubMacros    : none
/ Notes        : The footnote must be in quotes. Leading spaces are allowed.
/ Usage        : %lafootnote(2,"  second footnote indented two spaces")
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ num               (pos) footnote number
/ string            (pos) (in quotes) Footnote to left-align
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: lafootnote v1.0;

%macro lafootnote(num,string);
  footnote&num &string "%sysfunc(repeat(%str( ),199)))";
%mend lafootnote;
/*<pre><b>
/ Program      : latitle.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : To create a left-aligned title
/ SubMacros    : none
/ Notes        : The title must be in quotes. Leading spaces are allowed.
/ Usage        : %latitle(2,"  second title indented two spaces")
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ num               (pos) title number
/ string            (pos) (in quotes) Title to left-align
/ pagemark=no       By default, do not add a page marker (to receive the Page x
/                   of Y label) in the rightmost column
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  19Oct05         Add pagemark= parameter
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: latitle v1.0;

%macro latitle(num,string,pagemark=no);
  %local ls;
  %let ls=%sysfunc(getoption(linesize));

  %if not %length(&pagemark) %then %let pagemark=no;
  %let pagemark=%upcase(%substr(&pagemark,1,1));

  %if "&pagemark" EQ "Y" %then %do;
    title&num &string "%sysfunc(repeat(%str( ),&ls-%length(&string)))" 'FF'x;
  %end;
  %else %do;
    title&num &string "%sysfunc(repeat(%str( ),199))";
  %end;
%mend latitle;
/*<pre><b>
/ Program      : lcralign.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : Write to a macro variable with the supplied text left, center
/                and right-aligned.
/ SubMacros    : none
/ Notes        : The text to align must be in quotes. The macro variable
/                to receive the output must have been declared either locally
/                or globally before calling this macro. If no macro variable
/                name is supplied then a global macro variable _lcralign_ is set
/                up and used. If no length is specified then the line size in
/                effect will be used.
/                This is NOT a function-style macro. See usage notes.
/ Usage        : %let macvar=;
/                %lcralign(macvar,50,"left bit","center bit","right bit")
/                %put macvar=*&macvar*;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ macvar            (pos) name of macro variable to receive aligned results
/                   (will create a global macro variable name _lcralign_ if no
/                    macro variable name specified).
/ len               (pos) number of columns to use (defaults to line size)
/ left              (pos) (in quotes) text to left-align  (optional)
/ center            (pos) (in quotes) text to center      (optional)
/ right             (pos) (in quotes) text to right-align (optional)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: lcralign v1.0;

%macro lcralign(macvar,len,l,c,r);

  %local ls;

  %*- set up global macro variable _lcralign_ if no name supplied -;
  %if not %length(&macvar) %then %do;
    %global _lcralign_;
    %let macvar=_lcralign_;
  %end;


  %*- set len to same as line size if no length supplied -;
  %if not %length(&len) %then %do;
    %let ls=%sysfunc(getoption(linesize));
    %let len=&ls;
  %end;


  %*- set macvar contents to null in case data step fails -;
  %let &macvar=;


  *- align the text elements and symput out to macvar -;
  data _null_;
    length text $ &len;
    text=" ";
    %if %length(&l) %then %do;
      text=&l;
    %end;
    %if %length(&c) %then %do;
      substr(text,floor((&len-length(&c))/2)+1)=&c;
    %end;
    %if %length(&r) %then %do;
      substr(text,&len-length(&r)+1)=&r;
    %end;
    call symput("&macvar",text);
  run;

%mend lcralign;
/*<pre><b>
/ Program   : liblist.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 24-Nov-2009
/ Purpose   : To list all the libraries.
/ SubMacros : none
/ Notes     : This is NOT a function-style macro. See usage notes.
/             The list of libraries will be written to the global macro variable
/             _liblist_.
/ Usage     : %liblist;
/             %let liblist=&_liblist_;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ none
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: liblist v1.0;

%macro liblist;
  %global _liblist_;
  %let _liblist_=;

  proc sql noprint;
    select distinct libname into :_liblist_ separated by ' '
    from sashelp.vslib;
  quit;
%mend liblist;
/*<pre><b>
/ Program   : ljustify.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To left-justify all character fields in a dataset
/ SubMacros : none
/ Notes     : If there are no character variables in the input data set then it
/             will cause an error. Use %nvarsc to check that the number of
/             character variables is greater than zero, if unsure, before
/             calling this macro.
/ Usage     : %ljustify(dset)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsin              (pos) Input dataset
/ dsout             (pos) Output dataset (defaults to input dataset)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: ljustify v1.0;

%macro ljustify(dsin,dsout);

  %if not %length(&dsout) %then %let dsout=%scan(&dsin,1,%str(%());

  data &dsout;
    set &dsin;
    array _char {*} _character_;
    do _i=1 to dim(_char);
      _char(_i)=left(_char(_i));
    end;
    drop _i;
  run;

%mend ljustify;
  /*<pre><b>
/ Program   : look4lwork.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 01-Jun-2014
/ Purpose   : To look for the fileref LWORK and if found to change the "srclib"
/             value from "work" to "lwork" and to assign lwork.formats to the
/             format search path.
/ SubMacros : none
/ Notes     : This is an early attempt to detect when code is running remotely
/             and to adjust to the situation. LWORK is assumed to be the 
/             inherited WORK library from the calling program and if this libref
/             is found then the value of "srclib" wil be reassigned to "lwork".
/
/             The intention of the macro is to help you design code members that
/             will work in both local and remote sessions without change. It is
/             intended mainly for "reporting" members that report on datasets
/             that are prebuilt in the WORK library and this is why you see
/             the assignment to "srclib" in the usage notes below. It is assumed
/             that this will be resolved in your code as &srclib..dset1 etc. to
/             access the prebuilt datasets. This value of "work" can then be
/             replaced with "lwork" if you are running in a remote session.
/             "lwork" will also be added to the format search path if this
/             situation is detected.
/
/             You should call this macro as early as convenient in your code as
/             shown in the usage notes.
/
/ Usage     : %let srclib=work;  *- the expected source of prebuilt datasets -;
/             %look4lwork
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ N/A
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  01Jun14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: look4lwork v1.0;

%macro look4lwork; 
  %if (%sysfunc(libref(lwork))) EQ 0 %then %do; 
    *- data and formats will be in the LWORK library -; 
    %let srclib=lwork; 
    options fmtsearch=(lwork.formats); 
  %end; 
%mend look4lwork; 
/*<pre><b>
/ Program   : lookahead.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To do the opposite of lag and allow the user to look ahead at the
/             variables in the following observations in the same by group.
/ SubMacros : %words
/ Notes     : The input dataset must be sorted into the correct order. The
/             "bygroup" parameter will be set to the grouping variables which is
/             not the same as the list of sort variables since the records will
/             be sorted WITHIN the group as well. Suppose your sort variables 
/             were "subject, date, time" then your "bygroup" variable might just
/             be "subject". The look-ahead is only done within the "bygroup" set.
/             
/             The lookahead variables created will have the same name as the 
/             original variables except with a numeric suffix on the end. So for
/             the observation following it will have the suffix "1" and for the
/             second observation it will have the suffix "2" etc.
/ Usage     : 
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsin=             Input dataset
/ dsout=            Output dataset
/ bygroup=          Grouping variables(s)
/ vars=             Variables you want to look ahead for
/ lookahead=1       Number of observations to look ahead
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/==============================================================================*/

%put MACRO CALLED: lookahead v1.0;

%macro lookahead(dsin=,dsout=,bygroup=,vars=,lookahead=1);

  %local errflag i err;
  %let err=ERR%str(OR);
  %let errflag=0;


              /*--------------------------------------*
                 Check we have enough parameters set
               *--------------------------------------*/

  %if not %length(&dsin) %then %do;
    %let errflag=1;
    %put &err: (lookahead) Nothing specified to dsin= parameter;
  %end;

  %if not %length(&bygroup) %then %do;
    %let errflag=1;
    %put &err: (lookahead) Nothing specified to bygroup= parameter;
  %end;

  %if not %length(&vars) %then %do;
    %let errflag=1;
    %put &err: (lookahead) Nothing specified to vars= parameter;
  %end;

  %if &errflag %then %goto exit;

  %if not %length(&dsout) %then %let dsout=%scan(&dsin,1,%str(%());

  %if not %length(&lookahead) %then %let lookahead=1;



            /*--------------------------------------*
                   Start processing the data
             *--------------------------------------*/

  data _look;
    retain _seq 0;
    set &dsin;
    by &bygroup;
    if first.%scan(&bygroup,-1,%str( )) then _seq=0;
    _seq=_seq+1;
  run;

  %do i=1 %to &lookahead;
    data _look&i;
      set _look(keep=_seq &bygroup &vars);
      _seq=_seq-&i;
      rename
      %do j=1 %to %words(&vars);
        %scan(&vars,&j,%str( ))=%scan(&vars,&j,%str( ))&i
      %end;
      ;
    run;  
  %end;

  data &dsout;
    merge _look(in=_look)
    %do i=1 %to &lookahead;
        _look&i
    %end;
        ;
    by &bygroup _seq;
    if _look;
    drop _seq;
  run;



            /*--------------------------------------*
                         Tidy up and exit
             *--------------------------------------*/

  proc datasets nolist;
    delete _look
    %do i=1 %to &lookahead;
      _look&i
    %end;
    ;
  run;
  quit;


  %goto skip;
  %exit: %put &err: (lookahead) Leaving macro due to problem(s) listed;
  %skip:

%mend lookahead;
/*<pre><b>
/ Program   : lrafootnote.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To left and right-align a two part footnote for a pure text output
/ SubMacros : none
/ Notes     : This is for pure text output listings and tables. For other types 
/             of output you can use j=left, j=right or .j=left and .j=right in
/             the footnote statement to align elements of it.
/ Usage     : %lrafootnote(5,"Left aligned","Right-aligned")
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ num               (pos) Number of footnote
/ textl             (pos) Text for left alignment (must be in quotes)
/ textr             (pos) Text for right alignment (must be in quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: lrafootnote v1.0;

%macro lrafootnote(num,textl,textr);

  %local ls lenl lenr lent rpt wrn;
  %let wrn=WAR%str(NING);

  %let lenl=0;
  %if %length(&textl) %then %let lenl=%eval(%length(&textl)-2);

  %let lenr=0;
  %if %length(&textr) %then %let lenr=%eval(%length(&textr)-2);

  %let ls=%sysfunc(getoption(linesize));

  %let lent=%eval(&lenl+&lenr);

  %if &lent GT &ls %then %do;
    %put &wrn: (lrafootnote) Your footnote text is longer than the current linesize of &ls;
    footnote&num &textl &textr;
  %end;
  %else %if &lent EQ &ls %then %do;
    footnote&num &textl &textr;
  %end;
  %else %do;
    %let rpt=%eval(&ls-&lent-1);
    footnote&num &textl "%sysfunc(repeat(%str( ),&rpt))" &textr;
  %end;

%mend lrafootnote;
/*<pre><b>
/ Program   : lratitle.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To left and right-align a two part title for a pure text output
/ SubMacros : none
/ Notes     : This is for pure text output listings and tables. For other types 
/             of output you can use j=left, j=right or .j=left and .j=right in
/             the title statement to align elements of it.
/ Usage     : %lratitle(5,"Left aligned","Right-aligned")
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ num               (pos) Number of title
/ textl             (pos) Text for left alignment (must be in quotes)
/ textr             (pos) Text for right alignment (must be in quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: lratitle v1.0;

%macro lratitle(num,textl,textr);

  %local ls lenl lenr lent rpt wrn;
  %let wrn=WAR%str(NING);

  %let lenl=0;
  %if %length(&textl) %then %let lenl=%eval(%length(&textl)-2);

  %let lenr=0;
  %if %length(&textr) %then %let lenr=%eval(%length(&textr)-2);

  %let ls=%sysfunc(getoption(linesize));

  %let lent=%eval(&lenl+&lenr);

  %if &lent GT &ls %then %do;
  %put &wrn: (lratitle) Your title text is longer than the current linesize of &ls;
    title&num &textl &textr;
  %end;
  %else %if &lent EQ &ls %then %do;
    title&num &textl &textr;
  %end;
  %else %do;
    %let rpt=%eval(&ls-&lent-1);
    title&num &textl "%sysfunc(repeat(%str( ),&rpt))" &textr;
  %end;

%mend lratitle;
/*<pre><b>
/ Program   : ls2ds.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To write a list of Unix/Linux file names to a sas dataset
/ SubMacros : %ls2sas
/ Notes     : The command "LS -1" is used to list the members that fit the file
/             pattern you specify. The output dataset will contain a field
/             "filename" that is the name of the file as listed and "lcfname"
/             which is a lower case version of "filename" that is convenient for
/             checking purposes.
/ Usage     : %ls2ds(./MYLIB/*.txt);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ filepattern       (pos) File pattern
/ dsout             (pos) Output dataset name (defaults to _ls2ds)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Mar14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: ls2ds v1.0;

%macro ls2ds(filepattern,dsout);
  %if not %length(&dsout) %then %let dsout=_ls2ds;
  %ls2sas(&filepattern,&dsout)
%mend ls2ds;
/*<pre><b>
/ Program   : ls2sas.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 23-Apr-2013
/ Purpose   : To write a list of Unix/Linux file names to a sas dataset
/ SubMacros : none
/ Notes     : The command "LS -1" is used to list the members that fit the file
/             pattern you specify. The output dataset will contain a field
/             "filename" that is the name of the file as listed and "lcfname"
/             which is a lower case version of "filename" that is convenient for
/             checking purposes.
/ Usage     : %ls2sas(./MYLIB/*.txt);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ filepattern       (pos) File pattern
/ dsout             (pos) Output dataset name (defaults to _ls2sas)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  23Apr13         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: ls2sas v1.0;

%macro ls2sas(filepattern,dsout);

  %local savopts;
  %let savopts=%sysfunc(getoption(NOTES));

  %if not %length(&dsout) %then %let dsout=_ls2sas;

  options nonotes;

  filename _ls2sas pipe "ls -1 %sysfunc(dequote(&filepattern))";

  data &dsout;
    length filename lcfname $ 200;
    infile _ls2sas;
    input;
    filename=trim(_infile_);
    lcfname=lowcase(scan(filename,-1,"/"));
  run;

  filename _ls2sas CLEAR;

  options &savopts;

%mend ls2sas;
/*<pre><b>
/ Program   : lscmd.sas
/ Version   : 1.2
/ Author    : Roland Rashleigh-Berry
/ Date      : 24-Aug-2013
/ Purpose   : Function-style macro to return a list of members of a directory
/             on a Unix platform according to the file pattern you supply.
/             If you supply just the directory name then all members are 
/             listed. This runs the Unix command in the form "ls -1 mydir" .
/ SubMacros : %qreadpipe
/ Notes     : Just the file names are returned unquoted. If you need the full
/             path name in double quotes then use the %lsfpq macro instead
/             which will correctly handle file names containing spaces.
/ Usage     : %let dirlist=%lscmd(/usr/utilmacros);
/             %let dirlist=%lscmd(/usr/utilmacros/*.sas);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dir               (pos) Directory path name (no quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jun11         Remove quotes if supplied (v1.1)
/ rrb  24Aug13         Name of this macro changed from "ls" to "lscmd" so as not
/                      to be the same as a macro of that name in the sas
/                      autocall library (v1.2)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: lscmd v1.2;

%macro lscmd(dir);
%unquote(%qreadpipe(ls -1 %sysfunc(dequote(&dir))))
%mend lscmd;

/*<pre><b>
/ Program   : lsfp2ds.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To write a list of Unix/Linux full path file names to a dataset
/ SubMacros : %lsfp2sas
/ Notes     : Full path file names will be listed that fit the file pattern you
/             specify. The output dataset will contain a field "filename" that
/             is the full path file name as listed and "lcfname" which is a
/             lower case version of "filename" without the path prefix that is
/             convenient for checking purposes.
/ Usage     : %lsfp2ds(./MYLIB/*.txt);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ filepattern       (pos) File pattern
/ dsout             (pos) Output dataset name (defaults to _lsfp2ds)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Mar14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: lsfp2ds v1.0;

%macro lsfp2ds(filepattern,dsout);
  %if not %length(&dsout) %then %let dsout=_lsfp2ds;
  %lsfp2sas(&filepattern,&dsout)
%mend lsfp2ds;
/*<pre><b>
/ Program   : lsfp2sas.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 23-Apr-2013
/ Purpose   : To write a list of Unix/Linux full path file names to a dataset
/ SubMacros : none
/ Notes     : Full path file names will be listed that fit the file pattern you
/             specify. The output dataset will contain a field "filename" that
/             is the full path file name as listed and "lcfname" which is a
/             lower case version of "filename" without the path prefix that is
/             convenient for checking purposes.
/ Usage     : %lsfp2sas(./MYLIB/*.txt);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ filepattern       (pos) File pattern
/ dsout             (pos) Output dataset name (defaults to _lsfp2sas)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  23Apr13         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: lsfp2sas v1.0;

%macro lsfp2sas(filepattern,dsout);

  %local savopts;
  %let savopts=%sysfunc(getoption(NOTES));

  %if not %length(&dsout) %then %let dsout=_lsfp2sas;

  options nonotes;

  filename _lsfp pipe 
  "for fn in %sysfunc(dequote(&filepattern)) ; do echo $fn ; done";

  data &dsout;
    length filename $ 300 lcfname $ 200;
    infile _lsfp;
    input;
    filename=trim(_infile_);
    lcfname=lowcase(scan(filename,-1,"/"));
  run;

  filename _lsfp CLEAR;

  options &savopts;

%mend lsfp2sas;
/*<pre><b>
/ Program   : lsfpq.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 26-Jun-2011
/ Purpose   : Function-style macro to return a list of full-path quoted members
/             of a directory on a Unix platform according to the file pattern
/             you supply.
/ SubMacros : %qreadpipe
/ Notes     : Members are shown with the full path names in double quotes. If a
/             file name contains spaces then this will be correctly quoted. You
/             MUST give the full file pattern and not just the directory as this
/             does not use the ls command to act on the directory but rather
/             expands the file pattern.
/ Usage     : %let dirlist=%lsfpq(/usr/mylib);     %*- NO GOOD -;
/             %let dirlist=%lsfpq(/usr/mylib/*);      %*- GOOD -;
/             %let dirlist=%lsfpq(/usr/mylib/*.sas);  %*- GOOD -;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dir               (pos) Directory path name with file pattern (no quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jun11         Remove quotes if supplied (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: lsfpq v1.1;

%macro lsfpq(dir);
%unquote(%qreadpipe(for fn in %sysfunc(dequote(&dir)) ; do echo \"$fn\" ; done))
%mend lsfpq;

/*<pre><b>
/ Program   : lslist2ds.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To read the output of the "ls -l" command into a sas dataset
/ SubMacros : %lslist2sas
/ Notes     : The "ls -l" command produces a listing that can be saved to a file
/             but gives problems in that the position of the fields depends on
/             the length of the fields and as such is unpredictable. The fields
/             "group" and "size" might have no gap between them if they are
/             both long so "scanning" for this can give the wrong result.
/             The file name might contains spaces so this should not be scanned
/             for and instead "call scan" needs to be used to find out the
/             position of the date (or time) that precedes the final file name
/             so that the file name can be read using substr() to the end. There
/             may be other instances of when adjacent columns have no gap
/             between them that will need to be catered for.
/
/             The listing is expected to have the following "ls -l" style:
/
/                /dir1/dir2/dir3:
/                total 111
/                drwxr-xr-x   2 root       root          1024 Jan 21  2000 xx_yy
/
/             Variables in the output dataset are, in this order: path, total,
/             permiss, links, owner, group, size, month, day, year, time, date,
/             datetime, filename.
/
/ Usage     : lslist2ds(my-text-file); 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ textfile          (pos) (no quotes) Enclose in %nrstr() if the file path 
/                   contains spaces or special characters.
/ dsout             (pos) Name of output dataset (defaults to "_lslist2ds")
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Mar14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: lslist2ds v1.0;

%macro lslist2ds(textfile,dsout);
  %if not %length(&dsout) %then %let dsout=_lslist2ds;
  %lslist2sas(&textfile,&dsout)
%mend lslist2ds;
/*<pre><b>
/ Program   : lslist2sas.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To read the output of the "ls -l" command into a sas dataset
/ SubMacros : none
/ Notes     : The "ls -l" command produces a listing that can be saved to a file
/             but gives problems in that the position of the fields depends on
/             the length of the fields and as such is unpredictable. The fields
/             "group" and "size" might have no gap between them if they are
/             both long so "scanning" for this can give the wrong result.
/             The file name might contains spaces so this should not be scanned
/             for and instead "call scan" needs to be used to find out the
/             position of the date (or time) that precedes the final file name
/             so that the file name can be read using substr() to the end. There
/             may be other instances of when adjacent columns have no gap
/             between them that will need to be catered for.
/
/             The listing is expected to have the following "ls -l" style:
/
/                /dir1/dir2/dir3:
/                total 111
/                drwxr-xr-x   2 root       root          1024 Jan 21  2000 xx_yy
/
/             Variables in the output dataset are, in this order: path, total,
/             permiss, links, owner, group, size, month, day, year, time, date,
/             datetime, filename.
/
/ Usage     : lslist2sas(my-text-file); 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ textfile          (pos) (no quotes) Enclose in %nrstr() if the file path 
/                   contains spaces or special characters.
/ dsout             (pos) Name of output dataset (defaults to "_lslist2sas")
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  15May13         New (v1.0)
/ rrb  04Jun13         Problem with dates in the future fixed (v1.1)
/ rrb  20Mar14         Default output dataset name now starts with an underscore
/                      (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: lslist2sas v2.0;


%macro lslist2sas(textfile,dsout);

  %if not %length(&dsout) %then %let dsout=_lslist2sas;

  *-- there is no system informat for months so create one --;
  proc format;
    invalue _mon
    "Jan"=1
    "Feb"=2
    "Mar"=3
    "Apr"=4
    "May"=5
    "Jun"=6
    "Jul"=7
    "Aug"=8
    "Sep"=9
    "Oct"=10
    "Nov"=11
    "Dec"=12
    ;
  run;


  data &dsout;
    length path $ 200 total 8 permiss $ 10 links 8 owner $ 8
           grpsize $ 30 group $ 11 size 8 month $ 3 day 8 yrtm $ 5 
           pos len year time date datetime 8 filename $ 200;
    retain path " " total .;
    infile "&textfile";
    *-- Do a straight "input" and then use _infile_ for      --;
    *-- scanning and sub-stringing to get the column values. --;
    input;
    *-- Note that an "output" is only done for a valid data --;
    *-- line that starts with a "permissions" string.       --;
    if _infile_ NE " " then do;
      if substr(_infile_,length(_infile_),1)=":" 
       then path=substr(_infile_,1,length(_infile_)-1);
      else if _infile_=:"total" then total=input(scan(_infile_,2," "),comma13.);
      else do;
        permiss=scan(_infile_,1," ");
        links=input(scan(_infile_,2," "),6.);
        owner=scan(_infile_,3," ");
        *-- group and size read as combined in case they have joined --;
        grpsize=scan(_infile_,4," ");
        if length(grpsize)>11 then do;
          *-- most likely group and size are joined --;
          group=substr(grpsize,1,prxmatch('/\d+ *$/',grpsize)-1);
          size=input(substr(grpsize,prxmatch('/\d+ *$/',grpsize)),12.);
          month=scan(_infile_,5," ");
          day=input(scan(_infile_,6," "),2.);
          *-- the next will either be a year or the time --;
          yrtm=scan(_infile_,7," ");
          if index(yrtm,':') then do;
            *-- we have a time so assume the year is the current year --;
            time=input(yrtm,time5.);
            year=year(date());
          end;
          else do;
            *-- this is a plain year so set the time to zero --;
            year=input(yrtm,4.);
            time=0;
          end;
          *-- The file name may have spaces in it so we can not --;
          *-- just scan for it so we need to use "call scan" to --;
          *-- tell us where we got the year/time from and skip  --;
          *-- to just after that to read the file name in.      --;
          pos=0;
          len=0;
          call scan(_infile_,7,pos,len," ");
          filename=left(substr(_infile_,pos+len));
        end;
        else do;
          *-- we have seperate group and size --;
          group=grpsize;
          size=input(scan(_infile_,5," "),12.);
          month=scan(_infile_,6," ");
          day=input(scan(_infile_,7," "),2.);
          *-- see above comments --;
          yrtm=scan(_infile_,8," ");
          if index(yrtm,':') then do;
            time=input(yrtm,time5.);
            year=year(date());
          end;
          else do;
            year=input(yrtm,4.);
            time=0;
          end;
          *-- see "call scan" comments above --;
          pos=0;
          len=0;
          call scan(_infile_,8,pos,len," ");
          filename=left(substr(_infile_,pos+len));
        end;
        *-- calculate date and datetime from what we already have --;
        date=mdy(input(month,_mon.),day,year);
        datetime=dhms(date,0,0,time);
        *-- fix the date if it is in the future --;
        if date>today() then do;
          year=year-1;
          date=mdy(input(month,_mon.),day,year);
          datetime=dhms(date,0,0,time);
        end;
        *-- HERE IS WHERE WE DO THE "OUTPUT" --;
        output;
      end;
    end;
    FORMAT date date9. time time5. datetime datetime22.;
    *-- drop working variables (maybe keep for debugging) --;
    DROP pos len grpsize yrtm;
  run;


%mend lslist2sas;
/*<pre><b>
/ Program   : lstattrib.sas
/ Version   : 4.2
/ Author    : Roland Rashleigh-Berry
/ Date      : 02-Apr-2013
/ Purpose   : Lists the variable attributes of the specified dataset in the
/             form of a LENGTH statement and ATTRIB statement that can be used
/             in sas code.
/ SubMacros : none
/ Notes     : The information is written to the log (by default) as
/             syntactically correct sas code so you can copy and paste it into
/             your sas program to help you create a new dataset with the same
/             attributes as the original dataset. An actual example of what is
/             written to the log is shown below in the usage notes section. You
/             can choose an alternative fileref to the log.
/             
/             This macro is intended for interactive use as part of a data
/             pooling exercise, to generate correct LENGTH and ATTRIB statements
/             for the final pooled datasets. This macro could be run against
/             correct template datasets or datasets known to be correct so that
/             the LENGTH and ATTRIB statements could be stored in a central
/             location where programmers can copy and paste the code into their
/             own data pooling programs. The aim is to ensure that the final
/             datasets have identical variables and attributes.
/
/             You can route the generated code to filerefs defined to lenfile=
/             (for the generated LENGTH assignment code) and attrfile= (for the
/             generated ATTR assignment and KEEP code). You can prefix the 
/             variable names if you need to.
/
/             You can create dummy datasets using this macro either based on an
/             existing dataset or based on a dataset of attributes (see dsattr=
/             parameter description). For this you would change the logfile=
/             setting to a different fileref and set dsset= to null to suppress
/             the SET statement. The fileref could then be %include'd in the
/             code to generate the dummy dataset.
/
/             If you use a dsattr= dataset then the structure of it should match
/             what you will find in SASHELP.VCOLUMN or DICTIONARY.COLUMNS and
/             not the structure of the output dataset from "proc contents".
/
/             See also the %dsattrib macro.
/
/ Usage     : %lstattrib(sasuser.demog);
/===============================================================================
/ TEST CODE FOLLOWS:
/===============================================================================

%lstattrib(sasuser.demog)

/===============================================================================
/ TEST OUTPUT FOLLOWS:
/===============================================================================

******  Attributes obtained from sasuser.demog  ******;
DATA xxxxxx;
  *- The order of the variables in the following LENGTH statement matches -;
  *- the variable order in the original dataset so do not change.         -;
  LENGTH dob 8 trtcd 8 sexcd 8 racecd 8 weight 8 height 8 patno 8 invid 8
         sitecd 8 fascd 8 age 8 trtcdx 8 trtsex 8
         ;

  *- The MERGE or SET statement for the input dataset(s) should go here.  -;
  SET yyyyyy;

  *- Overwrite the following missing values with what you are populating the  -;
  *- variables with. You may have to change the order of the variables where  -;
  *- there are dependencies such that the source variable is populated first. -;
  *- If you follow this method then when you get notes in the log about       -;
  *- uninitialised variables you will know that you are trying to populate a  -;
  *- variable with another variable that does not exist. You also avoid the   -;
  *- problem of spelling a variable name incorrectly when you assign a value  -;
  *- to it which can easily happen if there are a large number of variables.  -;

  dob    = .  ;
  trtcd  = .  ;
  sexcd  = .  ;
  racecd = .  ;
  weight = .  ;
  height = .  ;
  patno  = .  ;
  invid  = .  ;
  sitecd = .  ;
  fascd  = .  ;
  age    = .  ;
  trtcdx = .  ;
  trtsex = .  ;

  *- Cancel existing formats and informats in the input dataset(s) -;
  FORMAT   _all_ ;
  INFORMAT _all_ ;

  *- Assign output variable attributes -;
  ATTRIB
    age    format=3.                        label="AGE (YEARS)"
    dob    format=DATE9.  informat=DATE7.   label="DATE OF BIRTH"
    fascd  format=NY.     informat=COMMA13. label="FULL ANALYSIS SET (N/Y)"
    height format=5.1     informat=COMMA13. label="HEIGHT (CM)"
    invid                 informat=COMMA13. label="INVESTIGATOR ID"
    patno                 informat=COMMA13. label="PATIENT NUMBER"
    racecd format=RACECD. informat=COMMA13. label="RACE CODE"
    sexcd  format=SEXCD.  informat=COMMA13. label="GENDER CODE"
    sitecd                informat=COMMA13. label="SITE CODE"
    trtcd  format=TRTCD.  informat=COMMA13. label="TREATMENT REGIMEN"
    trtcdx format=TRTCDX.                   label=" "
    trtsex format=TRTSEX.                   label=
"GENDER/TREATMENT REGIMEN (1+2 female, 11+12 male)"
    weight format=5.1     informat=COMMA13. label="WEIGHT (KG)"
    ;

  *- KEEP statement for the variables listed above -;
  KEEP age dob fascd height invid patno racecd sexcd sitecd trtcd trtcdx
       trtsex weight
       ;
RUN;

/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) (unquoted) One-level or two-level dataset name
/ dsattr            Special dataset containing the variables "name, length,
/                   type, format, informat, label, varnum" to override using
/                   a dataset specified to the "ds" positional parameter. The
/                   structure of this should match dictionary.columns or
/                   sashelp.vcolumn and not be structure like a "proc contents"
/                   output dataset.
/ init=yes          Whether to initialise all the variables (default yes)
/ lenfile           Fileref of file to receive the LENGTH statement code
/                   (defaults to LOG)
/ attrfile          Fileref of file to receive the ATTRIB and KEEP statement
/                   code (defaults to LOG).
/ initfile          Fileref of file to receive the variable initialisation
/                   code (defaults to LOG. init=yes must be specified).
/ namepref          Prefix (no quotes) to add to the front of all the variable
/                   names.
/ dsset=yyyyyy      This is for the generated SET statement dataset. If set to
/                   null then no SET statement will be generated.
/ dsout=xxxxxx      This is for the generated DATA statement dataset
/ logfile=log       This is the destination for the normal full output. You can 
/                   reroute this to a file and %include it later to create a 
/                   dataset if need be.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Apr11         Comment in generated code changed
/ rrb  04May11         Code tidy
/ rrb  30Aug11         Code added such that all the variables are initialised
/                      with missing values (v2.0)
/ rrb  07Nov12         Many extra parameters and extra processing added (v3.0)
/ rrb  13Nov12         Code changed to accept both datasets and views (v3.1)
/ rrb  13Dec12         initfile= parameter added (v4.0)
/ rrb  03Jan13         format and informat variables generated as missing values
/                      for dsattr= dataset in case these are missing (v4.1)
/ rrb  26Mar13         Temp dataset prefix _attr replaced by _lstattr and _lens
/                      temp dataset replaced by _lstlens (v4.2)
/ rrb  02Apr13         Explanation of dsattr= structure added to header
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: lstattrib v4.2;

%macro lstattrib(ds,
                 dsattr=,
                 init=yes,
                 lenfile=,
                 attrfile=,
                 initfile=,
                 namepref=,
                 dsset=yyyyyy,
                 dsout=xxxxxx,
                 dslabel=,
                 logfile=log
                );

  %local lib dsname maxname maxformat maxinformat errflag err savopts;
  %let err=ERR%str(OR);
  %let errflag=0;

  %let savopts=%sysfunc(getoption(notes));

  %if not %length(&init) %then %let init=yes;
  %let init=%upcase(%substr(&init,1,1));

  %if %length(&ds) %then %do;
    %if not (%sysfunc(exist(&ds)) OR %sysfunc(exist(&ds,VIEW))) %then %do;
      %let errflag=1;
      %put &err: (lstattrib) Specified dataset &ds does not exist;
    %end;
    %if &errflag %then %goto exit;
    %if not %length(%scan(&ds,2,.)) %then %do;
      %let lib=%sysfunc(getoption(user));
      %if not %length(&lib) %then %let lib=work;
      %let lib=%upcase(&lib);
      %let dsname=%upcase(&ds);
    %end;
    %else %do;
      %let lib=%upcase(%scan(&ds,1,.));
      %let dsname=%upcase(%scan(&ds,2,.));
    %end;
  %end;

  options nonotes;


  %if %length(&dsattr) %then %do;
    data _lstattrx;
      length format informat $ 49;
      retain format informat " ";
      set &dsattr;
    run;
  %end;


  proc sql noprint;
    %if not %length(&dslabel) %then %do;
      %if %length(&ds) %then %do;
        select memlabel into :dslabel separated by " "
        from dictionary.tables
        where libname="&lib" and memname="&dsname";
      %end;
    %end;

    create table _lstattr as
    select name, length, type, format, informat, label, varnum
    %if NOT %length(&dsattr) %then %do;
      from dictionary.columns
      where libname="&lib" and memname="&dsname"
    %end;
    %else %do;
      from _lstattrx
    %end;
    order by name;

    create table _lstlens as
    select name, length, type, varnum
    from _lstattr
    order by varnum;

  %if %length(&namepref) %then %do;
    quit;
    data _lstattr;
      set _lstattr;
      name="&namepref"||name;
    run;
    data _lstlens;
      set _lstlens;
      name="&namepref"||name;
    run;
    proc sql noprint;
  %end;
    
    select max(length(name)), max(length(format)), max(length(informat))
    into :maxname, :maxformat, :maxinformat separated by " "
    from _lstattr;
  quit;
 
  data _null_;
    length _str _str2 $ 200 _allvars $ 4000 fvar $ 20;
    retain maxname &maxname maxformat &maxformat maxinformat &maxinformat
           _allvars;
    if _n_=1 then do;
      %IF %LENGTH(&lenfile) %THEN FILE &lenfile;
      %ELSE file &logfile;
      ;
      if maxformat=1 then maxformat=-8;
      if maxinformat=1 then maxinformat=-10;
      %IF NOT %LENGTH(&lenfile) %THEN %DO;
        put;
        put @1 "******  Attributes obtained from &ds&dsattr  ******;";
        %if %length(&dslabel) %then %do;
          _str="DATA &dsout(label='"||"&dslabel"||"');";
        %end;
        %else %do;
          _str="DATA &dsout;";
        %end;
        put @1 _str;
        put @3 "*- The order of the variables in the following LENGTH statement matches -;";
        put @3 "*- the variable order in the original dataset so do not change.         -;";
      %END;  
      put @3 "LENGTH " @;
      __i=1;
      _str=" ";
      do until(__i>_nobs);
        do until(length(_str)>60 or __i>_nobs);
          set _lstlens nobs=_nobs point=__i;
          if upcase(substr(type,1,1)) EQ "C" then _str2=trim(name)||" $ "||left(put(length,5.));
          else _str2=trim(name)||" "||left(put(length,5.));
          _str=trim(_str)||" "||_str2;
          __i=__i+1;
        end;
        put @10 _str;
        _str=" ";
      end;
      put @10 ";";
      %IF NOT %LENGTH(&lenfile) OR %LENGTH(&initfile) %THEN %DO;      
        put;
        %IF %LENGTH(&dsset) %THEN %DO;
put @3 "*- The MERGE or SET statement for the input dataset(s) should go here. -;";
          put @3 "SET &dsset;";
          put;
        %END;
        %IF &init NE N %THEN %DO;
          %IF NOT %LENGTH(&initfile) %THEN %DO;
put @3 "*- Overwrite the following missing values with what you are populating the  -;";
put @3 "*- variables with. You may have to change the order of the variables where  -;";
put @3 "*- there are dependencies such that the source variable is populated first. -;";
put @3 "*- If you follow this method then when you get notes in the log about       -;";
put @3 "*- uninitialised variables you will know that you are trying to populate a  -;";
put @3 "*- variable with another variable that does not exist. You also avoid the   -;";
put @3 "*- problem of spelling a variable name incorrectly when you assign a value  -;";
put @3 "*- to it which can easily happen if there are a large number of variables.  -;";
            put;
          %END;
          __i=1;
          _str=" ";
          %IF %LENGTH(&initfile) %THEN FILE &initfile;;
          do until(__i>_nobs);
            set _lstlens nobs=_nobs point=__i;
            if upcase(substr(type,1,1)) EQ "C" then _str="= ' ';";
            else _str='= .  ;';
            put @3 name @(maxname+4) _str;
            __i=__i+1;
          end;
          put;
        %END;  
      %END;
      %IF %LENGTH(&attrfile) %THEN FILE &attrfile;
      %ELSE file &logfile;
      ;
      put @3 "*- Cancel existing formats and informats in the input dataset(s) -;";
      put @3 "FORMAT   _all_ ;";
      put @3 "INFORMAT _all_ ;";
      put;
      put @3 "*- Assign output variable attributes -;";
      put @3 "ATTRIB" ;
    end; *- end of _n_=1 -;
    %IF %LENGTH(&attrfile) %THEN FILE &attrfile;
    %ELSE file &logfile;
    ;
    set _lstattr end=last;
    _allvars=trim(_allvars)||" "||name;

    if upcase(substr(type,1,1)) EQ "C" then _str="$"||trim(left(put(length,6.)));
    else _str=trim(left(put(length,6.)));
    put @5 name @;
    if format ne " " then put @(maxname+6) "format=" format @;
    if informat ne " " then put @(maxname+maxformat+14) "informat=" informat @;
    _str='"'||trim(tranwrd(label,'"','""'))||'"';
    put @(maxname+maxformat+maxinformat+24) "label=" _str @;
    put ;
    if last then do;
      put @5 ";" ;
      put;
      put @3 "*- KEEP statement for the variables listed above -;";
      put @3 "KEEP " @;
      scanidx=1;
      do until(scan(_allvars,scanidx," ")=" ");
        _str=" ";
        do until(scan(_allvars,scanidx," ")=" " or length(_str)>65);
          _str=trim(_str)||" "||scan(_allvars,scanidx," ");
          scanidx=scanidx+1;
        end;
        put @8 _str;
      end;
      put @8 ";" ;
      %IF NOT %LENGTH(&attrfile) %THEN %DO;
        put @1 "RUN;";     
      %END;
    end;
  run;
  %put;

  proc datasets nolist;
    delete _lstattr _lstlens
    %if %length(&dsattr) %then %do;
           _lstattrx
    %end;
    ;
  run;
  quit;

  options &savopts;

  %goto skip;
  %exit: %put &err: (lstattrib) Leaving macro due to problem(s) listed;
  %skip:

%mend lstattrib;
/*<pre><b>
/ Program   : lstlbls.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 19-Jan-2012
/ Purpose   : To list variables and their labels to the log
/ SubMacros : none
/ Notes     : Variables will be listed in alphabetical order
/ Usage     : %lstlbls(dsname(keep=aa bb cc dd),16);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset (can have modifiers such as a keep list)
/ labcol            (pos) Column to position the label (defaults to 20)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  19Jan12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: lstlbls v1.0;

%macro lstlbls(ds,labcol);

  %local savopts;
  %let savopts=%sysfunc(getoption(notes));

  options nonotes;

  %if not %length(&labcol) %then %let labcol=20;

  %PUT;

  proc contents noprint data=&ds out=_lstcont(keep=name label);
  run;

  data _null_;
    set _lstcont;
    put name @&labcol label;
  run;

  proc datasets nolist;
    delete _lstcont;
  run;
  quit;

  %PUT;

  options &savopts;

%mend lstlbls;/*<pre><b>
/ Program   : ltgtm1.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : In-datastep macro to turn a text numeric value into a numeric
/             value and handle "<" and ">" signs preceding and adjust the value
/             according to a rule (method 1).
/ SubMacros : none
/ Notes     : The numeric adjustment done where values beging with "<" or ">"
/             may not be the "standard" method for your site. You should
/             ascertain whether a standard method already exists for handling
/             this situation and use that method unless you have special cause
/             to use this macro. This should be used in a data step.
/
/             This macro name ends with "m1" to singify "method 1". If you want
/             to implement a different algorithm then create extra macros with
/             different method ending numbers.
/
/             The essence of the algorithm used here is to add one or subtract
/             one from the value for a '>' or '<' sign respectively but to take
/             into account the number of decimal places in the orginal text 
/             value. <1 will be set to 0.9 and >0 will be set to 0.1 .
/
/ Usage     : %ltgtm1(textvar,numvar);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ textvar           (pos) Text variable containing number
/ numvar            (pos) Numeric variable to contain result
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  28Sep08         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: ltgtm1 v1.0;

%macro ltgtm1(textvar,numvar);

  *- set up working variable -;
  length _tempstr $ 20 _sign $ 1;

  *- left-align original text and place into temporary variable -;
  _tempstr=compress(&textvar,' ');

  *- set preceding sign to blank -;
  _sign=' ';

  *- set sign if required and remove from source -;
  if substr(_tempstr,1,1) in ('<','>') then do;
    _sign=substr(_tempstr,1,1);
    _tempstr=substr(_tempstr,2);
  end;

  *- chop off spurious trailing characters -;
  if verify(_tempstr,'0123456789.,')>1 
    then _tempstr=substr(_tempstr,1,verify(_tempstr,'0123456789.,')-1);

  *- count number of decimal points -;
  if scan(_tempstr,2,'.')=' ' then _dp=0;
  else _dp=length(scan(_tempstr,2,'.'));

  *- set to numeric value -;
  &numvar=input(_tempstr,comma20.);

  *- treat for "<" sign -;
  if _sign='<' then do;
    if _dp=0 and &numvar in (1,0) then &numvar=&numvar-0.1;
    else &numvar=&numvar-10**-_dp;
  end;

  *- treat for ">" sign -;
  else if _sign='>' then do;
    if _dp=0 and &numvar in (0,-1) then &numvar=&numvar+0.1;
    else &numvar=&numvar+10**-_dp;
  end;

  *- drop temporary variables -;
  drop _dp _sign _tempstr;

%mend ltgtm1;
/*<pre><b>
/ Program   : makehash.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 01-May-2014
/ Purpose   : In-datastep macro to set up a hash object
/ SubMacros : %cvarlens %quotelst %commas
/ Notes     : This macro MUST be used in a data step as shown in the usage
/             notes. Note especially that this macro is called BEFORE the SET
/             statement.
/
/             A numeric variable named "_rc" that receives the return code is
/             created and can be dropped from the output dataset using a DROP
/             statement (see usage notes).
/             
/ Usage     : data test2;
/               %makehash(class,sashelp.class,name age,sex height weight);
/               set test;
/               %findinhash(class);
/               DROP _rc;
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ hashname          (pos) Name to give the hash object (unquoted)
/ ds                (pos) Dataset name (no modifiers)
/ keyvars           (pos) List of key variables separated by spaces
/ datavars          (pos) List of data variables separated by spaces
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Apr14         New (v1.0)
/ rrb  01May14         %cvarlens macro used in place of %varlens macro (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: makehash v1.1;

%macro makehash(hashname,ds,keyvars,datavars);
LENGTH %cvarlens(&ds,&datavars);
if _n_=1 then do;
  declare hash &hashname(dataset: "&ds");
  _rc = class.defineKey(%commas(%quotelst(&keyvars)));
  _rc = class.defineData(%commas(%quotelst(&datavars)));
  _rc = class.defineDone();
  call missing(%commas(&datavars));
end;
%mend makehash;
/*<pre><b>
/ Program   : match.sas
/ Version   : 4.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 21-Jun-2013
/ Purpose   : Function-style macro to return elements of a list that match those
/             in a reference list.
/ SubMacros : %words %nodup
/ Notes     : Non-matching list elements are returned in the global macro
/             variable _nomatch_ .
/ Usage     : %let match=%match(aa bb,aa cc);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ref               (pos) Space-delimited reference list
/ list              (pos) Space-delimited test list
/ nodup=yes         By default, remove duplicates from the list
/ casesens=no       By default, case sensitivity is not important.
/ fixcase=no        By default, do not make the case of matching items the same
/                   as the item in the reference list.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  19Mar07         Macro called message added plus header tidy
/ rrb  30Jul07         Header tidy
/ rrb  01May11         Code restructured and missing list allowed (v2.0)
/ rrb  03Dec12         Header tidy (%nodup added to submacro list)
/ rrb  25Apr13         Combined missing ref and missing list allowed (v3.0)
/ rrb  21Jun13         Logic changed such that now there are no error
/                      conditions and either or both the reference list and the
/                      test list can be null (v4.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: match v4.0;

%macro match(ref,list,nodup=yes,casesens=no,fixcase=no);
  %local list2 nref nlist i j item match refitem;

  %global _nomatch_;
  %let _nomatch_=;

  %if not %length(&nodup) %then %let nodup=yes;
  %if not %length(&casesens) %then %let casesens=no;
  %if not %length(&fixcase) %then %let fixcase=no;

  %let nodup=%upcase(%substr(&nodup,1,1));
  %let casesens=%upcase(%substr(&casesens,1,1));
  %let fixcase=%upcase(%substr(&fixcase,1,1));

  %if "&nodup" EQ "Y" %then %let list2=%nodup(&list,casesens=&casesens);
  %else %let list2=&list;

  %let nref=%words(&ref);
  %let nlist=%words(&list2);

  %if not &nref %then %do;
    %put NOTE: (match) No elements in reference list therefore no items will match;
    %let _nomatch_=&list2;
  %end;
  %else %do;
    %if not &nlist %then %do;
%put NOTE: (match) No elements in testing list therefore no items to match;
    %end;
    %else %do;
      %do i=1 %to &nlist;
        %let item=%scan(&list2,&i,%str( ));
        %let match=NO;
        %do j=1 %to &nref;
          %let refitem=%scan(&ref,&j,%str( ));
          %if "&casesens" EQ "N" %then %do;
            %if "%upcase(&item)" EQ "%upcase(&refitem)" %then %do;
              %let match=YES;
              %let j=&nref;
            %end;
          %end;
          %else %do;
            %if "&item" EQ "&refitem" %then %do;
              %let match=YES;
              %let j=&nref;
            %end;
          %end;
        %end;
        %if &match EQ YES %then %do;
          %if "&fixcase" EQ "N" %then &item;
          %else &refitem;
        %end;
        %else %let _nomatch_=&_nomatch_ &item;
      %end;
    %end;
  %end;

%mend match;
/*<pre><b>
/ Program   : maxtitle.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To find the highest number title and footnote and output to global
/             macro variables.
/ SubMacros : none
/ Notes     : The global macro variables used to hold the maximum for titles and
/             footnotes will be _maxtitle_ and _maxfoot_ .
/ Usage     : %maxtitles
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ quiet             (pos) Set this to anything to stop message at end
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: maxtitle v1.0;

%macro maxtitle(quiet);

  %global _maxtitle_ _maxfoot_;
  %let _maxtitle_=0;
  %let _maxfoot_=0;


  *- extract maximum title and footnote number from the vtitle view -;
  data _null_;
    retain maxtitle maxfoot 0;
    set sashelp.vtitle end=last;
    if type='T' then maxtitle=number;
    else if type='F' then maxfoot=number;
    if last then do;
      call symput('_maxtitle_',compress(put(maxtitle,2.)));
      call symput('_maxfoot_',compress(put(maxfoot,2.)));
    end;
  run;

  %if not %length(&quiet) %then %do;
    %put;
    %put MSG: (maxtitle) The following global macro variables have been set up;
    %put MSG: (maxtitle) and can be used in your code. ;
    %put _maxtitle_=&_maxtitle_;
    %put _maxfoot_=&_maxfoot_;
  %end;

%mend maxtitle;
/*<pre><b>
/ Program   : md5sum.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 12-Aug-2011
/ Purpose   : To write the md5 checksum to the log for a two-level dataset
/             stored on Unix or Linux.
/ SubMacros : %rcmd2log
/ Notes     : This macro is only for use in sas sessions where you can "rsubmit"
/             code to a remote server.
/
/             This is only intended for two-level dataset names stored on
/             Unix/Linux and uses the "md5sum" command run on the remote host.
/             Do not use it on WORK datasets.
/
/             It is a good idea to run this macro directly after creating a
/             dataset to write the checksum to the log so that you can check at
/             a later date that the dataset has not become corrupted (corruption
/             is more likely in proportion to the size of the dataset). 
/
/ Usage     : %md5sum(outads.basco)
/
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Two level dataset name. Do not use on work datasets.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  12Aug11         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: md5sum v1.0;

%macro md5sum(ds);
  %local hilvl lowlvl path filename str err;
  %let err=ERR%str(OR);
  %if "%scan(&ds,2,.)" EQ " " %then %do;
    %put &err: (md5sum) You must supply a two level dataset name ds=&ds;
    %goto exit;
  %end;
  %else %do;
    %if not %sysfunc(exist(&ds)) %then %do;
      %put &err: (md5sum) Dataset %upcase(&ds) does not exist;
      %goto exit;
    %end;
    %let hilvl=%scan(&ds,1,.);
    %let lolvl=%scan(&ds,2,.);
    %if %upcase(&hilvl) EQ WORK %then %do;
      %put &err: (md5sum) You must not use this on WORK datasets ds=&ds;
      %put &err: (md5sum) Use only on stored datasets on Unix/Linux;
      %goto exit;
    %end;
    %let path=%sysfunc(pathname(&hilvl));
    %let filename=%lowcase(&lolvl).sas7bdat;
    %let str=rcmd2log(md5sum &path/&filename);
    %put NOTE: (md5sum) %upcase(&ds) is stored as &path/&filename;
    %*- call the rcmd2log macro to display the md5sum in the log -;
    %&str;
  %end;
  %goto skip;
  %exit: %put &err: (md5sum) Leaving macro due to problem(s) listed;
  %skip:
%mend md5sum;
/*<pre><b>
/ Program   : misscnt.sas
/ Version   : 3.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 09-Apr-2013
/ Purpose   : To create a list of variables and their missing value count
/ SubMacros : %nvarsc %nvarsn
/ Notes     : Version 2.0 and beyond is not compatible with version 1.0 as it
/             uses named parameters keep= and drop= and no longer the positional
/             parameter "drop" that was used in version 1.0.
/
/             It is not possible to implement this as a function-style macro due
/             to the data step boundary so the results will be written to a
/             global macro variable which by default is named "_miss_". What you
/             do with the list created is entirely up to you. The variables with
/             a non-zero missing count will be listed directly followed by an
/             equals sign directly followed by the missing value count.
/             Variables with zero missing values are not listed.
/
/             You can define both a keep list of variables and a drop list of 
/             variables. If you define both then only the keep list will be used
/             and the drop list will have no effect.
/
/ Usage     : %misscnt(dsname,keep=&keeplist);
/             %misscnt(dsname,drop=&droplist);
/             %misscnt(dsname,dsout=_misscnt);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset to analyze (unmodified)
/ keep=             List of variables to keep
/ drop=             List of variable to drop (gets overridden by keep= if
/                   keep= is specified)
/ globvar=_miss_    Name of the global macro variable to contain the list of
/                   variables with their missing count.
/ dsout=            Optional output dataset containing fields "name" and "count"
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  04May11         Code tidy
/ rrb  03Dec12         Keep= and drop= named parameters added (v2.0)
/ rrb  06Dec12         NOTEs disabled and changed so that if a character
/                      variable equates to a single period when left aligned
/                      then it will also be regarded as a missing value (v2.1)
/ rrb  08Apr13         dsout= parameter added (v3.0)
/ rrb  09Apr13         Make the dsout= dataset a zero observation dataset if the
/                      missing count is zero for all variables (v3.1) 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: misscnt v3.1;

%macro misscnt(ds,
               keep=,
               drop=,
               globvar=_miss_,
               dsout=
              );

  %local i bit dsname nvarsn nvarsc savopts;

  %let savopts=%sysfunc(getoption(notes));
  options nonotes;

  %global &globvar;
  %let &globvar=;
  %let dsname=&ds;

  %if %length(&drop) or %length(&keep) %then %do;
    %let dsname=_misscnt;
    data _misscnt;
      set &ds
      %if %length(&keep) %then %do;
        (keep=&keep)
      %end;
      %else %if %length(&drop) %then %do;
        (drop=&drop)
      %end;
      ;
    run;
  %end;


  %let nvarsn=%nvarsn(&dsname);
  %let nvarsc=%nvarsc(&dsname);

  data _null_;
    %if &nvarsn GT 0 %then %do;
      array _nmiss {&nvarsn} 8 _temporary_ (&nvarsn*0);
    %end;
    %if &nvarsc GT 0 %then %do;
      array _cmiss {&nvarsc} 8 _temporary_ (&nvarsc*0);
    %end;
    SET &dsname END=LAST;
    %if &nvarsn GT 0 %then %do;
      array _num {*} _numeric_;
    %end;
    %if &nvarsc GT 0 %then %do;
      array _char {*} _character_;
    %end;
    %if &nvarsn GT 0 %then %do;
      do i=1 to &nvarsn;
        if _num(i) EQ . then _nmiss(i)=_nmiss(i)+1;
      end;
    %end;
    %if &nvarsc GT 0 %then %do;
      do i=1 to &nvarsc;
        if left(_char(i)) IN (' ' '.') then _cmiss(i)=_cmiss(i)+1;
      end;
    %end;
    if LAST then do;
      %if &nvarsn GT 0 %then %do;
        do i=1 to &nvarsn;
          if _nmiss(i) GT 0 then call execute('%let &globvar=&&&globvar '||
            trim(vname(_num(i)))||'='||compress(put(_nmiss(i),11.))||';');
        end;
      %end;
      %if &nvarsc GT 0 %then %do;
        do i=1 to &nvarsc;
          if _cmiss(i) GT 0 then call execute('%let &globvar=&&&globvar '||
            trim(vname(_char(i)))||'='||compress(put(_cmiss(i),11.))||';');
        end;
      %end;
    end;
  run;


  %if "&dsname" EQ "_misscnt" %then %do;
    proc datasets nolist;
      delete _misscnt;
    quit;
  %end;


  %if %length(&dsout) %then %do;
    data &dsout;
      length name $ 32 count 8;
      if 0=1 then output;
      %let i=1;
      %let bit=%scan(&&&globvar,&i,%str( ));
      %do %while(%length(&bit));
        name="%scan(&bit,1,=)";
        count=%scan(&bit,2,=);
        output;
        %let i=%eval(&i+1);
        %let bit=%scan(&&&globvar,&i,%str( ));
      %end;
    run;
  %end;

  options &savopts;

%mend misscnt;
/*<pre><b>
/ Program   : missvars.sas
/ Version   : 2.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 19-Jan-2012
/ Purpose   : To create a list of all-missing variables
/ SubMacros : %nvarsc %nvarsn
/ Notes     : It is not possible to implement this as a function-style macro due
/             to the data step boundary so the results will be written out to a
/             global macro variable. What you do with the list created is
/             up to you. You might report them as errors or warnings or you
/             could drop the variables from a dataset as shown in the usage
/             notes below.
/ Usage     : %missvars(dsname);
/             run;
/             data dsname;
/               set dsname(drop=&_miss_);
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset (pos) (must be pure dataset name and have no keep,
/                   drop, where or rename associated with it).
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  11Nov09         Name of global macro variables _miss_ and _nonmiss_ now
/                      fixed. All-missing variable name list written to _miss_
/                      and other variables names written to _nonmiss_ (v2.0)
/ rrb  04May11         Code tidy
/ rrb  19Jan12         NOTEs disabled and changed so that if a character
/                      variable equates to a single period when left aligned
/                      then it will also be regarded as a missing value (v2.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: missvars v2.1;

%macro missvars(ds);

  %local nvarsn nvarsc savopts;
  %global _miss_ _nonmiss_;

  %let savopts=%sysfunc(getoption(notes));
  options nonotes;

  %let _miss_=;
  %let _nonmiss_=;

  %let nvarsn=%nvarsn(&ds);
  %let nvarsc=%nvarsc(&ds);

  data _null_;
    %if &nvarsn GT 0 %then %do;
      array _nmiss {&nvarsn} $ 1 _temporary_ (&nvarsn*'1');
    %end;
    %if &nvarsc GT 0 %then %do;
      array _cmiss {&nvarsc} $ 1 _temporary_ (&nvarsc*'1');
    %end;
    set &ds end=last;
    %if &nvarsn GT 0 %then %do;
      array _num {*} _numeric_;
    %end;
    %if &nvarsc GT 0 %then %do;
      array _char (*) _character_;
    %end;
    length _miss_ _nmiss_ $ 32767;
    retain _miss_ _nmiss_ " ";
    %if &nvarsn GT 0 %then %do;
      do i=1 to &nvarsn;
        if _num(i) NE . then _nmiss(i)='0';
      end;
    %end;
    %if &nvarsc GT 0 %then %do;
      do i=1 to &nvarsc;
        if left(_char(i)) NOT IN (' ' '.') then _cmiss(i)='0';
      end;
    %end;
    if last then do;
      %if &nvarsn GT 0 %then %do;
        do i=1 to &nvarsn;
          if _nmiss(i) EQ '1' then _miss_=trim(_miss_)||" "||vname(_num(i));
          else _nmiss_=trim(_nmiss_)||" "||vname(_num(i));
        end;
      %end;
      %if &nvarsc GT 0 %then %do;
        do i=1 to &nvarsc;
          if _cmiss(i) EQ '1' then _miss_=trim(_miss_)||" "||vname(_char(i));
          else _nmiss_=trim(_nmiss_)||" "||vname(_char(i));
        end;
      %end;
      call symput('_miss_',left(trim(_miss_)));
      call symput('_nonmiss_',left(trim(_nmiss_)));
    end;
  run;

  options &savopts;

%mend missvars;
/*<pre><b>
/ Program   : mkformat.sas
/ Version   : 2.3
/ Author    : Roland Rashleigh-Berry
/ Date      : 19-Jun-2013
/ Purpose   : To create a format out of "coded" and "decoded" variables for the 
/             specified dataset.
/ SubMacros : %hasvars %varlen %nobs %dequote
/ Notes     : Use this to generate a format from a coded and decoded variable so
/             that you can report it in coded order but have it displayed in its
/             decoded form by applying the generated format.
/
/             Your code and decode variables should not have the name "start" or
/             "label".
/
/             If your input dataset has zero observations then it will generate
/             a single obseration of missing values as input. You will receive
/             no warning in this situation. "Other" processing will still apply
/             in these cases.
/
/             You have to correctly choose your format name which should start
/             with a dollar sign for character formats, should not be more than
/             eight characters long (including the dollar) and should not end in
/             a number as ending in a number is invalid.
/
/ Usage     : %mkformat(dsname(where=(x>1)),varcd,vardcd,fmtname,fmtcat);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Input dataset (one or two level)
/ code              (pos) Coded variable name
/ decode            (pos) Decoded variable name
/ fmtname           (pos) Format name to generate
/ lib               (pos) Catalog library libref for writing the generated
/                   format to (defaults to work).
/ notes=no          By default, do not write NOTEs to the log
/ fmtnotes=yes      By default, write notes to the log about whether the format
/                   was created or not.
/ other=            Set to a value (quoted or unquoted) as the label for OTHER
/ indent=0          Number of spaces to indent the label
/ underscore=no     Whether to use underscore characters before and after the
/                   label (will override indent= if set to yes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  19Mar07         Macro called message added plus header tidy
/ rrb  30Jul07         Header tidy
/ rrb  19Jan11         Allow modifiers in input dataset specification (v1.2)
/ rrb  30Nov11         indent= parameter added (v1.3)
/ rrb  21Dec11         underscore= processing added (v1.4)
/ rrb  02Jan12         Notes disabled (v1.5)
/ rrb  01Aug12         New version (compatible with the old version) which
/                      allows you to show notes in the log, adds "other"
/                      processing and allows for empty input datasets (v2.0)
/ rrb  28Mar13         Parameter fmtnotes=yes added to activate "notes" just for
/                      the proc format step no matter what the setting for
/                      notes= so the user can see whether the format was created
/                      or not (v2.1)
/ rrb  04Jun13         Check for repeats and warn of any found and just use
/                      the first one (v2.2)
/ rrb  19Jun13         Test for the existence of a VIEW as well (v2.3)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: mkformat v2.3;

%macro mkformat(ds,
                code,
                decode,
                fmtname,
                lib,
                notes=no,
                fmtnotes=yes,
                other=,
                indent=,
                underscore=no);

  %local errflag err wrn len savopts;
  %let err=ERR%str(OR);
  %let wrn=WAR%str(NING);

  %let errflag=0;
  %if not %length(&notes) %then %let notes=no;
  %let notes=%upcase(%substr(&notes,1,1));

  %let savopts=%sysfunc(getoption(notes));
  %if &notes NE Y %then %do;
    options nonotes;
  %end;

  %if not %length(&fmtnotes) %then %let fmtnotes=yes;
  %let fmtnotes=%upcase(%substr(&fmtnotes,1,1));

  %if not %sysfunc(exist(%scan(&ds,1,%str(%()))) 
  and not %sysfunc(exist(%scan(&ds,1,%str(%()),VIEW)) %then %do;
    %put &err: (mkformat) Dataset or view &ds does not exist;
    %let errflag=1;
  %end;

  %let fmtname=%sysfunc(compress(&fmtname,.));
  %if not %length(&fmtname) %then %do;
    %put &err: (mkformat) You must supply a format name;
    %let errflag=1;
  %end;
  %else %if %sysfunc(prxmatch('\d$',&fmtname)) %then %do;
    %put &err: (mkformat) Format name must not end in a number fmtname=&fmtname;
    %let errflag=1;    
  %end;

  %if &errflag %then %goto exit;


  %if not %length(&indent) %then %let indent=0;

  %if not %length(&underscore) %then %let underscore=no;
  %let underscore=%upcase(%substr(&underscore,1,1));

  data _mkfmt;
    *-- force an obs if dataset is empty --;
    %if %nobs(&ds) EQ 0 %then output;;
    set &ds;
  run;

  %if not %hasvars(_mkfmt,&code &decode) %then %do;
    %put &err: (mkformat) Dataset &ds does not contain variable(s) &_nomatch_;
    %let errflag=1;
  %end;

  %if &errflag %then %goto exit;


  proc sort nodupkey data=_mkfmt(keep=&code &decode)
                      out=_mkfmt(rename=(&code=start &decode=label));
    by &code &decode;
  run;


  *- warn if there are repeats -;
  data _null_;
    set _mkfmt;
    by start;
    if not (first.start and last.start) then 
put "&wrn: (mkformat) Repeats found - only the first will be used " start= label=;
  run;


  *- keep only the first if there is a repeat -;
  data _mkfmt;
    set _mkfmt;
    by start;
    if first.start;
  run;



  %let len=%varlen(_mkfmt,label,x);
  %if &underscore EQ Y or &indent GT 0 
   %then %let len=%eval(&len+%sysfunc(max(2,&indent)));

  data _mkfmt;
    length label $ &len;
    retain fmtname "&fmtname";
    set _mkfmt 
    %if %length(&other) %then %do;
         end=last
    %end;
    ;
    %if &underscore EQ Y %then %do;
      label="_"||trim(label)||"_";
    %end;
    %else %if &indent GT 0 %then %do;
      label=repeat(" ",%eval(&indent-1))||label;
    %end;
    output;
    *--- if user put in a value for other, compile this block ---*;
    %if %length(&other) %then %do;
      if last then do;
        hlo='O';
        label="%dequote(&other)";
        output;
      end;
    %end;
  run;

  %if &fmtnotes NE N %then %do;
    options notes;
  %end;

  proc format cntlin=_mkfmt
    %if %length(&lib) %then %do;
      library=&lib
    %end;
    ;
  run;

  %if &notes NE Y %then %do;
    options nonotes;
  %end;

  proc datasets nolist;
    delete _mkfmt;
  run;
  quit;

  %goto skip;
  %exit: %put &err: (mkformat) Leaving macro due to problem(s) listed;
  %skip:

  options &savopts;

%mend mkformat;
/*<pre><b>
/ Program   : mkordinfmt.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 26-Oct-2011
/ Purpose   : To create a numeric informat to map character strings to an
/             ordering rank value.
/ SubMacros : none
/ Notes     : The value you assign to fmtname= must not end in a number. For
/             alphabetical order do not use the ordvar= parameter.
/ Usage     : %mkordinfmt(fmtname=lvl,dsin=test,var=str,ordvar=order)
/             %mkordinfmt(fmtname=lvl,dsin=test,var=str)
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ fmtname           Format name (must not end in a number)
/ dsin              Input dataset
/ var               Character variable whose values will be mapped to a rank
/ ordvar            Existing ordering variable in the input dataset that defines
/                   the order of the "var" character variable (optional - do not
/                   use for alphabetical order).
/ other=9999        By default, values not mapped are given the rank of 9999
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Oct11         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: mkordinfmt v1.0;

%macro mkordinfmt(fmtname=,dsin=,var=,ordvar=,other=9999);
  %local savopts;
  %let savopts=%sysfunc(getoption(notes));
  options nonotes;
  %let fmtname=%sysfunc(compress(&fmtname,.));
  data _mkord;
    set &dsin;
    keep &ordvar &var;
  run;
  proc sort nodupkey data=_mkord;
    by &ordvar &var;
  run;
  data _mkord(rename=(&var=start));
    retain fmtname "&fmtname" type "I";
    set _mkord end=last;
    label=_n_;
    output;
    if last then do;
      label=&other;
      hlo="O";
      output;
    end;
  run;
  proc format cntlin=_mkord;
  run;
  proc datasets nolist;
    delete _mkord;
  run;
  quit;
  options &savopts;
%mend mkordinfmt;
/*<pre><b>
/ Program   : mksharemac.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 02-Jun-2014
/ Purpose   : To create a shared macro catalog under the WORK library location
/             with the libref SHAREMAC and catalog name SASMACR and optionally
/             copy a list of compiled macros across from WORK.SASMACR to this
/             library.
/ SubMacros : none
/ Notes     : This macro follows the convention for sharing resources with
/             remote sessions as explained on the web site where this macro is
/             stored (see the page on "Managing your Multiprocessing Sessions").
/             You are expected to pass the libref SHAREMAC over to the remote
/             session in the INHERITLIB() option either by using the %rsubmitter
/             macro or by following the same conventions in that macro.
/
/             The list of macros to copy is optional. This can be done manually
/             at a later stage instead.
/
/ Usage     : %mksharemac(mymac1 mymac2)
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ copy              (pos - optional) List of compiled macro names separated by
/                   spaces that you want to copy to the shared macro library.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  02Jun14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: mksharemac v1.0;

%macro mksharemac(copy);

  %local path;

  *- Create a directory under WORK to store shared macros in   -;
  *- (use a different slash depending on the operating system) -;

  %if %sysfunc(subpad(&sysscp,1,3)) EQ WIN %then
    %let path=%sysfunc(pathname(work))\macros; 
  %else %let path=%sysfunc(pathname(work))/macros; 


  *- issue command to create the directory and wait -;
  systask command "mkdir ""&path"" " taskname=mkdir; 


  *- make sure the shared macros directory creation has ended -; 
  waitfor mkdir; 

  
  *- give the shared macros library the libref "sharemac" -; 
  libname sharemac "&path"; 


  *- Copy the list of macros from WORK.SASMACR to SHAREMAC.SASMACR   -;
  *- (this is an optional step - you might want to do this manually) -;
  %if %length(&copy) %then %do;
    *- copy locally compiled macros to the shared macros catalog -; 
    proc catalog c=work.sasmacr et=macro; 
      copy out=sharemac.sasmacr; 
      select &copy; 
    quit; 
  %end;

%mend mksharemac;
/*<pre><b>
/ Program   : modte.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the last modification datetime
/             stamp of a dataset.
/ SubMacros : %attrn
/ Notes     : This is a shell macro that calls %attrn
/ Usage     : %let modte=%modte(dsname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name
/ format            (pos) Format to use for output. This will default to nothing
/                   giving you the decimal fraction of the number of thousandths
/                   of a second since 01jan1960 but you can supply the usual
/                   formats if you like.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: modte v1.0;

%macro modte(ds,format);
  %local modte;
  %let modte=%attrn(&ds,modte);
  %if %length(&format) %then %do;
    %if %index(%upcase(&format),DATE) 
    and not %index(%upcase(&format),DATETIME) %then %do;
%sysfunc(putn(%sysfunc(datepart(&modte)),&format))
    %end;
    %else %do;
%sysfunc(putn(&modte,&format))
    %end;
  %end;
  %else %do;
&modte
  %end;
%mend modte;
/*<pre><b>
/ Program   : mtype.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the member type of a dataset
/             (i.e. whether DATA or VIEW).
/ SubMacros : %attrc
/ Notes     : This is a shell macro that calls %attrc
/ Usage     : %let mtype=%mtype(dsname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: mtype v1.0;

%macro mtype(ds);
%attrc(&ds,mtype)
%mend mtype;
/*<pre><b>
/ Program   : mvarlist.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return a list of macro variable names
/             satisfying the supplied scope.
/ SubMacros : none
/ Notes     : All macro variable names returned will be in uppercase. If no
/             scope name is supplied then the scope will be set to GLOBAL. The
/             supplied scope name can be lower or upper case because it will be
/             converted to upper case automatically.
/ Usage     : %macro dummy(a=123,b=345,c=);
/               %let setparmlist=%mvarlist(dummy,s);
/             %mend dummy;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ scopename         (pos) Name of the scope of the macro variables (no quotes)
/                   such as GLOBAL or MACRONAME. Value will be converted to
/                   upper case. If left blank then "GLOBAL" is used.
/ contents          (pos - no quotes) Default is "any" macro variables with the
/                   supplied scope but you can specify "empty" or "set" to
/                   select on macro variables with no assigned values or only
/                   macro variables with assigned values. Only the first
/                   character is inspected so "a"="any", "e"="empty" and
/                   "s"="set".
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: mvarlist v1.0;

%macro mvarlist(scopename,contents);

  %local dsid rc name namenum value valuenum mvarlist contents2 err;
  %let err=ERR%str(OR);
  %let mvarlist=;

  %if not %length(&scopename) %then %let scopename=GLOBAL;
  %else %let scopename=%upcase(&scopename);

  %if not %length(&contents) %then %let contents=any;
  %let contents2=%upcase(%substr(&contents,1,1));
  %if not %index(ASE,&contents2) %then %do;
    %put &err: (mvarlist) Expected "any", "empty" or "set" but you supplied "&contents";
    %goto exit;
  %end; 

  %let dsid=%sysfunc(open(sashelp.vmacro(where=(scope="&scopename")),is));
  %if &dsid EQ 0 %then %do;
    %put &err: (mvarlist) sashelp.vmacro not opened due to the following reason:;
    %put %sysfunc(sysmsg());
    %goto exit;
  %end;
  %else %do;
    %let namenum=%sysfunc(varnum(&dsid,name));
    %let valuenum=%sysfunc(varnum(&dsid,value));
  %end;

  %readloop:
    %let rc=%sysfunc(fetch(&dsid));
    %if &rc %then %goto endoff;
    %let name=%sysfunc(getvarc(&dsid,&namenum));
    %let value=%sysfunc(getvarc(&dsid,&valuenum));
    %if &contents2 EQ A %then %let mvarlist=&mvarlist &name;
    %else %if &contents2 EQ S %then %do;
      %if %length(&value) %then %let mvarlist=&mvarlist &name;
    %end;
    %else %if &contents2 EQ E %then %do;
      %if not %length(&value) %then %let mvarlist=&mvarlist &name;
    %end;
  %goto readloop;


  %endoff:
&mvarlist
  %let rc=%sysfunc(close(&dsid));


  %goto skip;
  %exit: %put &err: (mvarlist) Leaving macro due to problem(s) listed;
  %skip:

%mend mvarlist;
/*<pre><b>
/ Program      : mvarvalues.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : Lists and resolves macro variables one per line for a supplied
/                macro variable list.
/ SubMacros    : %words
/ Notes        : On each line, a macro variable name will be shown followed by
/                " = " followed by the resolved macro variable. You have the
/                option to place the characters you define to the quotewithin=
/                parameter both before and after every resolved value for
/                greater clarity, especially where there is the possibility of
/                leading and trailing spaces. If you put the value of mvarlist
/                in single quotes then these quotes will be stripped
/                automatically by this macro. Single quotes should be used if
/                what you supply to mvarlist= is a macro expression. See usage
/                notes.
/ Usage        : %mvarvalues(&mvarlist,*);
/                %mvarvalues('%mvarlist(dummy9,a)',**);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ mvarlist          (pos) List of macro variables separated by spaces. You can
/                   put the whole thing in single quotes and you should use
/                   single quotes if what you supply to this parameter is a
/                   macro expression. See usage notes. 
/ quotewithin       (pos) Character or string of characters to surround the 
/                   resolved macro variable value.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: mvarvalues v1.0;

%macro mvarvalues(mvarlist,quotewithin);

  %*- strip start and trailing single quotes of mvarlist if present -;
  %if %length(&mvarlist) %then %do;
    %if %qsubstr(&mvarlist,1,1) EQ %str(%') 
    and %qsubstr(&mvarlist,%length(&mvarlist),1) EQ %str(%') %then %do;
      %let mvarlist=%unquote(%qsubstr(&mvarlist,2,%length(&mvarlist)-2));
    %end;
  %end;

  %local i name;

  %do i=1 %to %words(&mvarlist);
    %let name=%scan(&mvarlist,&i,%str( ));
    %put &name = %str(&quotewithin)%superq(&name)%str(&quotewithin);
  %end;

%mend mvarvalues;
/*<pre><b>
/ Program   : mysasautos.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 28-May-2014
/ Purpose   : Function-style macro to return the user's SASAUTOS setting but
/             with any double quotes translated to single quotes.
/ SubMacros : none
/ Notes     : Use this macro to ensure that when you resolve your SASAUTOS
/             setting within a double quoted string that you do not mess up the
/             syntax due to unknown double quotes being present around file path
/             names. Double quotes are converted to single quotes. Any commas
/             will be kept as they are.
/
/ Usage     : rsubmit wait=no process1 inheritlib=(work=lwork) 
/             sascmd="!sascmd -sasuser work -noautoexec -sasautos %mysasautos";
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ N/A
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  28May14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: mysasautos v1.0;

%macro mysasautos;
%sysfunc(translate(%sysfunc(getoption(sasautos)),%str(%'),%str(%")))
%mend mysasautos;
/*<pre><b>
/ Program   : nlobs.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the number of logical observations
/             (i.e. not marked for deletion) in a dataset or view. This will 
/             either be a positive integer or forced to zero.
/ SubMacros : none
/ Notes     : If a where clause is specified or the dataset is really a view 
/             then to count the number of observations, a forced read is done 
/             of the dataset using NLOBSF which can be slow for large datasets.
/             The where clause should be specified using the normal data step
/             style. See usage notes.
/ Usage     : %put >>>>>> %nlobs(sashelp.class) >>>>;
/             %put >>>>>> %nlobs(sashelp.class(where=(sex="M"))) >>>>;
/             %put >>>>>> %nlobs(sashelp.vtable) >>>>;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name (pos) (a where clause modifier is allowed)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  12Feb07         "macro called" message added
/ rrb  07May08         Version 2.0 allows for a where clause modifier
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: nlobs v2.0;

%macro nlobs(ds);
  %local nlobs dsid rc err;
  %let err=ERR%str(OR);
  %let dsid=%sysfunc(open(&ds));
  %*---- if open fails then file handle value is zero -----;
  %if &dsid EQ 0 %then %do;
    %put &err: (nlobs) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %*---- Open worked so check for an active where clause or a  ----;
  %*---- view and use NLOBSF in that case, otherwise use NLOBS. ----;
  %else %do;
    %if %sysfunc(attrn(&dsid,WHSTMT)) or
      %sysfunc(attrc(&dsid,MTYPE)) EQ VIEW %then %let nlobs=%sysfunc(attrn(&dsid,NLOBSF));
    %else %let nlobs=%sysfunc(attrn(&dsid,NLOBS));
    %*-- close the dataset --;
    %let rc=%sysfunc(close(&dsid));
    %*-- reset negative values to zero --;
    %if &nlobs LT 0 %then %let nlobs=0;
    %*-- return the result --;
&nlobs
  %end;
%mend nlobs;
/*<pre><b>
/ Program   : nobs.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the number of observations in a
/             dataset or view. This will either be a positive integer or forced
/             to zero.
/ SubMacros : none
/ Notes     : If a where clause is specified or the dataset is really a view 
/             then to count the number of observations, a forced read is done 
/             of the dataset using NLOBSF which can be slow for large datasets.
/             The where clause should be specified using the normal data step
/             style. See usage notes.
/ Usage     : %put >>>>>> %nobs(sashelp.class) >>>>;
/             %put >>>>>> %nobs(sashelp.class(where=(sex="M"))) >>>>;
/             %put >>>>>> %nobs(sashelp.vtable) >>>>;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name (pos) (a where clause modifier is allowed)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  12Feb07         "macro called" message added
/ rrb  07May08         Version 2.0 allows for a where clause modifier
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: nobs v2.0;

%macro nobs(ds);

  %local nobs dsid rc err;
  %let err=ERR%str(OR);

  %let dsid=%sysfunc(open(&ds));

  %*---- if open fails then file handle value is zero -----;
  %if &dsid EQ 0 %then %do;
    %put &err: (nobs) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;

  %*---- Open worked so check for an active where clause or a  ----;
  %*---- view and use NLOBSF in that case, otherwise use NOBS. ----;
  %else %do;
    %if %sysfunc(attrn(&dsid,WHSTMT)) or
      %sysfunc(attrc(&dsid,MTYPE)) EQ VIEW %then %let nobs=%sysfunc(attrn(&dsid,NLOBSF));
    %else %let nobs=%sysfunc(attrn(&dsid,NOBS));
    %*-- close the dataset --;
    %let rc=%sysfunc(close(&dsid));
    %*-- reset negative values to zero --;
    %if &nobs LT 0 %then %let nobs=0;
    %*-- return the result --;
&nobs
  %end;

%mend nobs;
/*<pre><b>
/ Program   : nocommas.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 27-May-2014
/ Purpose   : Function-style macro to translate commas into spaces
/ SubMacros : none
/ Notes     : No attempt is made to "tidy up" after the commas have been
/             translated into spaces. A simple replacement of every comma with a
/             space is performed. This macro can be used inside another macro
/             call to remove commas before the outer macro start to work.
/
/             This macro should not use the parameter= convention. It should be
/             used with a purely positional parameter value only.
/
/ Usage     : %let str=aa, bb, cc;
/             %put >>> %nocommas(&str);
/             >>> aa  bb  cc
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (only positional) String to translate commas into spaces
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  27May14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: nocommas v1.0;

%macro nocommas/parmbuff;
%qsubstr(%sysfunc(translate(&syspbuff,%str( ),%str(,))),2,%length(&syspbuff)-2)
%mend nocommas;
/*<pre><b>
/ Program   : nodup.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to drop duplicates in a space-delimited list
/ SubMacros : %words
/ Notes     : 
/ Usage     : %let str=%nodup(aaa bbb aaa);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ list              (pos) space-delimited list of items
/ casesens=no       Case sensitive. no by default.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: nodup v1.0;

%macro nodup(list,casesens=no);

  %local i j match item errflag err;
  %let err=ERR%str(OR);
  %let errflag=0;
  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));

  %if not %index(YN,&casesens) %then %do;
    %put &err: (nodup) casesens must be set to yes or no;
    %let errflag=1;
  %end;

  %if &errflag %then %goto exit;

  %do i=1 %to %words(&list);
    %let item=%scan(&list,&i,%str( ));
    %let match=NO;
    %if &i LT %words(&list) %then %do;
      %do j=%eval(&i+1) %to %words(&list);
        %if &casesens EQ Y %then %do;
          %if "&item" EQ "%scan(&list,&j,%str( ))" %then %let match=YES;
        %end;
        %else %do;
          %if "%upcase(&item)" EQ "%upcase(%scan(&list,&j,%str( )))" %then %let match=YES;
        %end;
      %end;
    %end;
    %if &match EQ NO %then &item;
  %end;

  %goto skip;
  %exit: %put &err: (nodup) Leaving macro due to problem(s) listed;
  %skip:

%mend nodup;
  /*<pre><b>
/ Program   : nodupkey.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To sort "nodupkey" but list observations being dropped so that
/             they can be investigated and accounted for.
/ SubMacros : %sortedby %attrn
/ Notes     : This is for where all observations that are dropped will need to
/             be accounted for.
/ Usage     : %nodupkey(ds,var1 var2 var3)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsin              (pos) Dataset to be sorted.
/ by                (pos) List of "by" variables to sort by.
/ dsout             (pos) Output dataset. Will default to input dataset if not
/                   specified.
/ msg=WARNING       Message to put out with the listed duplicates
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  28Sep08         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: nodupkey v1.0;

%macro nodupkey(dsin,by,dsout,msg=WARNING);

  %local errflag err;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&dsin) %then %do;
    %let errflag=1;
    %put &err: (nodupkey) No parameter define to dsin=;
  %end;

  %if &errflag %then %goto exit;

  %if not %length(&dsout) %then %let dsout=%scan(&dsin,1,%str(%());
  %if not %length(&by) %then %let by=%sortedby(%scan(&dsin,1,%str(%()));

  %if not %length(&by) %then %do;
    %let errflag=1;
    %put &err: (nodupkey) No parameter define to by=;
  %end;

  %if &errflag %then %goto exit;

  proc sort data=&dsin out=_nodup;
    by &by;
  run;

  data &dsout _nodup;
    set _nodup;
    by &by;
    if first.%scan(&by,-1,%str( )) then output %scan(&dsout,1,%str(%());
    else output _nodup;
  run;

  data _null_;
    set _nodup;
    if _n_=1 then put "&msg: (nodupkey) The following %attrn(_nodup,nobs)
observations were dropped after a nodup sort by ""&by"" ";
    put (_all_) (=);
  run;

  proc datasets nolist;
    delete _nodup;
  run;
  quit;

  %goto skip;
  %exit: %put &err: (nodupkey) Leaving macro due to problem(s) listed;
  %skip:

%mend nodupkey;
/*<pre><b>
/ Program   : noquotes.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to remove all quoted strings from a macro
/             expression.
/ SubMacros : none
/ Notes     : This gets rid of all quoted strings and returns what is left.
/ Usage     : %let noquotes=%noquotes(&str);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: noquotes v1.0;

%macro noquotes(str);

  %local i pos1 pos2 qtype tempstr;
  %let tempstr=&str;

  %redo:

  %let pos1=0;
  %let pos2=0;
  %let qtype=;

  %do i=1 %to %length(&tempstr);
    %if &pos1 EQ 0 %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(%')
       or %qsubstr(&tempstr,&i,1) EQ %str(%") %then %do;
        %let pos1=&i;
        %let qtype=%qsubstr(&tempstr,&i,1);
      %end;
    %end;
    %else %if (&pos1 GT 0) and (&pos2 EQ 0) %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(&qtype) %then %let pos2=&i;
    %end;
  %end; 

  %if (&pos1 GT 0) and (&pos2 GT 0) %then %do;
    %if (&pos1 GT 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1)%qsubstr(&tempstr,&pos2+1);
    %else %if (&pos1 EQ 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,&pos2+1);
    %if (&pos1 GT 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1);
    %else %if (&pos1 EQ 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=;
    %if %length(&tempstr) %then %goto redo;
  %end;

&tempstr

%mend noquotes;
/*<pre><b>
/ Program   : now.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 19-Mar-2013
/ Purpose   : Function-style macro to return the current timestamp
/ SubMacros : none
/ Notes     : This macro is just a shorter way of writing what it contains
/             which is the syntax for resolving the current datetime as a macro
/             expression.
/ Usage     : %put Stage1: %now;
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ fmt               Datetime format to use (default is datetime21.2)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/ rrb  19Mar13         Changed default format to datetime21.2 (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: now v1.1;

%macro now(fmt=datetime21.2);
%sysfunc(datetime(),&fmt)
%mend now;
/*<pre><b>
/ Program   : numchars.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To create a list of character variables that contain numeric-like
/             text.
/ SubMacros : %nvarsc
/ Notes     : It is not possible to implement this as a function-style macro due
/             to the data step boundary so the results will be written out to a
/             global macro variable. You can use this list in the char2num macro
/             that converts character fields to numeric fields. This macro uses
/             the verify function with the test string '0123456789., ' to test
/             for numeric-like entries which is not a perfect test. Using this
/             test then if a field is character and all-missing then it will be
/             assumed to be a possible numeric field.
/ Usage     : %numchars(dsname,globvar=_numchars_);
/             %put ######## &_numchars_;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset (pos) (must be pure dataset name and have no keep,
/                   drop, where or rename associated with it).
/ globvar=_numchars_    Name of the global macro variable to set up to contain
/                   the list of all-missing variables.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: numchars v1.0;

%macro numchars(ds,globvar=_numchars_);

  %local err;
  %let err=ERR%str(OR);

  %global &globvar;
  %let &globvar=;

  %let nvarsc=%nvarsc(&ds);

  %if &nvarsc EQ 0 %then %do;
    %put &err: (numchars) Data set &ds does not contain any character variables;
    %goto exit;
  %end;


  data _null_;
    array _num {&nvarsc} $ 1 _temporary_ (&nvarsc*'1');
    set &ds end=last;
    array _char (*) _character_;
    do i=1 to &nvarsc;
      if verify(_char(i),'0123456789., ') then _num(i)='0';
    end;
    if last then do;
      do i=1 to &nvarsc;
        if _num(i) EQ '1' then call execute('%let &globvar=&&&globvar '||
          trim(vname(_char(i)))||';');
      end;
    end;
  run;

  %goto skip;
  %exit: %put &err: (numchars) Leaving macro due to problem(s) listed;
  %skip:

%mend numchars;
/*<pre><b>
/ Program   : nvars.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the number of variables in a
/             dataset.
/ SubMacros : %attrn
/ Notes     : This is a shell macro that calls %attrn
/ Usage     : %let nvars=%nvars(dsname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: nvars v1.0;

%macro nvars(ds);
  %attrn(&ds,nvars)
%mend nvars;
/*<pre><b>
/ Program   : nvarsc.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the number of character variables
/             in a dataset.
/ SubMacros : %varlistc %words
/ Notes     : 
/ Usage     : %let nvarsc=%nvarsc(dsname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: nvarsc v1.0;

%macro nvarsc(ds);
  %words(%varlistc(&ds))
%mend nvarsc;
/*<pre><b>
/ Program   : nvarsn.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the number of numeric variables in
/             a dataset.
/ SubMacros : %varlistn %words
/ Notes     : 
/ Usage     : %let nvarsn=%nvarsn(dsname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: nvarsn v1.0;

%macro nvarsn(ds);
  %words(%varlistn(&ds))
%mend nvarsn;
/*<pre><b>
/ Program   : optlength.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 02-Apr-2013
/ Purpose   : To create an optimized LENGTH statement for character variables
/             that take up less length than that allotted to the variables.
/ SubMacros : %nvarsc
/ Notes     : This macro is useful for saving space taken up by uncompressed
/             datasets. It will read through the entire dataset to detect the
/             maximum length actually used by every character variables and
/             where this is less than the allotted length will generate a
/             syntactically correct LENGTH statement and write it to a global
/             macro variable such that it can be resolved in a subsequent data
/             step to adjust the length of the variables (see usage notes).
/
/             A "drop" modifier can be assigned to the dataset such that some
/             variables can be excluded from this optimization calculation such
/             as --TESTCD variables (see usage notes).
/
/             If all character variables are already of optimum length then the
/             global macro variable will contain a null string which will have
/             no effect in a subsequent automatic optimizing data step (if used
/             as shown in the usage notes).
/
/             This macro writes changed lengths out to a dataset in addition to
/             writing to a global macro variable. This is to allow the user more
/             control for keeping the variable order the same as the original
/             since the output dataset can be used to update a "contents" style
/             dataset which can then be used to generate a data structure using
/             the %lstattrib macro and so maintain the original order of the
/             variables.
/
/ Usage     : %optlength(dset(drop=vstestcd));
/             data dset2;
/               &_optlength_;
/               set dset;
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsin              (pos) Input dataset
/ globvar=_optlength_     Name of global macro variable.
/ dsout=_optlens          Output dataset 
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  02Apr13         dsout= parameter added so that changed lengths are also
/                      written to a dataset with variable names "name", "length"
/                      and "old_length" (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: optlength v2.0;

%macro optlength(dsin,globvar=_optlength_,dsout=_optlens);

  %local nvarsc wrn savopts;
  %let wrn=WAR%str(NING);
  %let savopts=%sysfunc(getoption(NOTES));
  options nonotes;

  %if not %length(&globvar) %then %let globvar=_optlength_;
  %global &globvar;
  %let &globvar=;

  %if not %length(&dsout) %then %let dsout=_optlens;

  %let nvarsc=%nvarsc(%scan(&dsin,1,%str(%()));

  %if not &nvarsc %then %do;
    %put &wrn: (optlength) No character variables detected in &dsin so macro will exit;
    %goto exit;
  %end;

  data &dsout(rename=(_name=name _newlen=length _oldlen=old_length));
    set &dsin end=last;
    array _char {*} _character_;
    length _name $ 32 _oldlen _newlen 8;
    length _str $ 32767;
    array _length {&nvarsc} 8 _temporary_ (&nvarsc*1);
    do _i=1 to dim(_char);
      if length(_char(_i))>_length(_i) then _length(_i)=length(_char(_i));
    end;
    if last then do;
      _str='LENGTH';
      do _i=1 to dim(_char);
        _name=vname(_char(_i));
        _oldlen=vlength(_char(_i));
        _newlen=_length(_i);
        if _newlen<_oldlen then do;
          _str=trim(_str)||' '||trim(_name)||' $ '||compress(put(_newlen,5.));
          output;
        end;
      end;
      if _str NE 'LENGTH' then call symput("&globvar",trim(_str));
    end;
    KEEP _name _oldlen _newlen;
  run;

  *- sort in name order for later update purposes -;
  proc sort data=&dsout;
    by name;
  run;

  %exit:

  options &savopts;

%mend optlength;
/*<pre><b>
/ Program   : optvarlen.sas
/ Version   : 1.2
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-Apr-2013
/ Purpose   : To create an output dataset with the same variable order as the
/             input dataset but with character variables reduced to their
/             optimum length such that they are long enough to hold the longest
/             value but no longer.
/ SubMacros : %dsattr %optlength %quotelst %dslabel
/ Notes     : Specify variables you do not want optimized to the notvars=
/             parameter (variable names will be ignored if not present in the
/             input dataset).
/
/             You can specify modifiers with the input dataset (such as a drop
/             list) and this will be processed before variable optimization.
/             If the output dataset is specified without modifiers then it will
/             be assigned the dataset label of the input dataset (if it exists).
/
/             A practical use for this macro (and why it was written) is to
/             achieve a single step SDTM Plus to SDTM conversion. The drop
/             variables could be written to a macro variable and resolved as
/             a drop list modifier for the input dataset in the call to this
/             macro and the output SDTM dataset would have these variables
/             dropped with the remaining variables in the same relative order as
/             the input dataset plus all the character fields optimised for
/             length with selected fields such as --TESTCD unchanged if desired.
/             &domain.TESTCD could be used as a notvars= variable for all
/             domains because if the variable does not exist in the domain it
/             will be ignored.
/
/ Usage     : %optvarlen(sashelp.class,classattr);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsin              (pos) (unquoted) One-level or two-level input dataset name
/                   (modifiers allowed).
/ dsout             (pos) (unquoted) One-level or two-level output dataset name
/ notvars           List of variable names separated by spaces where you do not
/                   want the variable lengths to be changed.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  03Apr13         New (v1.0)
/ rrb  04Apr13         Modifiers allowed for input dataset plus output dataset
/                      assigned the label of the input dataset (v1.1)
/ rrb  04Apr13         Minor bugs fixed (v1.2)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: optvarlen v1.2;

%macro optvarlen(dsin,dsout,notvars=);

  %local sasvge92 err errflag savopts dslabel;
  %let err=ERR%str(OR);
  %let errflag=0;


  %if not %length(&dsin) %then %do;
    %let errflag=1;
    %put &err: (optvarlen) No input dataset specified as the first positional parameter;
  %end;

  %if not %length(&dsout) %then %do;
    %let errflag=1;
    %put &err: (optvarlen) No output dataset specified as the second positional parameter;
  %end;

  %if &errflag %then %goto exit;


  %let savopts=%sysfunc(getoption(NOTES));
  options nonotes;


  *- assume all variable names will be upcase -;
  %let notvars=%upcase(&notvars);


  *- store the input dataset label -;
  %let dslabel=%dslabel(%scan(&dsin,1,%str(%()));


  %if %index(&dsin,%str(%()) %then %do;
    *- allow modifiers to take effect -;
    data _optvds;
      set &dsin;
    run;
    %let dsin=_optvds;
  %end;


  *- detect if user is using sas 9.2 or later -;
  %if %sysevalf(&sysver GE 9.2) %then %let sasvge92=1;
  %else %let sasvge92=0;


  *- get variable info -;
  %dsattr(&dsin,dsout=_optvin);


  *- calculate optimum lengths -;
  %optlength(&dsin,dsout=_optvlens);


  *- drop optimum lengths for selected variables -;
  %if %length(&notvars) %then %do;
    data _optvlens;
      set _optvlens;
      where name not in (%quotelst(&notvars));
    run;
  %end;


  *- use the output from optlength to update the variable info -;
  data _optvnew;
    update _optvin _optvlens;
    by name;
  run;


  *- assign filerefs to receive length and other code from lstattrib -;
  filename _optvlen TEMP;
  filename _optjunk TEMP;


  *- call lstattrib to write the length code -;
  %lstattrib(dsattr=_optvnew,lenfile=_optvlen,attrfile=_optjunk);


  *- switch off variable length warnings -;
  %if &sasvge92 %then options varlenchk=nowarn;;


  *- apply the length code and create the output dataset -;
  data &dsout
    %if %length(&dslabel) and not %length(%scan(&dsout,2,%str(%())) %then %do;
      (label="&dslabel")
    %end;
    ;
    %include _optvlen;
    set &dsin;
  run;


  *- switch back on variable length warnings -;
  %if &sasvge92 %then options varlenchk=warn;;


  *- clear the filerefs -;
  filename _optvlen CLEAR;
  filename _optjunk CLEAR;


  *- delete work datasets -;
  proc datasets nolist;
    delete _optvin _optvlens _optvnew
    %if "&dsin" EQ "_optvds" %then %do;
           _optvds
    %end;
    ;
  run;
  quit;


  *- restore incoming notes option -;
  options &savopts;


  %goto skip;
  %exit: %put &err: (optvarlen) Leaving macro due to problem(s) listed;
  %skip:

%mend optvarlen;/*<pre><b>
/ Program   : partialdates.sas
/ Version   : 2.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : In-datastep macro to impute partial dates to a high or low value
/ SubMacros : none
/ Notes     : This macro will accept partial dates in a range of formats defined
/             to the pattern= parameter and impute the date either on the "low"
/             value or "high" value possible as defined to the lohi= parameter
/             given the partial information. Note that many internal variables
/             are created and dropped by this macro. You should ensure that
/             their names do not cause a conflict with existing dataset names.
/             You are free to change these variable names if you need to by
/             resetting the parameters.
/
/             If the year is missing then a missing date will be returned.
/
/ Usage     : data test;
/               datestr="--feb08";
/               %partialdates(datetext=datestr,datevar=date,pattern="ddmmmyy",
/                             lohi=high);
/               format date date9.;
/               put date= datestr=;
/             run;
/             29FEB2008
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ datetext          Name of variable or quoted string literal containing the
/                   date text.
/ datevar           Output SAS date variable (supply your own format)
/ pattern           (quoted) Pattern of the date. Year must be specified as YY
/                   or YYYY. Month specified as MMM for three letter character
/                   month or MM for two digit month. Day of month specified as
/                   MM for the two digit day of the month. Examples are 
/                   "ddmmmyy", "ddmmmyyyy", "dd/mm/yyyy", "dd/mm/yy" (case is
/                   not important). This can be an unquoted character variable
/                   instead for where the pattern varies.
/ lohi=low          (unquoted) Whether to take the lower or higher value of the
/                   possible range of dates. Defaults to "low". You should only
/                   use "low" or "high" (unquoted). Only the first character
/                   will be used for recognition.
/
/                   THE FOLLOWING ARE THE NAMES OF THE TEMPORARY VARIABLES THAT
/                   WILL BE USED IN THIS MACRO AND DROPPED. Change any that might
/                   conflict with your input dataset variable names. Other
/                   temporary variables used and dropped are "dummytext" and
/                   "dummydate".
/
/ yearvar=_year
/ monthvar=_month
/ dayvar=_day
/ yposvar=_ypos
/ ylenvar=_ylen
/ mposvar=_mpos
/ mlenvar=_mlen
/ dposvar=_dpos 
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  09Jul08         lohivar= and patternvar= parameters dropped. All retains
/                      dropped. Pattern can now be a variable as well as a
/                      quoted string for v2.0.
/ rrb  10Jul08         Bug in year length fixed
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: partialdates v2.1;

%macro partialdates(datetext=,
                     datevar=,
                     pattern=,
                        lohi=low,
                     yearvar=_year,
                    monthvar=_month,
                      dayvar=_day,
                     yposvar=_ypos,
                     ylenvar=_ylen,
                     mposvar=_mpos,
                     mlenvar=_mlen,
                     dposvar=_dpos               
                     );

  %local err;
  %let err=ERR%str(OR);

  %let lohi=%upcase(%substr(&lohi,1,1));


  *- set up and retain year, month and day positions and their lengths -;
  &yposvar=index(upcase(&pattern),"YYYY");
  &ylenvar=4;
  if &yposvar<1 then do;
    &yposvar=index(upcase(&pattern),"YY");
    &ylenvar=2;
  end;
  if &yposvar<1 then do;
    _ERROR_=1;
    put "&err: (partialdates) No YY or YYYY found in supplied date pattern " &pattern;
  end;
  &mposvar=index(upcase(&pattern),"MMM");
  &mlenvar=3;
  if &mposvar<1 then do;
    &mposvar=index(upcase(&pattern),"MM");
    &mlenvar=2;
  end;
  if &mposvar<1 then do;
    _ERROR_=1;
    put "&err: (partialdates) No MM or MMM found in supplied date pattern " &pattern;
  end;
  &dposvar=index(upcase(&pattern),"DD");
  if &dposvar<1 then do;
    _ERROR_=1;
    put "&err: (partialdates) No DD found in supplied date pattern " &pattern;
  end;


  *- get the year which might be a four digit or two digit year -;
  if &ylenvar=4 then &yearvar=input(substr(upcase(&datetext),&yposvar,4),?? 4.);
  else do;
    *- temporarily set to the raw two digit year -;
    &yearvar=input(substr(&datetext,&yposvar,2),?? 2.);
    *- now get the 4 digit year with yearcutoff applied if not missing -;
    if not missing(&yearvar) then do;
      dummytext="01JAN"||substr(&datetext,&yposvar,2);
      dummydate=input(dummytext,date7.);
      &yearvar=year(dummydate);
    end;
  end;

  *- if the year is missing then set the date to missing else carry on -;
  if missing(&yearvar) then &datevar=.;
  else do;

    *- get the month which might be 3 letters or a 2 digit number -;
    if &mlenvar=3 then do;
      dummytext="01"||substr(upcase(&datetext),&mposvar,3)||"99";
      dummydate=input(dummytext,?? date7.);
      if missing(dummydate) then do;
        if "&lohi"="L" then &monthvar=1;
        else &monthvar=12;
      end;
      else &monthvar=month(dummydate);
    end;
    else &monthvar=input(substr(&datetext,&mposvar,2),?? 2.);
    if missing(&monthvar) then do;
      if "&lohi"="L" then &monthvar=1;
      else &monthvar=12;
    end;

    *- get the day which will be a 2 digit number -;
    &dayvar=input(substr(&datetext,&dposvar,2),?? 2.);
    if missing(&dayvar) then do;
      if "&lohi"="L" then &dayvar=1;
      else &dayvar=day(intnx("month",mdy(&monthvar,1,&yearvar),1)-1);
    end;

    &datevar=mdy(&monthvar,&dayvar,&yearvar);

  end;

  drop &yposvar &ylenvar &mposvar &mlenvar &dposvar dummytext dummydate;

%mend partialdates;
/*<pre><b>
/ Program   : prefix.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 12-Jun-2011
/ Purpose   : Function-style macro to return a list with a prefix added.
/ SubMacros : none
/ Notes     : Items in matching quotes are treated as single elements
/ Usage     : %let preflist=%prefix(C:\mylib\,fname1 "fname 2" fname3);
/             
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ prefix            (pos) Text to prefix each item with (unquoted)
/ list              (pos) List of items to prefix (separated by spaces)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: prefix v1.0;

%macro prefix(prefix,list);
  %local i bit;
  %let i=1;
  %let bit=%sysfunc(scanq(&list,&i,%str( )));
  %do %while(%length(&bit));
&prefix.&bit
    %let i=%eval(&i+1);
    %let bit=%sysfunc(scanq(&list,&i,%str( )));
  %end;
%mend prefix;

/*<pre><b>
/ Program   : printall.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To print every observation in a library where a variable satisfies
/             a specified condition.
/ SubMacros : none
/ Notes     : You can only use conditional operators =<>: and the conditional
/             must be bracketed with %str() to stop the macro thinking the
/             = sign refers to a parameter.
/ Usage     : %printall(work,%str(num>1))
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ libname           (pos) Libref.
/ cond              (pos) Conditional statement. Variable must come first and be
/                   the only variable specified. Allowed operators are =<>: You
/                   must enclose this in a %str() declaration otherwise the =
/                   sign makes the macro think it is a parameter. Literals in
/                   character conditionals must be enclosed in single quotes.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26May03         Added local cond2 for compressing quotes out of character
/                      conditionals so title line works and added further
/                      instructions for cond= parameter.
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: printall v1.0;

%macro printall(libname,cond);

  %local var cond2 err;
  %let err=ERR%str(OR);
  %if not %length(&libname) %then %let libname=%sysfunc(getoption(user));
  %if not %length(&libname) %then %let libname=work;

  %if not %length(&cond) %then %do;
    %put &err: (printall) No conditional specified to cond parameter;
    %goto skip;
  %end;

  %let var=%scan(&cond,1,%str( =<>));
  %let cond2=%sysfunc(compress(&cond,%str(%'%")));

  options formdlim='-';

  data _null_;
    set sashelp.vcolumn(where=(libname="%upcase(&libname)" and name="&var"));
    call execute('proc print data='||trim(libname)||'.'||trim(memname)||
  "(where=(&cond));");
    call execute('title "WHERE &cond2 - ALL DATA IN '||
  trim(libname)||'.'||trim(memname)||'";run;');
  run;

  %skip:

%mend printall;
/*<pre><b>
/ Program   : prxnames.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 01-Feb-2011
/ Purpose   : Function-style macro to convert a space-delimited list of sas
/             names (variable or dataset names) to a Pearl Regular Expression
/             for use in the prxmatch() function that takes into account the
/             ending colon notation.
/ SubMacros : none
/ Notes     : All sas names will be converted to upper case. Names such as "d:"
/             will match strings such as "D", "DABC", "D123". If the string
/             "aaa b:" (no quotes) is supplied then this will be converted
/             to the regular expression "/^AAA *$|^B.* *$/" which signifies a
/             regular expression (enclosed in "//") starting with ("^") "AAA"
/             and ending with ("$") zero or more spaces (" *") OR ("|") starting
/             with "B" followed by zero or more characters (".*") ending with
/             zero or more spaces.
/ Usage     : %let dslist=var1 var2 vx:;
/             ....where prxmatch(%prxnames(&dslist),memname);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) sas variable or dataset names separated by spaces with
/                   the ending colon notation allowed to represent sas names
/                   that start with what precedes the colon (no quotes).
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: prxnames v1.0;

%macro prxnames(str);
"/^%sysfunc(tranwrd(%sysfunc(tranwrd(%sysfunc(compbl(%upcase(&str))),%str( ),
%str( *$|^))),:,.*)) *$/"
%mend prxnames;
/*<pre><b>
/ Program   : putvars.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 31-Jul-2007
/ Purpose   : To list variables in a dataset suffixed with an equals sign
/             suitable for a "put" statement written to the log.
/ SubMacros : %quotelst %varlist
/ Notes     : This uses %quotelst and %varlist to do all the work. You would
/             typically use this to list out all variables and their contents to
/             the log given an unexpected condition.
/ Usage     : put %putvars(ds);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset to list variables from.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: putvars v1.0;

%macro putvars(ds);
%quotelst(%varlist(&ds),quote=,delim=%str(= ))=
%mend putvars;
/*<pre><b>
/ Program   : qcompress.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 23-Sep-2011
/ Purpose   : Function-style macro to compress a macro variable string and
/             return the result MACRO QUOTED.
/ SubMacros : none
/ Notes     : 
/ Usage     : %let tidy=%qcompress(&string);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos) String to compress.
/ ref               (pos) Reference characters to remove from the string.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  08May11         Code tidy
/ rrb  23Sep11         Header tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: qcompress v1.0;

%macro qcompress(string,ref);
  %local i errflag err;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&string) %then %goto skip;

  %if not %length(&ref) %then %do;
    %put &err: (qcompress) No reference characters supplied to compress string with;
    %let errflag=1;
  %end;

  %if &errflag %then %goto exit;

%qsysfunc(compress(&string,&ref))

  %goto skip;
  %exit: %put &err: (qcompress) Leaving macro due to problem(s) listed;
  %skip:
%mend qcompress;
  /*<pre><b>
/ Program      : qdequote.sas
/ Version      : 1.3
/ Author       : Roland Rashleigh-Berry
/ Date         : 16-Nov-2011
/ Purpose      : Function-style macro to remove front and end matching quotes
/                from a macro string and return the result MACRO QUOTED.
/ SubMacros    : none
/ Notes        : This is a function-style macro. The resulting expression will
/                be MACRO QUOTED so you will have to use the %unquote() function
/                if you are using the results in sas code. See usage notes.
/ Usage        : %let str=%qdequote(%qreadpipe(echo '%username%'));
/                CLASS %unquote(%qdequote('&trtvar')) ;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ N/A
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  30Jul07         Header tidy
/ rrb  19Jan08         Note added in header about macro quoting
/ rrb  31Oct08         Purpose in header updated 
/ rrb  01Jan09         Use %qtrim() instead of %quote()
/ rrb  12Oct09         Macro renamed from dequote to qdequote (v1.2)
/ rrb  04May11         Code tidy
/ rrb  16Nov11         Bug when str is "" fixed (v1.3)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: qdequote v1.3;

%macro qdequote(str);
  %if (%qsubstr(&str,1,1) EQ %str(%') and %qsubstr(&str,%length(&str),1) EQ %str(%'))
  or (%qsubstr(&str,1,1) EQ %str(%") and %qsubstr(&str,%length(&str),1) EQ %str(%"))
  %then %do;
    %if %length(&str) LE 2 %then %qtrim();
    %else %qsubstr(&str,2,%length(&str)-2);
  %end;
  %else %qtrim(&str);
%mend qdequote;
/*<pre><b>
/ Program      : qdosfileinfo.sas
/ Version      : 1.1
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : Function-style macro to return information about a DOS file
/                and return the result MACRO QUOTED.
/ SubMacros    : %qreadpipe
/ Notes        : A list of modifiers that give different pieces of DOS file
/                information can be got by typing in the command "for /?".
/                Use the single character modifier immediately following the "~"
/                to give you the piece of file information that you need such as
/                "z" for file size.
/                %~I         - expands %I removing any surrounding quotes (")
/                %~fI        - expands %I to a fully qualified path name
/                %~dI        - expands %I to a drive letter only
/                %~pI        - expands %I to a path only
/                %~nI        - expands %I to a file name only
/                %~xI        - expands %I to a file extension only
/                %~sI        - expanded path contains short names only
/                %~aI        - expands %I to file attributes of file
/                %~tI        - expands %I to date/time of file
/                %~zI        - expands %I to size of file
/ Usage        : %let filesize=%qdosfileinfo(C:\spectre\unistats.html,z);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dosfile           (pos) DOS file name
/ modifier          (pos) Modifier (single character no quotes) to give the
/                   piece of file information that you need.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  30Jul07         Header tidy
/ rrb  12Oct09         Macro renamed from dosfileinfo to qdosfileinfo and call
/                      changed from %readpipe to %qreadpipe due to macro
/                      renaming (v1.1)
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: qdosfileinfo v1.1;

%macro qdosfileinfo(dosfile,modifier);
  %local A;
  %let A=%nrstr(%A);
%qreadpipe(for &A in (&dosfile) do @echo %~&modifier.A)
%mend qdosfileinfo;
/*<pre><b>
/ Program      : qgetenv.sas
/ Version      : 1.1
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : Function-style macro to get the contents of a system or user
/                environment variable and return the result MACRO QUOTED.
/ SubMacros    : %qreadpipe
/ Notes        : Works for Windows and Unix/Linux platforms. If not Windows then
/                a Unix style method of echoing the environment variable using a
/                dollar sign is assumed (i.e. echo $envvar is assumed to work).
/                The result is MACRO QUOTED. If you wish to use the results in
/                normal sas code then you must %unquote() the result. Note that
/                unlike the %sysget macro function, this macro will not give a
/                warning if the environment variable does not exist. Instead a 
/                null string is returned. In the case of Windows then if the
/                first character is a "%" then it is assumed that the
/                environment variable was not resolved and a null string is
/                returned.
/ Usage        : %let newvar=%qgetenv(uservar);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ envvar            (pos) Name of environment variable (unquoted)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  12Oct09         Macro renamed from getenv to qgetenv (v1.1)
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: qgetenv v1.1;

%macro qgetenv(envvar);
  %local tempres;
  %if "&sysscp" EQ "WIN" %then %do;
    %let tempres=%qreadpipe(echo %nrbquote(%str(%%)%superq(envvar)%str(%%)));
    %*- if it did not resolve then set to null -;
    %if "%qsubstr(%superq(tempres),1,1)" EQ "%" %then %let tempres=;
  %end;
  %else %let tempres=%qreadpipe(echo $&envvar);
&tempres
%mend qgetenv;
/*<pre><b>
/ Program   : qreadpipe.sas
/ Version   : 2.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 23-Sep-2011
/ Purpose   : Function-style macro to read the output of a system command and
/             return the result trimmed and MACRO QUOTED.
/ SubMacros : %qtrim
/ Notes     : Result will be MACRO QUOTED. Use %unquote to make the string 
/             output usable in ordinary sas code.
/ Usage     : %let mvar=%qreadpipe(echo $USER);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ command           (pos) System command. This should not be enclosed in quotes
/                   but may be enclosed in %str(), %quote() etc..
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  22Jul07         Header tidy
/ rrb  30Jul07         Header tidy
/ rrb  31Oct08         Major redesign for v2.0
/ rrb  12Oct09         Macro renamed from readpipe to qreadpipe (v2.1)
/ rrb  04May11         Code tidy
/ rrb  23Sep11         Header tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: qreadpipe v2.1;

%macro qreadpipe(command);
  %local fname fid str rc res err;
  %let err=ERR%str(OR);
  %let rc=%sysfunc(filename(fname,&command,pipe));
  %if &rc NE 0 %then %do;
    %put &err: (qreadpipe) Pipe file could not be assigned due to the following:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let fid=%sysfunc(fopen(&fname,s,80,b));
    %if &fid EQ 0 %then %do;
  %put &err: (qreadpipe) Pipe file could not be opened due to the following:;
  %put %sysfunc(sysmsg());
    %end;
    %else %do;
      %do %while(%sysfunc(fread(&fid)) EQ 0);
        %let rc=%sysfunc(fget(&fid,str,80));
        %let res=&res%superq(str);
      %end;
%qtrim(&res)
      %let rc=%sysfunc(fclose(&fid));
      %if &rc NE 0 %then %do;
  %put &err: (qreadpipe) Pipe file could not be closed due to the following:;
  %put %sysfunc(sysmsg());
      %end;
      %let rc=%sysfunc(filename(fname));
      %if &rc NE 0 %then %do;
  %put &err: (qreadpipe) Pipe file could not be deassigned due to the following:;
  %put %sysfunc(sysmsg());
      %end;
    %end;
  %end;
%mend qreadpipe;
/*<pre><b>
/ Program   : quotecnt.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to count quoted strings in a macro expression
/ SubMacros : none
/ Notes     : This returns the number of quoted strings.
/ Usage     : %let count=%quotecnt(&str);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message and header tidy
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: quotecnt v1.0;

%macro quotecnt(str);

  %local i pos1 pos2 qtype tempstr count;
  %let tempstr=&str;
  %let count=0;

  %redo:

  %let pos1=0;
  %let pos2=0;
  %let qtype=;

  %do i=1 %to %length(&tempstr);
    %if &pos1 EQ 0 %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(%')
       or %qsubstr(&tempstr,&i,1) EQ %str(%") %then %do;
        %let pos1=&i;
        %let qtype=%qsubstr(&tempstr,&i,1);
      %end;
    %end;
    %else %if (&pos1 GT 0) and (&pos2 EQ 0) %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(&qtype) %then %let pos2=&i;
    %end;
  %end; 

  %if (&pos1 GT 0) and (&pos2 GT 0) %then %do;
    %let count=%eval(&count + 1);
    %if (&pos1 GT 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1)%qsubstr(&tempstr,&pos2+1);
    %else %if (&pos1 EQ 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,&pos2+1);
    %if (&pos1 GT 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1);
    %else %if (&pos1 EQ 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=;
    %if %length(&tempstr) %then %goto redo;
  %end;

&count

%mend quotecnt;  /*<pre><b>
/ Program   : quotelst.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to quote the elements of a list
/ SubMacros : none
/ Notes     : DO NOT COPY AND PASTE THIS FROM THIS BROWSER WINDOW. YOU MUST USE
/             THE "VIEW" PULL-DOWN WINDOW AND USE "SOURCE". This is because the
/             browser will change some of the characters in this file to quotes.
/
/             This is useful to turn a list into a quoted list so that you can
/             use the in() function on it in a data step. Also, if you search for
/             a quoted string among a list of quoted strings then you can avoid
/             matching on a subset of a single element. Note that you can change
/             not only the quote mark but the delimiter as well so you can use
/             this macro for other purposes like putting commas between variable
/             names etc. It is assumed that the elements of the list are
/             delimited by spaces.
/ Usage     : %if %index(%quotelst(varnames),"varname") %then...
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               String to quote elements of (pos)
/ quote=%str(%")    Quote character to use (defaults to double quotation mark)
/ delim=%str( )     Delimiter character to use (defaults to a space)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  21May08         Use of %scan replaced by %qscan
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: quotelst v1.1;

%macro quotelst(str,quote=%str(%"),delim=%str( ));
  %local i quotelst;
  %let i=1;
  %do %while(%length(%qscan(&str,&i,%str( ))) GT 0);
    %if %length(&quotelst) EQ 0 %then %let quotelst=&quote.%qscan(&str,&i,%str( ))&quote;
    %else %let quotelst=&quotelst.&quote.%qscan(&str,&i,%str( ))&quote;
    %let i=%eval(&i + 1);
    %if %length(%qscan(&str,&i,%str( ))) GT 0 %then %let quotelst=&quotelst.&delim;
  %end;
%unquote(&quotelst)
%mend quotelst;
/*<pre><b>
/ Program   : quotescan.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to scan for a quoted string in a macro
/             expression.
/ SubMacros : none
/ Notes     : The quoted string will still have its quote marks around it.
/             A null string will be returned if there is nothing quoted.
/             Note that any string returned will be macro-quoted so you should
/             put it inside %unquote() if using the output in normal sas code.
/ Usage     : %let scan=%quotescan(&str,2);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/ pos               (pos) Position
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  28May07         Header tidy
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: quotescan v1.0;

%macro quotescan(str,pos);

  %local i pos1 pos2 qtype tempstr count qstr;
  %let tempstr=&str;
  %let count=0;
  %if not %length(&pos) %then %let pos=1;
  %redo:

  %let pos1=0;
  %let pos2=0;
  %let qtype=;

  %do i=1 %to %length(&tempstr);
    %if &pos1 EQ 0 %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(%')
       or %qsubstr(&tempstr,&i,1) EQ %str(%") %then %do;
        %let pos1=&i;
        %let qtype=%qsubstr(&tempstr,&i,1);
      %end;
    %end;
    %else %if (&pos1 GT 0) and (&pos2 EQ 0) %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(&qtype) %then %let pos2=&i;
    %end;
  %end; 

  %if (&pos1 GT 0) and (&pos2 GT 0) %then %do;
    %let count=%eval(&count + 1);
    %let qstr=%qsubstr(&tempstr,&pos1,%eval(&pos2-&pos1+1));
    %if (&pos1 GT 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1)%qsubstr(&tempstr,&pos2+1);
    %else %if (&pos1 EQ 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,&pos2+1);
    %if (&pos1 GT 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1);
    %else %if (&pos1 EQ 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=;
    %if (&count LT &pos) and %length(&tempstr) %then %goto redo;
  %end;

  %if &count EQ &pos %then &qstr;

%mend quotescan;  /*<pre><b>
/ Program   : rafootnote.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To right-align a footnote for a pure text output
/ SubMacros : %lrafootnote
/ Notes     : This is for pure text output listings and tables. For other types 
/             of output you can use j=right or .j=right in the footnote
/             statement to achieve right-alignment.
/ Usage     : %rafootnote(5,"This footnote 5 will be right-aligned")
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ num               (pos) Number of footnote
/ text              (pos) Text of footnote (must be in quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: rafootnote v1.0;

%macro rafootnote(num,text);
  %lrafootnote(&num,,&text)
%mend rafootnote;
/*<pre><b>
/ Program      : rannomac.sas
/ Version      : 2.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : Compile Roland's annotate macros
/ SubMacros    : none
/ Notes        : This is Roland's version of the SI supplied macro %annomac that
/                makes available the annotate macros for use in a data step to
/                help create an annotate dataset.
/
/                Note that except for %drawline the macros defined below draw
/                shapes that lie parallel to the x-axis only hence all the
/                macros use a single "y" parameter but use two "x" parameters
/                "x1" and "x2" to indicate the start and end x coordinates
/                (except for the %text and %box macros which only have one x
/                coordinate).
/
/                This macro must be used like %annomac in that it should be
/                called outside a data step to compile the macros whose macros
/                definitions are contained within before they can be used in a
/                data step.
/
/                The macros defined below do not call any of the SI supplied
/                annotate macros but you are expected to mix use with the SI
/                supplied annotate macros as needed (see usage notes below).
/
/                All macro parameters are named parameters, unlike the SI
/                supplied annotate macros which use positional parameters.
/
/                The values supplied to the parameters can be VARIABLE NAMES in
/                all cases in which case you have to make sure they are of the
/                correct type (numeric or character) and if character then of
/                sufficient length. The variable names you supply and use to
/                hold the values should be named differently to the annotate
/                dataset variable names (see the %dclannovars macro below for
/                a list of these variable names).
/
/                In your annotate data step you must define a length for the
/                "HTML" character variable long enough to contain your longest
/                assignment (if you are using this variable for html
/                "hotspots"). Recommended is the maximum allowed length of
/                1024. This is automatically set in the %dclannovars macro if
/                you call that macro. This length should also be applied to
/                your own variables you set up whose values you will pass to
/                html= as a variable name. 
/
/                Note that the variable named HTML is strictly an output
/                variable to be used in the output annotate dataset. You must
/                not treat this as a working variable as the macros defined
/                below will often reset the value of HTML to a space to ensure
/                that the scope of the instructions contained in the HTML
/                variable are limited to only the intended function. You will
/                typically require a working html variable (maybe named
/                HTMLWORK) and it is likely you have another html variable
/                in a dataset you are using for input. You must not name this
/                variable HTML in your input dataset nor use the HTML variable
/                as a working variable. You should make sure you set the
/                length of these other html variables to something suitable.
/                The maximum allowed length of 1024 is recommended. Note that
/                the %dclannovars macro contains a "keep" statement that will
/                only keep true annotate variables. If you want to keep more
/                variables then you will have to add another "keep" statement
/                to do this.
/
/                Most of these macros draw polygons. The shape is drawn twice
/                to allow you to define a both a fill color and additionally a
/                fill pattern drawn in the same color as the outline. This is
/                to allow you to use both the fill color and the fill pattern
/                to mean different things. For example, fill colors of "yellow"
/                "green" and "red" might indicate the severity of an AE and
/                the fill pattern might indicate relationship to study drug.
/                For the %box macro you should be aware that in most cases the
/                box will be too small for the fill pattern to be visible.
/
/                The thickness (or fatness) of the shapes drawn is controlled
/                by the "height" parameter. A "width" parameter additionally
/                applies to the box shape drawn by the %box macro.
/
/                If you do not want a fill pattern then specify
/                fillpattern="mempty". Note that the fill patterns are "map"
/                fill patterns (they begin with an "m"). See the SAS
/                documentation for how to correctly specify these patterns.
/
/                Macros definitions contained in this macro are as follows:
/                %rannomac: Dummy macro that does nothing
/                %dclannovars:  Declare the annotate variables
/                %xyzhsys:  Macro to define coordinate system to use
/                %text:     Like %label except all parameters are named
/                %box:      Draw a small box that is centered
/                %rod:      Like %rect except you can fill it
/                %rarrow:   Right arrow (arrow head points right)
/                %larrow:   Left arrow (arrow head points left)
/                %dblarrow: Double arrow (arrow heads on both ends)
/                %drawline: Draw a line
/                %bigbox:   Draw a big (empty) box
/                %fillbar:  Draw a fill bar (solid color - no outline)
/
/                You should use %fillbar before you draw a shape in the area
/                it fills otherwise it will overwrite your shape.
/
/                Note that for the %text macro, color=' ' and font=' '. This
/                is so it can pick up these values from the goptions statement
/                and hence lead to a consistency of fonts and text colors.
/                For font it will use what you define to ftext= and for color
/                it will use ctext= and if this is not set then it will use
/                the first color defined to the color list color=(). Note that
/                for annotate datasets, you are limited to an eight character
/                color name, even if a goptions statement can work with a
/                longer color name so if color=' ' then it will only accept
/                what is defined in a goptions statement if the color name
/                used is eight characters or less. You can always use the RGB
/                version of a long color name. For example, if you enter the
/                command "regedit" in an interactive sas session you will be
/                able to look at the list of colors in
/                SAS_REGISTRY\COLORNAMES\HTML. AntiqueWhite is near the top
/                of the list and its hex codes are displayed as FA,EB,D7
/                which means you could define it in the goptions statement as
/                ctext=CXFAEBD7 (no quotes required) and the annotate dataset
/                could accept this as the default color for text. Also the
/                default for height is height=. so that it will use what is
/                defined to the goptions statement hsize= or if not set then
/                it will use the SAS default of "1 cell".
/
/                If you use the html variable with the %text macro then the
/                hotspot is only correctly aligned for left-aligned text. If
/                you use position='<' then the hotspot is to the immediate
/                left of the displayed text. If you use "+" the hotspot is to
/                the left of the exact center of the displayed text. This is
/                a SAS bug that exists in sas v8.2 and sas v9.1.3 but should
/                be fixed in sas v9.2 . In the meantime, you will just have
/                to remember where to put your mouse cursor to pick up the
/                hotspot. The sas bug is reported at
/                http://support.sas.com/kb/12/377.html
/
/                The intention is for you to use both the SI supplied annotate
/                macros plus Roland's annotate macros together as needed.
/                However, it should be possible to use only Roland's annotate
/                macros in simple cases where you are only displaying shapes
/                defined in macros below that lie parallel to the x axis. These
/                macros were specifically written for use with a graphical
/                patient profiler and to provide a complete set for this. If
/                the need for more macros for this purpose are identified then
/                the extra macros will be added. If you are using this set of
/                macros for graphical patient profiling and you identify more
/                macros that are needed then tell the author.
/
/                In the usage notes below you will see a typical situation
/                where you use goptions to create a "long" html page that you
/                would typically use for graphical patient profiling. The
/                number of xpixels and ypixels will give you that area for
/                graphics. This is only accepted by a few devices such as
/                dev=gif and dev=html. hpos and vpos effectively give you the
/                number of columns (hpos=horizontal positions) and the number
/                of rows (vpos=vertical positions). Since cell size is the
/                default coordinate system then the top y position will be 300
/                if vpos=300. In the example below the first line used is
/                y=298 which leaves a two-row gap at the top. If the figures
/                and text look too big then you can reduce the height of them
/                using the height= parameters. If you have done that but the
/                rows seem too far apart then increase the hpos and vpos
/                values to divide up the graphics area up into smaller cells.
/
/                Note that v8.2 of SAS does not handle hotspots correctly.
/                If you run the code below using SAS v8.2 then the 
/                "Third Box" hotspot will also be active for the second box.
/                This problem does not occur for SAS v9.1.3 so if you are
/                writing annotate datasets that use hotspots then you MUST
/                use SAS v9.1.3 or later.
/               
/ Usage        : filename webout "C:\spectre\";
/
/                goptions reset=all xpixels=1000 ypixels=6000 hpos=50 vpos=300
/                dev=gif gsfmode=replace transparency border
/                ftext='Arial' htext=1 cell ctext=CX483D8C; * DarkSlateBlue ;
/
/                ods listing close;
/                ods html path=webout body="annotest.html";
/
/                %rannomac
/
/                data test;
/                  %dclannovars
/                  %rarrow(y=298,x1=20,x2=48)
/                  %text(y=298,x=19,position='<',text="right-aligned text") 
/                  %rarrow(y=297,x1=20,x2=48,fillcolor='green',
/                          linecolor='black',fillpattern='mempty')
/                  %text(y=297,x=19,position='<',text="next line of text")
/                  %text(y=296,x=19,position='<',
/                        text="This has a hotspot but misaligned on the left",
/                        color='maroon',
/               html="alt='This hotspot is misaligned on the left of the text'")
/                  %box(y=295,x=25)
/                  %box(y=295,x=35)
/                  %box(y=295,x=45,html="alt='Third Box Hotspot'")
/                  %text(y=295,x=19,position='<',
/                        text="The third box ONLY should have a hotspot")
/                  %bigbox(x1=20,y1=294.5,x2=50,y2=298.5,linecolor="brown")
/                run;
/
/                *- Set description to a space to stop whole output area -;
/                *- from having a hotspot and give the gif the same name -;
/                *- as the html body file. -;
/                proc ganno annotate=test description=" " name="annotest";
/                run;
/
/                *- If you rerun this code then you need to delete the -;
/                *- "annotest" grseg member in work.gseg so it can be  -;
/                *- reused as a name in the "proc ganno" step.  -;
/                proc greplay igout=gseg nofs;
/                  delete annotest;
/                  run;
/                quit;
/
/                ods html close;
/                ods listing;
/
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ x1                x coordinate start value
/ x2                x coordinate end value
/ x                 x coordinate (%box and %text only)
/ y                 y coordinate value
/ y1                y coordinate start value (%drawline, %bigbox and %fillbar)
/ y2                y coordinate end value (%drawline, %bigbox and %fillbar)
/ fillcolor="green"   Color to fill the inside of the shape with (not used for
/                   %bigbox). Default is "beige" for %fillbar.
/ linecolor="black"   Color of line to use for the outline of the shape
/ linewidth=1       Width of the line used to draw the outline
/ height=0.4        Height or fatness of the shape drawn (not %bigbox)
/ width=0.2         Width of the box shape (only used for %box)
/ html=' '          Used to assign html hotspots for the shapes drawn (not
/                   %bigbox). The %dclannovars macro will assign it the maximum
/                   allowed length of $ 1024. Note that this is an output
/                   variable. You must not use it as a working variable.
/ headfactor=1.5    Used to define the length of the arrow head in relation to
/                   the shaft fatness (not used for %rod even though defined).
/ fillpattern="mempty"  Default "map" pattern used to fill the shape is to have
/                   no pattern. Other recommended patterns are "m5n135", "m5n45"
/                   and "m5x45".
/--------------- These parameters apply to the %text macro only ----------------
/ text=' '          Text to display
/ font=' '          Font to use for the text is by default missing so that it
/                   uses what is defined to ftext= in the goptions statement.
/                   (note that non-SAS fonts must be enclosed in single quotes.
/                   If supplied as a variable they must also be enclosed in
/                   single quotes so they would have to be defined to a variable
/                   something like userfont="'Arial'". To specify a modified
/                   font such as "bold" then specify the modifier after a slash
/                   such as "'Arial / Bold'").
/ rotate=0          Rotation angle for the line of text relative to being
/                   parallel to the x axis.
/ angle=0           Angle of rotation of every text letter relative to the 
/                   perpendicular of the line of text.
/ position='+'      Default position of the text is CENTERED relative to the x,y
/                   coordinate. Use "<" for right-aligned and ">" for left-
/                   aligned, if you use "+" for centered. If you change this
/                   from your required default then you must reset it back
/                   manually afterwards.
/-------------- These parameters apply to the %xyzhsys macro only --------------
/  (Note that the following default values are also assigned in %dclannovars)
/ xsys='4'          Default for x coordinate system is '4' which is for
/                   multiples of cell height.
/ ysys='4'          Default for y coordinate system is '4' which is for 
/                   multiples of cell height.
/ zsys='2'          Default z coordinate system is to use data values
/ hsys='4'          Default for height coordinate system is '4' which is for
/                   multiples of cell height.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  03Mar08         Header update
/ rrb  04Mar08         "Keep" list added to %dclannovars macro
/ rrb  04Mar08         xsys='4', ysys='4', hsys='4' (cell based) now same as SAS
/                      defaults. Height changed to half cell height for shape
/                      thickness.
/ rrb  05Mar08         Header update. New usage example added that shows how to
/                      use ODS to create output.
/ rrb  05Mar08         Defaults changed to font=' ' and color=' ' for %text
/ rrb  05Mar08         Default changed to height=. for %text
/ rrb  06Mar08         Header example code updated
/ rrb  06Mar08         %drawline and %bigbox macros added and some defaults
/                      changed. Example code in header updated.
/ rrb  07Mar08         header tidy plus some defaults changed
/ rrb  11Mar08         %fillbar macro added and line=1 moved to "poly" obs
/ rrb  01Jan09         %text macro changed to accept a sas variable name for the
/                      font= parameter.
/ rrb  02Jan09         The %box macro now works the same way as the other filled
/                      shape macros in that it is a two-pass draw. All filled
/                      shape macros now do a two pass draw. These major changes
/                      implemented for version 2.0
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: rannomac v2.0;

%macro rannomac;
%mend rannomac;



              /*------------------------------------------*
                        declare annotate variables
               *------------------------------------------*/

%macro dclannovars;

  LENGTH html $ 1024 text $ 200;
  LENGTH function color $ 8;
  LENGTH style $ 32;
  LENGTH xsys ysys zsys hsys $ 1;
  LENGTH when position $ 1;

  LENGTH line size angle rotate x y z 8;

  RETAIN xsys '4' ysys '4' zsys '2' hsys '4';
  RETAIN position '+' when 'B';

  line=1;
  size=1;
  angle=0;
  rotate=0;
  x=0;
  y=0;
  z=0;
  html=' ';
  text=' ';
  function=' ';
  color=' ';

  KEEP html text function color style xsys ysys zsys hsys when position
       line size angle rotate x y z;

%mend dclannovars;



              /*------------------------------------------*
                        xyzhsys macro definition
               *------------------------------------------*/

%macro xyzhsys(xsys='4',
               ysys='4',
               zsys='2',
               hsys='4');
  xsys=&xsys;
  ysys=&ysys;
  zsys=&zsys;
  hsys=&hsys;

%mend xyzhsys;



              /*------------------------------------------*
                         drawline macro definition
               *------------------------------------------*/

%macro drawline(x1=,
                x2=,
                y1=,
                y2=,
         linecolor='black',
         linewidth=1);

  x=&x1;y=&y1;line=1;color=&linecolor;size=&linewidth;function="move";output;
  x=&x2;y=&y2;function="draw";output;

%mend drawline;



              /*------------------------------------------*
                         fillbar macro definition
               *------------------------------------------*/

%macro fillbar(x1=,
               x2=,
               y1=,
               y2=,
        fillcolor='beige');

  x=&x1;y=&y1;line=3;color=&fillcolor;style="solid";function="move";output;
  x=&x2;y=&y2;function="bar";output;
  line=1;

%mend fillbar;



              /*------------------------------------------*
                           text macro definition
               *------------------------------------------*/

%macro text(x=,
            y=,
         text=' ',
        color=' ',
         font=' ',
       height=.,
         html=' ',
        angle=0,
       rotate=0,
     position='+');

  html=&html;
  x=&x;y=&y;color=&color;style=&font;text=&text;size=&height;
  angle=&angle;rotate=&rotate;position=&position;function="label";output;
  html=' ';

%mend text;



              /*------------------------------------------*
                          bigbox macro definition
               *------------------------------------------*/

%macro bigbox(x1=,
              x2=,
              y1=,
              y2=,
       linecolor='black',
       linewidth=1);

    x=&x1;y=&y1;function="poly";style="mempty";size=&linewidth;line=1;output;
    y=&y2;color=&linecolor;function="polycont";output;
    x=&x2;function="polycont";output;
    y=&y1;function="polycont";output;
    x=&x1;function="polycont";output;

%mend bigbox;



              /*------------------------------------------*
                           box macro definition
               *------------------------------------------*/

%macro box(x=,
           y=,
   fillcolor='green',
   linecolor='black',
   linewidth=1,
      height=0.4,
        html=' ',
       width=0.2,
 fillpattern="mempty");


  *- First time draw using "fillcolor" -;
  html=' ';
  x=&x-&width/2;y=&y-&height/2;function="poly";color=&fillcolor;style="msolid";size=&linewidth;output;
  x=&x+&width/2;line=1;color=&linecolor;function="polycont";output;
  y=&y+&height/2;function="polycont";output;
  x=&x-&width/2;function="polycont";output;
  y=&y-&height/2;function="polycont";output;

  *- Second time draw using "fillpattern" with pattern color same as line color. -;
  *- If you dont want a fill pattern then use fillpattern="mempty" -;
  html=&html;
  x=&x-&width/2;y=&y-&height/2;function="poly";color=&linecolor;style=&fillpattern;line=1;output;
  html=' ';
  x=&x+&width/2;color=&linecolor;function="polycont";output;
  y=&y+&height/2;function="polycont";output;
  x=&x-&width/2;function="polycont";output;
  y=&y-&height/2;function="polycont";output;

%mend box;



              /*------------------------------------------*
                           rod macro definition
               *------------------------------------------*/

%macro rod(y=,
          x1=,
          x2=,
   fillcolor="green",
   linecolor="black",
   linewidth=1,
      height=0.4,
        html=' ',
  headfactor=1.5,
 fillpattern="mempty");

  *- First time draw using "fillcolor" -;
  html=' ';
  x=&x1;y=&y-&height/2;function="poly";color=&fillcolor;style="msolid";size=&linewidth;output;
  x=&x2;line=1;color=&linecolor;function="polycont";output;
  y=&y+&height/2;function="polycont";output;
  x=&x1;function="polycont";output;
  y=&y-&height/2;function="polycont";output;

  *- Second time draw using "fillpattern" with pattern color same as line color. -;
  *- If you dont want a fill pattern then use fillpattern="mempty" -;
  html=&html;
  x=&x1;y=&y-&height/2;function="poly";color=&linecolor;style=&fillpattern;line=1;output;
  html=' ';
  x=&x2;color=&linecolor;function="polycont";output;
  y=&y+&height/2;function="polycont";output;
  x=&x1;function="polycont";output;
  y=&y-&height/2;function="polycont";output;

%mend rod;



              /*------------------------------------------*
                   rarrow (right arrow) macro definition
               *------------------------------------------*/
 
%macro rarrow(y=,
             x1=,
             x2=,
      fillcolor="green",
      linecolor="black",
      linewidth=1,
         height=0.4,
           html=' ',
     headfactor=1.5,
    fillpattern="mempty");

  *- First time draw using "fillcolor" -;
  html=' ';
  x=&x1;y=&y-&height/2;function="poly";color=&fillcolor;style="msolid";
  size=&linewidth;line=1;output;
  x=&x2-&height*&headfactor;color=&linecolor;function="polycont";output;
  y=&y-&height;function="polycont";output;
  x=&x2;y=&y;function="polycont";output;
  x=&x2-&height*&headfactor;y=&y+&height;function="polycont";output;
  y=&y+&height/2;function="polycont";output;
  x=&x1;function="polycont";output;
  y=&y-&height/2;function="polycont";output;

  *- Second time draw using "fillpattern" with pattern color same as line color. -;
  *- If you dont want a fill pattern then use fillpattern="mempty" -;
  html=&html;
  x=&x1;y=&y-&height/2;function="poly";color=&linecolor;style=&fillpattern;line=1;output;
  html=' ';
  x=&x2-&height*&headfactor;color=&linecolor;function="polycont";output;
  y=&y-&height;function="polycont";output;
  x=&x2;y=&y;function="polycont";output;
  x=&x2-&height*&headfactor;y=&y+&height;function="polycont";output;
  y=&y+&height/2;function="polycont";output;
  x=&x1;function="polycont";output;
  y=&y-&height/2;function="polycont";output;

%mend rarrow;



              /*------------------------------------------*
                   larrow (left arrow) macro definition
               *------------------------------------------*/
 
%macro larrow(y=,
             x1=,
             x2=,
      fillcolor="green",
      linecolor="black",
      linewidth=1,
         height=0.4,
           html=' ',
     headfactor=1.5,
    fillpattern="mempty");


  *- First time draw using "fillcolor" -;
  html=' ';
  x=&x1;y=&y;function="poly";style="msolid";color=&fillcolor;size=&linewidth;line=1;output;
  x=&x1+&height*&headfactor;y=&y-&height;color=&linecolor;function="polycont";output;
  y=&y-&height/2;function="polycont";output;
  x=&x2;function="polycont";output;
  y=&y+&height/2;function="polycont";output;
  x=&x1+&height*&headfactor;function="polycont";output;
  y=&y+&height;function="polycont";output;
  x=&x1;y=&y;function="polycont";output;
  
  *- Second time draw using "fillpattern" with pattern color same as line color. -;
  *- If you dont want a fill pattern then use fillpattern="mempty" -;
  html=&html;
  x=&x1;y=&y;function="poly";color=&linecolor;style=&fillpattern;line=1;output;
  html=' ';
  x=&x1+&height*&headfactor;y=&y-&height;color=&linecolor;function="polycont";output;
  y=&y-&height/2;function="polycont";output;
  x=&x2;function="polycont";output;
  y=&y+&height/2;function="polycont";output;
  x=&x1+&height*&headfactor;function="polycont";output;
  y=&y+&height;function="polycont";output;
  x=&x1;y=&y;function="polycont";output;

%mend larrow;



              /*------------------------------------------*
                 dblarrow (double arrow) macro definition
               *------------------------------------------*/
 
%macro dblarrow(y=,
               x1=,
               x2=,
        fillcolor="green",
        linecolor="black",
        linewidth=1,
           height=0.4,
             html=' ',
       headfactor=1.5,
      fillpattern="mempty");


  *- First time draw using "fillcolor" -;
  html=' ';
  x=&x1;y=&y;function="poly";style="msolid";color=&fillcolor;size=&linewidth;line=1;output;
  x=&x1+&height*&headfactor;y=&y-&height;color=&linecolor;function="polycont";output;
  y=&y-&height/2;function="polycont";output;
  x=&x2-&height*&headfactor;function="polycont";output;
  y=&y-&height;function="polycont";output;
  x=&x2;y=&y;function="polycont";output;
  x=&x2-&height*&headfactor;y=&y+&height;function="polycont";output;
  y=&y+&height/2;function="polycont";output;
  x=&x1+&height*&headfactor;function="polycont";output;
  y=&y+&height;function="polycont";output;
  x=&x1;y=&y;function="polycont";output;

  *- Second time draw using "fillpattern" with pattern color same as line color. -;
  *- If you dont want a fill pattern then use fillpattern="mempty" -;
  html=&html;
  x=&x1;y=&y;function="poly";color=&linecolor;style=&fillpattern;line=1;output;
  html=' ';
  x=&x1+&height*&headfactor;y=&y-&height;color=&linecolor;function="polycont";output;
  y=&y-&height/2;function="polycont";output;
  x=&x2-&height*&headfactor;function="polycont";output;
  y=&y-&height;function="polycont";output;
  x=&x2;y=&y;function="polycont";output;
  x=&x2-&height*&headfactor;y=&y+&height;function="polycont";output;
  y=&y+&height/2;function="polycont";output;
  x=&x1+&height*&headfactor;function="polycont";output;
  y=&y+&height;function="polycont";output;
  x=&x1;y=&y;function="polycont";output;

%mend dblarrow;
/*<pre><b>
/ Program   : ratitle.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To right-align a title for a pure text output
/ SubMacros : %lratitle
/ Notes     : This is for pure text output listings and tables. For other types 
/             of output you can use j=right or .j=right in the title statement
/             to achieve right-alignment.
/ Usage     : %ratitle(5,"This title 5 will be right-aligned")
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ num               (pos) Number of title
/ text              (pos) Text of title (must be in quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: ratitle v1.0;

%macro ratitle(num,text);
  %lratitle(&num,,&text)
%mend ratitle;
/*<pre><b>
/ Program   : rcmd2ds.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To run a system command on the remote host and write the output to
/             a dataset.
/ SubMacros : none
/ Notes     : This macro is only for use in sas sessions where you can "rsubmit"
/             code to a remote server.
/
/             It works by using a pipe filename statement in an rsumbit block
/             where the output is read in and written to a dataset in the RWORK
/             library with the single variable STR.
/
/             This is suitable where multiple lines of output are returned. For
/             single line output you can use %rcmd2mvar to write the output to a
/             macro variable stored locally.
/
/ Usage     : %rcmd2ds(ls /root/usr/mylib)
/
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ cmd               (pos) Command you want to run in the remote session
/ dsout             (pos) Output dataset name to go in RWORK (defaults to
/                   _rcmd2ds).
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  12Aug11         new (v1.0)
/ rrb  20Mar14         Allow output dataset name to be changed. STR length
/                      increased to 256  (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: rcmd2ds v2.0;

%macro rcmd2ds(cmd,dsout);
  %if not %length(&dsout) %then %let dsout=_rcmd2ds;
  %syslput _rcmd=&cmd;
  %syslput _dsout=&dsout;
  RSUBMIT;
  filename _rcmd2ds pipe "&_rcmd";
  data &_dsout;
    length str $ 256;
    infile _rcmd2ds;
    input;
    str=_infile_;
  run;
  filename _rcmd2ds CLEAR;
  ENDRSUBMIT;
%mend rcmd2ds;
/*<pre><b>
/ Program   : rcmd2log.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 12-Aug-2011
/ Purpose   : To run a system command on the remote host and write the output to
/             the log.
/ SubMacros : none
/ Notes     : This macro is only for use in sas sessions where you can "rsubmit"
/             code to a remote server.
/
/             It works by using a pipe filename statement in an rsumbit
/             block where the output is read in and written to the log.
/
/ Usage     : %rcmd2log(ps -fu userid); *- see details of a user-id -;
/             %rcmd2log(ps -fp 12345);  *- see details of a process-id -;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ cmd               (pos) command you want to run in the remote session
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  12Aug11         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: rcmd2log v1.0;

%macro rcmd2log(cmd);
  %syslput _rcmd=&cmd;
  rsubmit;
  filename _rcmd pipe "&_rcmd";
  data _null_;
    infile _rcmd;
    input;
    put _infile_;
  run;
  filename _rcmd clear;
  endrsubmit;
%mend rcmd2log;
/*<pre><b>
/ Program   : rcmd2mvar.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 12-Aug-2011
/ Purpose   : To run a system command on the remote host and write the output to
/             a macro variable on the local host.
/ SubMacros : %getvalue
/ Notes     : This macro is only for use in sas sessions where you can "rsubmit"
/             code to a remote server.
/
/             It works by using a pipe filename statement in an rsumbit block
/             where the output is read in and written to a dataset that is read
/             into a macro variable back on the local host.
/
/             Only use this for commands returning one line output. For multiple
/             line output then use %rcmd2ds to write to a dataset or %rcmd2log
/             to write to the log.
/
/             The macro variable to receive the output must have been declared
/             in a local session before this macro is called. Note that this is
/             not a "function-style macro". It must be used in the way shown in
/             the usage notes.
/
/ Usage     : %rcmd2mvar(ps -fu userid,mymvar); *- see details of a user-id -;
/             %rcmd2mvar(ps -fp 12345,mymvar); *- see details of a process-id -;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ cmd               (pos) command you want to run in the remote session
/ mvar              (pos) Name of macro variable to write output to
/ usequotes=no      By default, do not quote the returned string
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  12Aug11         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: rcmd2mvar v1.0;

%macro rcmd2mvar(cmd,mvar,usequotes=no);
  %syslput _rcmd=&cmd;
  RSUBMIT;
    filename _rcmd pipe "&_rcmd";
    data _rcmd;
      infile _rcmd;
      input;
      str=trim(_infile_);
    run;
    filename _rcmd clear;
  ENDRSUBMIT;
  %let &mvar=%getvalue(rwork._rcmd,str,1,usequotes=&usequotes);
  proc datasets nolist lib=rwork;
    delete _rcmd;
  run;
  quit;
%mend rcmd2mvar;
/*<pre><b>
/ Program   : rcmd2sas.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 20-Mar-2014
/ Purpose   : To run a system command on the remote host and write the output to
/             a dataset.
/ SubMacros : %rcmd2ds
/ Notes     : This macro is only for use in sas sessions where you can "rsubmit"
/             code to a remote server.
/
/             It works by using a pipe filename statement in an rsumbit block
/             where the output is read in and written to a dataset in the RWORK
/             library with the single variable STR.
/
/             This is suitable where multiple lines of output are returned. For
/             single line output you can use %rcmd2mvar to write the output to a
/             macro variable stored locally.
/
/ Usage     : %rcmd2sas(ls /root/usr/mylib)
/
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ cmd               (pos) Command you want to run in the remote session
/ dsout             (pos) Output dataset name to go in RWORK (defaults to
/                   _rcmd2sas).
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Mar14         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: rcmd2sas v1.0;

%macro rcmd2sas(cmd,dsout);
  %if not %length(&dsout) %then %let dsout=_rcmd2sas;
  %rcmd2ds(&cmd,&dsout)
%mend rcmd2sas;
/*<pre><b>
/ Program   : readfile.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to read in a flat file and assign the
/             contents to a macro variable.
/ SubMacros : none
/ Notes     : You could use this to generate information and write it to a file
/             and then read it in to a macro variable for further processing.
/             Lines in the file must not be longer than 200 characters. Line
/             breaks will be lost when the data is read in.
/ Usage     : %let mvar=%readfile(filename);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ file              (pos) Path name of flat file
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: readfile v1.0;

%macro readfile(file);
  %local fname fid str rc err;
  %let err=ERR%str(OR);
  %let file="%sysfunc(compress(&file,%str(%'%")))";
  %if not %sysfunc(fileexist(&file)) %then 
  %put &err: (readfile) File &file does not exist;
  %else %do;
    %let rc=%sysfunc(filename(fname,&file));  
    %if &rc NE 0 %then %do;
  %put &err: (readfile) File &file could not be assigned due to the following:;
  %put %sysfunc(sysmsg());
    %end;
    %else %do;
      %let fid=%sysfunc(fopen(&fname));
      %if &fid EQ 0 %then %do;
  %put &err: (readfile) File &file could not be opened due to the following:;
  %put %sysfunc(sysmsg());
      %end;
      %else %do;
        %do %while(%sysfunc(fread(&fid)) EQ 0);
          %let rc=%sysfunc(fget(&fid,str,200));
&str
        %end;
        %let rc=%sysfunc(fclose(&fid));
        %if &rc NE 0 %then %do;
  %put &err: (readfile) File &file could not be closed due to the following:;
  %put %sysfunc(sysmsg());
        %end;
        %let rc=%sysfunc(filename(fname));
        %if &rc NE 0 %then %do;
  %put &err: (readfile) File &file could not be deassigned due to the following:;
  %put %sysfunc(sysmsg());
        %end;
      %end;
    %end;
  %end;
%mend readfile;
/*<pre><b>
/ Program   : remove.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to remove all occurrences of the target
/             string(s) from another string.
/ SubMacros : none
/ Notes     : none
/ Usage     : %let string2=%remove(&string1,XXX,yyy,YYY);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos - unquoted) String to remove target from
/ target1-30        (pos - unquoted) Target string(s) to remove
/ casesens=no       Whether the search for the target(s) is case sensitive
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: remove v1.0;

%macro remove(string,
              target1,
              target2,
              target3,
              target4,
              target5,
              target6,
              target7,
              target8,
              target9,
              target10,
              target11,
              target12,
              target13,
              target14,
              target15,
              target16,
              target17,
              target18,
              target19,
              target20,
              target21,
              target22,
              target23,
              target24,
              target25,
              target26,
              target27,
              target28,
              target29,
              target30,
           casesens=no
              );

  %local i result index targlen beyond newstr;

  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));

  %let result=&string;

  %do i=1 %to 30;
    %let targlen=%length(&&target&i);
    %if &targlen %then %do;
      %if "&casesens" EQ "Y" %then %let index=%index(&result,&&target&i);
      %else %let index=%index(%qupcase(&result),%qupcase(&&target&i));
      %do %while(&index GT 0);
        %if &index GT 1 %then %let newstr=%qsubstr(&result,1,%eval(&index-1));
        %else %let newstr=;
        %let beyond=%eval(&index+&targlen);
        %if &beyond LE %length(&result) %then %let newstr=&newstr%qsubstr(&result,&beyond);
        %let result=&newstr;
        %if "&casesens" EQ "Y" %then %let index=%index(&result,&&target&i);
        %else %let index=%index(%qupcase(&result),%qupcase(&&target&i));
      %end;
    %end;
  %end;

&result

%mend remove;
/*<pre><b>
/ Program   : removew.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 05-Dec-2012
/ Purpose   : Function-style macro to remove all occurrences of the target
/             word(s) from a source list of words.
/ SubMacros : %words
/ Notes     : For a word to be removed, the whole word must match. This macro
/             will not remove substrings in the sense that "low" will not be
/             removed from the end of the word "yellow". Multiple occurences of
/             a word will be removed. This macro will only work correctly for
/             lists of space-delimited words containing no special characters
/             that need quoting. You should avoid combinations of a string with
/             many words and many target words such that their product is very
/             high (e.g. 100 x 100 = 10000) as this code will run slow and use
/             a lot of processor power. Data step solutions or SQL solutions are
/             better for those cases. Final result returned will have leading
/             and trailing spaces removed and multiple adjacent blanks replaced
/             by single blanks.
/ Usage     : %let colors2=%removew(&rainbow,green yellow);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos) Unquoted space-delimited source list of words
/ targetwords       (pos) Unquoted space-delimited target word(s) to remove
/ casesens=no       Whether the search for the target word(s) is case sensitive
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jan08         compbl bug fixed
/ rrb  04May11         Code tidy
/ rrb  05Dec12         Usage notes macro call coreected
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: removew v1.1;

%macro removew(string,
          targetwords,
             casesens=no
              );

  %local i j result match twords swords tword sword;

  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));

  %let twords=%words(&targetwords);
  %let swords=%words(&string);

  %let result=;

  %do i=1 %to &swords;
    %let match=0;
    %let sword=%scan(&string,&i,%str( ));
    %do j=1 %to &twords;
      %let tword=%scan(&targetwords,&j,%str( ));
      %if "&casesens" EQ "Y" %then %do;
        %if "&tword" EQ "&sword" %then %do;
          %let match=1;
          %let j=&twords;
        %end;
      %end;
      %else %do;
        %if "%upcase(&tword)" EQ "%upcase(&sword)" %then %do;
          %let match=1;
          %let j=&twords;
        %end;
      %end;
    %end;
    %if not &match %then %let result=&result &sword;
  %end;

  %if %length(&result) %then %let result=%sysfunc(compbl(&result));

&result

%mend removew;
/*<pre><b>
/ Program   : rename8.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 12-Feb-2011
/ Purpose   : Function-style macro to return a variable rename list for variable
/             names longer than 8 characters to shorten them to 8 characters.
/ SubMacros : %varlist
/ Notes     : No checking for the uniqueness of variable names is done. Use this 
/             macro to get legacy code working where for some reason you are
/             getting variable names more than 8 characters long where you are
/             not expecting it. Most problems come from transposes but if you
/             set VALIDVARNAME=V6 before the transpose and VALIDVARNAME=V7 after
/             the transpose then it should solve the problem. If you can not do
/             that for some reason or somebody sends you a dataset with variable
/             names longer than 8 characters and you need to shorten them then
/             perhaps this macro can be of use. Note that this will not work on 
/             variable names that have spaces in them created with the option
/             VALIDVARNAME=ANY in effect. If none of the variables names are
/             more than 8 characters long then the null string is returned. This
/             will not cause a problem in a RENAME statement (see Usage below)
/             as then the RENAME statement will be ignored.
/ Usage     : data myds2;
/               set myds;
/               rename %rename8(myds);
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: rename8 v1.0;

%macro rename8(ds);
  %local i varlist renlist var;
  %let varlist=%varlist(&ds);
  %let var=%scan(&varlist,1,%str( ));
  %do %while(%length(&var));
    %if %length(&var) GT 8 %then %let renlist=&renlist &var=%substr(&var,1,8);
    %let i=%eval(&i+1);
    %let var=%scan(&varlist,&i,%str( ));
  %end;
&renlist
%mend rename8;
/*<pre><b>
/ Program   : replhex.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To replace occurrences of a specified hex character in a flat file
/             with another specified character.
/ SubMacros : none
/ Notes     : Hex characters must be specified in quoted form such as 'FE'x. 
/             The target character does not have to be hex and the replacement
/             character can be hex if you want. Note that a space specified as a
/             replacement character must be quoted and not left blank.
/             You can use the %asciinonp macro to show up what non-printable hex
/             characters are in a flat file.
/ Usage     : %replhex(infile,outfile,'FE'x,' ')
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ infile            (pos) Input file
/ file              (pos) Output file
/ target            (pos) Target character (quoted)
/ repl              (pos) Replacement character (quoted)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  15Jun03         Use _file_ and _infile_ instead
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: replhex v1.0;

%macro replhex(infile,file,target,repl);

  %local errflag err;
  %let err=ERR%str(OR);
  %let errflag=0;

       /*--------------------------------------*
            Check we have all parameters set
        *--------------------------------------*/

  %if not %length(&infile) %then %do;
    %let errflag=1;
    %put &err: (replhex) No input file specified;
  %end;

  %if not %length(&file) %then %do;
    %let errflag=1;
    %put &err: (replhex) No output file specified;
  %end;

  %if not %length(&target) %then %do;
    %let errflag=1;
    %put &err: (replhex) No target character specified;
  %end;

  %if not %length(&repl) %then %do;
    %let errflag=1;
    %put &err: (replhex) No replacement character specified;
  %end;

  %if &errflag %then %goto exit;



       /*--------------------------------------*
               Start processing the data
        *--------------------------------------*/

  data _null_;
    infile "&infile";
    file "&file" notitles noprint;
    input;
    if _infile_ ne ' ' then _file_=translate(_infile_,&repl,&target);
    put;
  run;


  %goto skip;
  %exit: %put &err: (replhex) Leaving macro due to problem(s) listed;
  %skip:

%mend replhex;
/*<pre><b>
/ Program   : rinclude.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 12-Jun-2011
/ Purpose   : To submit local sas code members in the remote session
/ SubMacros : none
/ Notes     : This macro works by placing local sas code members in a catalog as
/             "source" members and uploading them to the remote host where they
/             are extracted and submitted.
/
/             A mixed list of files (in quotes) and filerefs (not in quotes) can
/             be supplied (separated by spaces) much like how %include works.
/             It assumes you are already connected to the remote session.
/
/             No sas system options are set in this macro so if you want to
/             suppress notes in the log then submit the option "nonotes" in an
/             rsubmit block in the remote session as well as in your local
/             session before calling this macro. You may wish to set other sas
/             options in this way as well.
/
/             You would normally use this macro to compile macros in your local
/             session on the remote host so you can use them there. 
/
/             The macros %dirfpq (for Windows) and %lsfpq (for Unix) are useful
/             for creating a full-path quoted list of directory members for use
/             in the filelist= parameter when you have a large number of macros
/             to upload.
/
/ Usage     : %rinclude(mylib(mymacro1.sas) "C:\mylib\mymacro2.sas"
/                       %dirfpq(C:\macros\*.sas);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ filelist          (pos) Space-delimited list of mixed files (quoted) and
/                   filerefs (not quoted) as you would supply to %include
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  12Jun11         Header tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: rinclude v1.0;

%macro rinclude(filelist);

  %local bit i;
  %let i=1;
  %let bit=%sysfunc(scan(&filelist,&i," ",q));

  %*- do for each file listed -;
  %do %while(%length(&bit));

    %*- do differently for file names and filerefs -;
    %if %qsubstr(&bit,1,1) EQ %str(%') 
     OR %qsubstr(&bit,1,1) EQ %str(%") %then %do;

      filename _rincin &bit;
      filename _rincout catalog "work._rinc._rinc.source";

      *- write to the catalog -;
      data _null_;
        infile _rincin;
        file _rincout;
        input;
        put _infile_;
      run;

      RSUBMIT;
        proc upload incat=work._rinc outcat=work._rinc status=no;
          select _rinc.source;
        quit;

        filename _rinc catalog "work._rinc._rinc.source";

        %include _rinc;

        *- delete the remote catalog -;
        proc datasets nolist memtype=catalog;
          delete _rinc;
        quit;
 
        filename _rinc clear;
      ENDRSUBMIT;

      *- delete the local catalog -;
      proc datasets nolist memtype=catalog;
        delete _rinc;
      quit;

      filename _rincin clear;
      filename _rincout clear;

    %end;

    %else %do;

      filename _rincout catalog "work._rinc._rinc.source";

      *- write to the catalog -;
      data _null_;
        infile &bit;
        file _rincout;
        input;
        put _infile_;
      run;

      RSUBMIT;
        proc upload incat=work._rinc outcat=work._rinc status=no;
          select _rinc.source;
        quit;

        filename _rinc catalog "work._rinc._rinc.source";

        %include _rinc;

        *- delete the remote catalog -;
        proc datasets nolist memtype=catalog;
          delete _rinc;
        quit;
 
        filename _rinc clear;

      ENDRSUBMIT;

      *- delete the local catalog -;
      proc datasets nolist memtype=catalog;
        delete _rinc;
      quit;

      filename _rincout clear;

    %end;

    %*- prepare for the next iteration -;
    %let i=%eval(&i+1);
    %let bit=%sysfunc(scan(&filelist,&i," ",q));

  %end;

%mend rinclude;
/*<pre><b>
/ Program   : round.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To round all the numeric variables in a list of datasets.
/ SubMacros : %dsall %words %varlistn
/ Notes     : You can use the _all_ notation to refer to all the datasets in a
/             library. You would normally run this against datasets obtained 
/             from a different platform before you use the data. This is because
/             numbers are stored to different accuracies on different platforms.
/             You would normally run this after running %dropvars on the
/             datasets to drop umwanted variables.
/ Usage     : %round(work._all_)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- ------------------------description-------------------------
/ list              (pos) List of datasets. The _all_ notation can be used.
/ roundto=0.0000000001    Value to round to.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: round v1.0;

%macro round(list,roundto=0.0000000001);

  %local varlistn i j;
  %dsall(&list)

  %do i=1 %to %words(&_dsall_);
    %let varlistn=%varlistn(%scan(&_dsall_,&i,%str( )));
    %if %length(&varlistn) %then %do;
      data %scan(&_dsall_,&i,%str( ));
        set %scan(&_dsall_,&i,%str( ));
      %do j=1 %to %words(&varlistn);
        %scan(&varlistn,&j,%str( ))=round(%scan(&varlistn,&j,%str( )),&roundto);
      %end;
      run;
    %end;
  %end;

%mend round;
/*<pre><b>
/ Program   : rsubmitter.sas
/ Version   : 5.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 11-Jun-2014
/ Purpose   : To remotely submit a block of tasks in a specified number of
/             multiprocessing streams or to run those tasks sequentially if
/             SAS/CONNECT is not licensed or zero streams requested.
/ SubMacros : %allafter %mysasautos %scandlm %commaparmsu %prefix %words
/ Notes     : This macro also works where SAS/CONNECT is not licensed to run on
/             a computer except it will not multiprocess and instead will run
/             tasks sequentially. A simple NOTE will be written to the log in
/             that case before any tasks are run. If used in that way, this
/             macro acts as a general purpose macro for running multiple tasks
/             whether SAS/CONNECT is licensed or not. Using this macro can
/             therefore make your code simpler, tidier and general-purpose for
/             both SAS/CONNECT licensed sites and for sites where not licensed,
/             without having to change your code. If you use it for this purpose
/             and set the streams equal to your number of tasks (streams=T) then
/             if the submission order is not important then you can help this
/             macro by running the longer tasks later in the sequence. That way
/             it can sign off the completed sessions sooner and can return
/             allocated resources back to the computer.
/
/             The purpose of this macro is to submit tasks in the order
/             specified in the task block and to collect outputs in that same
/             task order (which will probably not the the same as the finishing
/             order) whilst allowing these tasks to run in parallel streams up
/             to the number of streams specified to the streams= parameter and
/             to manage those streams in the sense of monitoring them for job
/             completions and to submit new tasks where previous tasks have
/             completed.
/
/             To keep computer overheads down it is better to let the number of
/             streams default. You can set streams=T , which will equate to the
/             total number of tasks, but this macro will reduce your requested
/             number of streams if that value is more than the total number of
/             cores. If you use streams=T for a large number of tasks, with
/             enough cores to run those tasks, then be aware of the impact this
/             may have for other users of the server. The number of streams this
/             macro will use is reported in the log as a NOTE. This may be less
/             than your requested value.
/
/             The tasks listed in the "taskblock" will potentially all be run in
/             parallel if the streams number is high enough to accommodate them
/             all so it is important to realise that this macro should not be
/             used where one task is dependent on another task having completed.
/             Although the tasks will be submitted in order, it is expected that
/             some tasks will take longer than others to run so later tasks will
/             be submitted while earlier tasks have still not completed,
/             therefore no dependencies should be relied upon. A typical use of
/             this macro will be where datasets have been built in the WORK
/             library and the reporting tasks can be run on those datasets in
/             parallel to save time. This macro will then collect together the
/             outputs in the submitted order, even though this will probably not
/             be the same as the finishing order.
/
/             Note that any local compiled macros needed by the tasks must be
/             copied from WORK.SASMACR to the catalog SHAREMAC.SASMACR . There
/             is a macro named %mksharemac that can be used to set up the shared
/             macro catalog and copy compiled macros into it for this purpose.
/             If there is no requirement to share compiled macros then this
/             catalog and libref is not needed. For macros on the SASAUTOS path
/             then there is no need to copy any macros as the SASAUTOS path in
/             the local session will be passed across to the remote sessions. If
/             SAS/CONNECT is not licensed then this SHAREMAC.SASMACR catalog
/             will not be used but this will not cause any problems as the code
/             will use WORK.SASMACR in the local session instead.
/
/             The local session WORK library will be inherited by the remote
/             sessions as the LWORK library. If the code members need to access
/             data in the local session work library then they should follow the
/             conventions in the %look4lwork macro so that code members can work
/             both locally and remotely without needing to change the code.
/
/             The "block" of tasks must follow a specific convention that will
/             be explained here. Each block element will start with a "#" or a
/             "*". A "#" signifies that this is a task to be run. A "*"
/             signifies that the task should not be run (i.e. it has been
/             effectively commented out). Each active element then follows the
/             following convention:
/
/                #include="maybe a path in quotes or fileref without"
/
/                OR
/
/                #mactype=macname param1=xxxx param2=yyyyy param3=zzzz
/
/             For the "include" convention, what follows the equals sign will
/             follow a generated %INCLUDE statement and this will be the code to
/             run. In the above case that would equate to:
/
/                %INCLUDE "maybe a path in quotes or fileref without";
/
/             For the "mactype" convention, a macro in the position of "macname"
/             will be called and the parameters passed to that macro will be
/             those that follow the macro name, except that commas will be
/             inserted between the parameters and be enclosed by round brackets.
/             In the above case that would equate to the following call:
/
/                %macname(param1=xxxx,param2=yyyy,param3=zzzz);
/
/             This "rsubmitter" macro would normally be called inside another
/             macro that gets the number of streams and taskblock supplied to it
/             as parameters and passes on those same parameter values to this
/             macro. The calling macro is then expected to create any datasets
/             and formats that the tasks defined in the block need to have
/             access to. The content of the task block might need to be parsed
/             by the calling macro to know what datasets to build and what
/             variables to include. The macros %scandlm and %allafter, as used
/             in this macro, will probably be useful for parsing the task block
/             if this is required.
/
/             If the called processes need to inherit more libraries than WORK
/             (as LWORK) and SHAREMAC then this must be specified to the
/             inheritlibs= parameter. If this is not done then the called code
/             will have no link to these extra libraries.
/
/             In very rare circumstances there may be a need to change the
/             parameter names of the generated macro calls so this can be
/             achieved using the parmreplace= parameter.
/
/ Usage     : %rsubmitter(streams=&streams,taskblock=&taskblock);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ streams=          (optional - recommend to allow to default) Number of
/                   rsubmit streams to run. If set to 0 then no multiprocessing
/                   streams will be used - if null then a suitable value will be
/                   calculated assuming fast code - if streams=T then set to the
/                   total number of tasks.
/ taskblock=        Block of tasks to run
/ inheritlibs=_all_    List of extra librefs (separated by spaces - not WORK or
/                   SHAREMAC) that need to be inherited by the remote processes.
/                   Default is to use _all_ to share all of them (apart from
/                   WORK, SHAREMAC and any SAS: or MAPS: libraries). Do not
/                   combine _all_ with other librefs. It must be specified on
/                   its own if used.
/ appendpairs=      Pairs of base/data datasets, separated by spaces, for
/                   appending data in the WORK folders of the remote sessions
/                   onto data in the local sessions before signing off the
/                   processes. Supply in the form:
/                       lcldset1/remdset1 lcldset2/remdset2
/ parmreplace=      (rarely used) Pairs of parameter names followed by their
/                   name replacements (of the form parm1=repl1 myparm2=myrepl2)
/                   (not case sensitive) to act on generated macro calls
/                   (following the #mactype=macname convention) to replace the
/                   generated parameter names with new ones.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  01Jun14         New (v1.0)
/ rrb  03Jun14         Added handling for %include files, simplified the logic
/                      and added more explanation in the header (v2.0)
/ rrb  04Jun14         Added check for SAS/CONNECT being licensed and run all
/                      tasks synchronously in local session if not (v3.0)
/ rrb  05Jun14         More instructions added to header (v3.0)
/ rrb  08Jun14         Added automatic calculation of streams= value if null
/                      and the facility to set streams=T for the total number of
/                      tasks. Streams value will be reset to the minimum of
/                      &sysncpu or &tasknum, whichever is smaller, if streams
/                      value is greater (v4.0)
/ rrb  11Jun14         inheritlibs= , parmreplace= and appendpairs= parameters
/                      added. Use of %commaparms replaced by %commaparmsu. All
/                      macro parameters changed to named parameters (v5.0)
/ rrb  11Jun14         Code for handling parmreplace= enhanced so that it
/                      matches on whole parameter names (v5.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: rsubmitter v5.1;

%macro rsubmitter(streams=
               ,taskblock=
             ,inheritlibs=_all_
             ,appendpairs=
             ,parmreplace=
                 ); 

  %local i j task tasknum old_plist plist next_signoff pnum pval numended
         savopts mactype macname params taskstr sharemac shareopt err
         errflag newinheritlibs lib apppair baseds datads; 

  %let err=ERR%str(OR);
  %let errflag=0;
  %let tasknum=0;


  *- Find out of the SHAREMAC libref has been assigned -;
  *- and set up a string for inheritlib() if it is.    -;
  %let sharemac=;
  %let shareopt=;
  %if (%sysfunc(libref(sharemac))) EQ 0 %then %do;
    %let sharemac=sharemac=sharemac;
    %let shareopt=mstored sasmstore=sharemac;
  %end;

  *- Build a list of extra inheritlibs to pass to the remote sessions -;
  %if "%upcase(&inheritlibs)" EQ "_ALL_" %then %do;
    PROC SQL NOPRINT;
      %let inheritlibs=;
      SELECT DISTINCT libname into :inheritlibs separated by ' '
      FROM dictionary.libnames
      WHERE libname not in ("WORK" "SHAREMAC")
      and libname not like 'MAPS%'
      and libname not like 'SAS%';
    QUIT;
  %end;
  %let newinheritlibs=;
  %do i=1 %to %words(&inheritlibs);
    %let lib=%upcase(%scan(&inheritlibs,&i,%str( )));
    %if %sysfunc(libref(&lib)) NE 0 %then %do;
      %let errflag=1;
      %put &err: (rsubmitter) inheritlibs=&inheritlibs but libref &lib is not assigned;
    %end;
    %else %let newinheritlibs=&newinheritlibs &lib=&lib;
  %end;


  *---- Read in the active tasks from the task block parameter value  ----; 
  *---- into a macro array and set "tasknum" to the total valid tasks ----; 
  *---- which will be those elements starting with '#'.               ----;
  %let i=1;
  %do %until(not %length(&task)); 
    %let task=%scandlm(&taskblock,&i,*#); 
    %if "%sysfunc(subpad(&task,1,1))" EQ "#" %then %do; 
      %let tasknum=%eval(&tasknum+1); 
      %local task&tasknum; 
      %let task&tasknum=&task; 
    %end; 
    %let i=%eval(&i+1); 
  %end;


  *- Calculate a suitable streams value if null or set   -;
  *- to the total number of tasks if it starts with "t". -;
  %if not %length(&streams) %then
   %let streams=%sysfunc(round(2+&sysncpu**0.5));
  %else %if "%upcase(%substr(&streams,1,1))" EQ "T" 
   %then %let streams=&tasknum;


  *- The number of streams must be an integer -;
  %if %length(%sysfunc(compress(&streams,0123456789))) %then %do;
    %let errflag=1;
    %put &err: (rsubmitter) streams=&streams is not valid as it is not an integer;
  %end;

  %if &errflag %then %goto exit;



  *- Do not allow the streams value to exceed the  -;
  *- number of cores or the total number of tasks. -;
  %let streams=%sysfunc(min(&sysncpu,&tasknum,&streams));


  %if (%sysprod(connect) EQ 1) and (&streams NE 0) %then %do;

    %let savopts=%sysfunc(getoption(autosignon));
  
    %put NOTE: (rsubmitter) &streams rsubmit streams will be used;

    options noautosignon;

    *#########  Define sub-macro that sets up the remote session  #########; 

    %macro rsub(pnum=,task=);
      %local j parmpair parm1 parm2;

      %let mactype=%scan(%substr(&task,2),1,=);
      %if "%upcase(&mactype)" EQ "INCLUDE" %then
        %let taskstr=INCLUDE %allafter(&task,=);
      %else %do;
        %let macname=%scan(%allafter(&task,=),1,%str( )); 
        %let params=%allafter(&task,=&macname);
        %if %length(&parmreplace) %then %do;
          %do j=1 %to %words(%superq(parmreplace));
            %let parmpair=%scan(&parmreplace,&j,%str( ));
            %let parm1=%upcase(%scan(&parmpair,1,=));
            %let parm2=%upcase(%scan(&parmpair,2,=));
            %let params=%sysfunc(prxchange(s/\s&parm1\s*=/ &parm2=/i,
             1,%str( )%nrbquote(&params)));
          %end;
        %end;
        %let taskstr=&macname(%commaparmsu(%nrbquote(&params)));
      %end;
 

      *- we need an explicit signon so that we can "syslput" to -; 
      *- a remote session we are already in contact with.       -; 
      signon P&pnum cwait=no 
      inheritlib=(work=lwork &sharemac &newinheritlibs) 
      sascmd="!sascmd -sasuser work -noterminal -nonotes -nosplash 
              -noautoexec -sasautos %mysasautos";

      *- Make the contents of "taskstr" available to the remote session -; 
      *- as the contents of the remote local macro variable "taskrem".  -; 
      %syslput taskrem=&taskstr / remote=P&pnum;

      *- Make the contents of "shareopt" available to the remote session -; 
      *- as the contents of the remote local macro variable "sharerem".  -;
      %syslput sharerem=&shareopt / remote=P&pnum;

      *- Make the contents of "pnum" available to the remote session   -; 
      *- as the contents of the remote local macro variable "pnumrem". -;
      %syslput pnumrem=&pnum / remote=P&pnum;

      RSUBMIT cmacvar=stat&pnum sysrputsync=yes;
        options notes nodate nonumber &sharerem;
        %&taskrem;
        %nrstr(%let rempath=%sysfunc(pathname(work)));
        %nrstr(%sysrput workpath&pnumrem=&rempath);
      ENDRSUBMIT; 

    %mend rsub; 

    *############ End of sub-macro definition ###########; 
  
  

    *###### initiate and manage the remote sessions ######; 

    %let pnum=0; 
    %let next_signoff=1; 

    *--- launch tasks for each of the number of streams ---; 
    %do i=1 %to &streams; 
      %if &i LE &tasknum %then %do; 
        %let pnum=%eval(&pnum+1); 
        %let plist=&plist &pnum;
        %rsub(pnum=&pnum,task=&&task&pnum); 
      %end; 
    %end; 

    *--- point to keep jumping back to ---; 
    %loop: 

    *-- stop and wait for any of the processes to end ---; 
    waitfor _any_ %prefix(P,&plist); 

    *- try to sign off as many processes as possible -; 
    %do i=&next_signoff %to &pnum; 
      %if &&stat&i EQ 0 %then %do;
        %*- append WORK data from remote sessions if requested -;
        %if %length(&appendpairs) %then %do;
          libname _rwork "&&workpath&i";
          %do j=1 %to %words(%superq(appendpairs));
            %let apppair=%scan(&appendpairs,&j,%str( ));
            %let baseds=%scan(&apppair,1,\/);
            %let datads=%scan(&apppair,2,\/);
            %if %sysfunc(exist(_rwork.&datads)) %then %do;
              proc append force base=&baseds data=_rwork.&datads;
              run;
            %end;
          %end;
          libname _rwork CLEAR;
        %end;
        %put NOTE: (rsubmitter) Now signing off P&i so P&i log follows:;
        signoff P&i; 
        %let next_signoff=%eval(&i+1); 
      %end; 
      %else %let i=&pnum; 
    %end; 

    *- if we have signed off all processes then exit the loop -; 
    %if &next_signoff GT &tasknum %then %goto finish; 

    %let old_plist=&plist; 
    %let plist=; 

    *- count how many processes have ended -; 
    %let numended=0; 
    %do i=1 %to %words(&old_plist); 
      %let pval=%scan(&old_plist,&i,%str( )); 
      %if &&stat&pval EQ 0 %then %let numended=%eval(&numended+1); 
      %else %let plist=&plist &pval; 
    %end; 

    *- launch a new task for each ended process -; 
    %do i=1 %to &numended; 
      %let pnum=%eval(&pnum+1); 
      %if &pnum LE &tasknum %then %do; 
        %let plist=&plist &pnum;
        %rsub(pnum=&pnum,task=&&task&pnum); 
      %end; 
      %else %let pnum=%eval(&pnum-1); 
    %end; 

    *- go back and wait for another process to end -; 
    %goto loop; 
  

    *#######  we have finished with all the remote sessions  ######; 
    %finish: 

    options &savopts;

  %end; %*- end of the test whether the user has SAS/CONNECT licensed -;

  %else %do; %*- SAS/CONNECT not licensed or streams=0 so no multiprocessing -;

    %if &streams NE 0 %then %PUT NOTE: (rsubmitter) SAS/CONNECT is not
licensed so all requested tasks will run sequentially in the local session;
    %else %PUT NOTE: (rsubmitter) streams=0 set so all requested tasks
will run sequentially in the local session;

    %do i=1 %to &tasknum;
      %let task=&&task&i;
      %let mactype=%scan(%substr(&task,2),1,=);
      %if "%upcase(&mactype)" EQ "INCLUDE" %then
        %let taskstr=INCLUDE %allafter(&task,=);
      %else %do;
        %let macname=%scan(%allafter(&task,=),1,%str( )); 
        %let params=%allafter(&task,=&macname);        
        %if %length(&parmreplace) %then %do;
          %do j=1 %to %words(%superq(parmreplace));
            %let parmpair=%scan(&parmreplace,&j,%str( ));
            %let parm1=%upcase(%scan(&parmpair,1,=));
            %let parm2=%upcase(%scan(&parmpair,2,=));
            %let params=%sysfunc(prxchange(s/\s&parm1\s*=/ &parm2=/i,
              1,%str( )%nrbquote(&params)));
          %end;
        %end;
        %let taskstr=&macname(%commaparmsu(%nrbquote(&params)));
      %end;
      %&taskstr;
    %end;

  %end;

  %goto skip;
  %exit: %put &err: (rsubmitter) Leaving macro due to problem(s) listed;
  %skip:

%mend rsubmitter;
/*<pre><b>
/ Program   : rxmatch.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return those space-delimited elements of a
/             list that match a specified rxparse pattern.
/ SubMacros : %words
/ Notes     : Refer to SAS documentation for how RX pattern matching works.
/             Non-matching elements get returned via the global macro variable
/             _nomatch_.
/ Usage     : %let match=%rxmatch(apopa pop aapop popaa,pop $s);
/             %put &match;
/ pop aapop
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ list              (pos) space-delimited-element list
/ rxpattern         (pos) RX pattern match
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: rxmatch v1.0;

%macro rxmatch(list,rxpattern);
  %local rx i;
  %global _nomatch_;
  %let _nomatch_=;
  %let rx=%qsysfunc(rxparse(&rxpattern));
  %do i=1 %to %words(&list);
    %if %sysfunc(rxmatch(&rx,%scan(&list,&i,%str( )))) %then %scan(&list,&i,%str( ));
    %else %let _nomatch_=&_nomatch_ %scan(&list,&i,%str( ));
  %end;
  %syscall rxfree(rx);
%mend rxmatch;
/*<pre><b>
/ Program   : samevars.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 25-Apr-2013
/ Purpose   : Function-style macro to return true (1) or false (0) if variables
/             in one dataset have the same variables and of the same type as
/             those in another dataset.
/ SubMacros : %hasvarsc %hasvarsn
/ Notes     : Use this on datasets where the combined variable count is 40 or
/             less due to the large amount of macro looping.
/ Usage     : %if not %samevars(dset1,dset2) %then %do....
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dset1             (pos) First dataset for comparison of variables
/ dset2             (pos) Second dataset for comparison of variables
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  25Apr13         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: samevars v1.0;

%macro samevars(dset1,dset2);
  %if %hasvarsc(&dset1,%varlistc(&dset2)) 
  and %hasvarsc(&dset2,%varlistc(&dset1))
  and %hasvarsn(&dset1,%varlistn(&dset2)) 
  and %hasvarsn(&dset2,%varlistn(&dset1))
  %then 1;
  %else 0;
%mend samevars;
/*<pre><b>
/ Program   : sas2tabdlm.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 14-Oct-2011
/ Purpose   : To write the contents of a sas dataset to a tab-delimited file
/ SubMacros : %varlist %words
/ Notes     : If a variable is formatted then that format is applied to the 
/             value.
/
/             If you do not specify a destination file then the contents will
/             be written to the log but the tab characters will not be seen.
/
/             You can use the %dlm2sas macro to convert the output file back
/             into a sas dataset but all columns will be treated as character.
/
/ Usage     : %sas2tabdlm(sashelp.cars,,yes)
/             %sas2tabdlm(sashelp.cars,C:\mylib\myfile.txt,yes)
/             %sas2tabdlm(sashelp.cars,"C:\mylib\myfile.txt",no)
/             %sas2tabdlm(sashelp.cars,"C:\mylib\myfile.txt")
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name (no modifiers)
/ dest              (pos) Destination file (quoted or unquoted)
/ varnames          (pos) By default, show the variable names in the first row.
/                   Set to no to suppress this.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  14Oct11         New
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: sas2tabdlm v1.0;

%macro sas2tabdlm(ds,dest,varnames);

  %local i varlist numvars;

  %if not %length(&varnames) %then %let varnames=yes;
  %let varnames=%upcase(%substr(&varnames,1,1));

  %let varlist=%varlist(&ds);
  %let numvars=%words(&varlist);

  %if not %length(&dest) %then %let dest=log;
  %else %let dest="%sysfunc(dequote(&dest))";

  data _null_;
    file &dest;
    set &ds;
    %if &varnames NE N %then %do;
      if _n_=1 then do;
        %do i=1 %to %eval(&numvars-1);
          put "%scan(&varlist,&i,%str( ))" "09"x @;
        %end;
        put "%scan(&varlist,&numvars,%str( ))";
      end;
    %end;
    %do i=1 %to %eval(&numvars-1);
      put %scan(&varlist,&i,%str( )) +(-1) "09"x @;
    %end;
    put %scan(&varlist,&numvars,%str( ));
  run;

%mend sas2tabdlm;/*<pre><b>
/ Program      : sas2xpt.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 10-Aug-2012
/ Purpose      : Create multiple transport files from sas datasets
/ SubMacros    : %prxnames
/ Notes        : Normal practice is to include multiple sas datasets in a
/                transport file and this is easily achieved using a single call
/                to 'proc copy'. This macro was written for those cases where
/                there must be separate transport files corresponding to each
/                sas dataset (which is typical for FDA electronic submissions).
/
/                Paths specified must end in a slash and must be enclosed in
/                double quotes. If the path name contains special characters
/                such as '&' or '%' then the double-quoted path name should be
/                enclosed in %nrstr( ) to stop sas trying to resolve these
/                symbols.
/
/                Note that transport files in SAS must match SAS version 6
/                restrictions such as character variables having a maximum
/                length of 200, variable names limited to eight characters and
/                variable labels limited to 40 characters. Your input datasets
/                must also abide by these restrictions even if created with
/                later versions of SAS. You might find the %checkv6 macro useful
/                for checking your datasets for compatibility.
/
/                Pay careful attention to any warning or error messages that
/                may appear in the log as well as note statements about the
/                truncation of variable labels where features of the input
/                datasets may be incompatible with transport file restrictions.
/
/ Usage        : %sas2xpt((INDSLIB),%nrstr("V:\SAS\Two Parts\X&Y\temp\"));
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ in                (pos) Either the full path name of the input folder
/                   containing the sas datasets (same naming rules as below) or
/                   an existing libref contained in round brackets such as
/                   (WORK) (no quotes)
/ outfolder         (pos) Full path name of output folder to hold created .xpt
/                   files (must end in a slash, must be enclosed in double
/                   quotes and if containing special characters such as "&" or
/                   "%" must also be enclosed by %nrstr( )  )
/ dslist            Optional list of datasets separated by spaces (no quotes)
/                   to create transport files from. You can use the end colon
/                   notation to denote datasets beginning with the preceding
/                   characters. Default is to use all datasets found so this can
/                   be left blank.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  02Feb11         New (v1.0)
/ rrb  10Aug12         Header update
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%macro sas2xpt(in,outfolder,dslist=);

  libname _sas2xpt &in;

  proc sql noprint;
    create table _sas2cont as
    (select memname from dictionary.tables
     where libname="_SAS2XPT" and memtype="DATA"
     %if %length(&dslist) %then %do;
       and prxmatch(%prxnames(&dslist),memname)
     %end;
     ) order by memname;
  quit;

  data _null_;
    retain outxpt &outfolder;
    set _sas2cont;
    call execute("libname _xptout xport %nrstr('"||trim(outxpt)||trim(memname)||".xpt');");
    call execute('proc copy in=_sas2xpt out=_xptout;select '||trim(memname)||';run;');
    call execute('libname _xptout clear;');
  run;

  libname _sas2xpt clear;

  proc datasets nolist memtype=data;
    delete _sas2cont;
  run;
  quit;

%mend sas2xpt;
/*<pre><b>
/ Program   : savopts.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 14-Jun-2011
/ Purpose   : Function-style macro to return a list of active sas options so
/             that these options can be restored at a later point.
/ SubMacros : none
/ Notes     : %sysfunc(getoption(OPTION,keyword)) is used and for badly formed
/             responses such as "MISSING= " then these are corrected.
/ Usage     : %let savopts=%savopts(missing mprint);
/             option &savopts;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ optlist           (pos) Options to save separated by spaces (no quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: savopts v1.0;

%macro savopts(optlist);
  %local i bit resp newopts;
  %let i=1;
  %let bit=%scan(&optlist,&i,%str( ));
  %do %while(%length(&bit));
    %let resp=%sysfunc(getoption(&bit,keyword));
    %if "&resp" EQ "MISSING=" %then %let resp=MISSING=" ";
    %else %if "&resp" EQ "FORMDLIM=" %then %let resp=FORMDLIM=" ";
    %let newopts=&newopts &resp;
    %let i=%eval(&i+1);
    %let bit=%scan(&optlist,&i,%str( ));
  %end;
&newopts
%mend savopts;
/*<pre><b>
/ Program   : scandlm.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 22-Mar-2013
/ Purpose   : Function-style macro to return a scan of a string with its
/             delimiter shown in front.
/ SubMacros : none
/ Notes     : none
/ Usage     : %put %scandlm(&str,2,*#);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/ num               (pos) Position
/ dlm               (pos) Delimiters (not quoted)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  22Mar13         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: scandlm v1.0;

%macro scandlm(str,num,dlm);
  %local pos len;
  %let pos=0;
  %let len=0;
  %let bit=%qscan(%nrbquote(&str),&num,&dlm);
  %syscall scan(str,num,pos,len,dlm);
  %let pos=%eval(&pos-1);
  %if &pos GT 0 %then %qsubstr(%nrbquote(&str),&pos,1)%nrbquote(&bit);
  %else %nrbquote(&bit);
%mend scandlm;
/*<pre><b>
/ Program   : scanfile.sas
/ Version   : 3.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 19-Sep-2011
/ Purpose   : Counts the number of lines of text in a file that contain the
/             string or the regular expression you specify within the line limit
/             you choose and optionally writes the line or blocks of lines to
/             the log.
/ SubMacros : none
/ Notes     : This macro is useful for scanning LST files to ensure they contain
/             strings such as population set identifiers and subgroup
/             identifiers. The search can be case sensitive or not as you wish.
/             If you set a low line limit then you could aim to just search the
/             titles on the first page of .LST output.
/
/             Setting prx=yes allows you to use the more powerful Perl Regular
/             Expressions to search on in which case you can use the "or" ()
/             symbol to search on multiple terms.
/
/             The result of the number of lines matching the pattern you specify
/             will be written to the global macro variable _lines_ .
/
/             If you specify a file that does not exist then no error message
/             will be put out by this macro. Instead, _lines_ will be set to
/             DNE and it is up to the user to take action based on that.
/
/             If an error message is issued then _lines_ will be  null (i.e. it
/             will be blank).
/
/             If the file exists but is empty then _lines_ will be set to
/             EMPTY .
/
/             You can write blocks of lines to the log using the printmore=
/             parameter to state a specific number of lines to print after the
/             matching line or using the untilstr= parameter to signal a line
/             match to stop writing more lines.
/
/ Usage     : %scanfile(C:\temp\myfile.lst,Treated,3,casesens=no)
/
/             *-- Complex example of scanning all the sas programs   --;
/             *-- in a library and printing the "proc format" steps. --;
/             %doallitem(%qreadpipe(dir /B C:\Mylib\*.sas),
/             '%scanfile(C:\Mylib\&item,proc format,
/             untilstr=run,notstr=cntlin,casesens=no)');
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/      (note that enclosing quotes will be ignored for "file" and "str")
/ file              (pos) Full file path of file you wish to search
/ str               (pos) String or regular expression you wish to search on
/ limit             (pos) Number of lines limit to search
/ casesens=yes      By default, search is case sensitive
/ prx=no            By default, the string is not a perl regular expression
/ print=no          By default, do not print the matching lines
/ printmore=0       By default, do not print this extra number of lines after
/                   finding a match.
/ untilstr          String or regular expression to signal the last of the extra
/                   lines to print.
/ notstr            String or regular expression to exclude a match on str
/ _n_=no            By default, do not display the line numbers
/ silent=no         By default, put out a message to the log for all the files
/                   being scanned whether the string was found or not.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  08Sep11         new (v1.0)
/ rrb  12Sep11         existerr= parameter added (v1.1)
/ rrb  13Sep11         print=, printmore=, notstr= and untilstr= parameters
/                      added (v2.0)
/ rrb  15Sep11         _n_= and silent= parameters added (v2.1)
/ rrb  17Sep11         existerr= processing removed so that this macro will not
/                      issue an error message if a file does not exist but will
/                      instead set _lines_ to DNE (v3.0)
/ rrb  19Sep11         _lines_ now set to EMPTY for an empty file so that it
/                      works the same way as the %gettitles macro (v3.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: scanfile v3.1;

%macro scanfile(file,str,limit,
               untilstr=,
                 notstr=,
                  print=no,
              printmore=0,
                    prx=no,
               casesens=yes,
                    _n_=no,
                 silent=no);

  %local err errflag savopts;
  %let savopts=%sysfunc(getoption(notes));

  options nonotes;

  %let err=ERR%str(OR);
  %let errflag=0;

  %global _lines_;
  %let _lines_=;


  %if not %length(&silent) %then %let silent=no;
  %let silent=%upcase(%substr(&silent,1,1));

  %if not %length(&printmore) %then %let printmore=0;

  %if %length(&untilstr) %then %let printmore=99;

  %if &printmore GT 0 %then %let print=yes;

  %if not %length(&_n_) %then %let _n_=no;
  %let _n_=%upcase(%substr(&_n_,1,1));
  %if &_n_ EQ Y %then %let _n_=_n_=;
  %else %let _n_=;

  %if not %length(&print) %then %let print=no;
  %let print=%upcase(%substr(&print,1,1));


  %if not %length(&file) %then %do;
    %let errflag=1;
    %put &err: (scanfile) No file specified to the first positional parameter;
  %end;
  %else %do;
    %let file=%sysfunc(dequote(&file));
    %if not %sysfunc(fileexist(&file)) %then %do;
      %let _lines_=DNE;
      %goto skip;
    %end;
  %end;

  %if not %length(&str) %then %do;
    %let errflag=1;
    %put &err: (scanfile) No search string specified to the second positional parameter;
  %end;

  %if %length(&limit) %then %do;
    %if %length(%sysfunc(compress(&limit,0123456789))) %then %do;
      %let errflag=1;
      %put &err: (scanfile) Third positional parameter must be a positive integer limit=&limit;
    %end;
  %end;

  %if &errflag %then %goto exit;


  %if not %length(&casesens) %then %let casesens=yes;
  %let casesens=%upcase(%substr(&casesens,1,1));

  %if not %length(&prx) %then %let prx=no;
  %let prx=%upcase(%substr(&prx,1,1));

  %if &prx EQ Y %then %do;
    %if &casesens EQ Y %then %let casesens=;
    %else %let casesens=i;
  %end;

  %let _lines_=0;

  data _null_;
    retain printmore . gotit 0;
    infile "&file" eof=eof;
    input;
    %if &print EQ Y and &silent NE Y %then %do;
      if _n_=1 then put / ">>>>>>>>>>>>>>>>>>> scanning file &file";
    %end;
    %if %length(&limit) %then %do;
      if _n_>&limit then goto eof;
    %end;
    %if &prx EQ Y %then %do;
      if prxmatch("/%sysfunc(dequote(&str))/&casesens",_infile_) 
      %if %length(&notstr) %then %do;
        and not prxmatch("/%sysfunc(dequote(&notstr))/&casesens",_infile_) 
      %end;
      then do;
        numlines+1;
        printmore=&printmore;
        %if &print EQ Y %then %do;
          %if &silent EQ Y %then %do;
            if gotit eq 0 then put / ">>>>>>>>>>>>>>>>>>> scanning file &file";
          %end;
          put &_n_ _infile_;
        %end;
        gotit=1;
      end;
      %if %length(&untilstr) %then %do;
        else if printmore>0 and
        prxmatch("/%sysfunc(dequote(&untilstr))/&casesens",_infile_) then do;
          printmore=0;
          put &_n_ _infile_;
        end;
      %end;
      else do;
        if printmore>0 then do;
          put &_n_ _infile_;
          printmore=printmore-1;
        end;
      end;
    %end;
    %else %do;
      %if &casesens EQ N %then %do;
        if index(upcase(_infile_),%upcase("%sysfunc(dequote(&str))"))
        %if %length(&notstr) %then %do;
          and not index(upcase(_infile_),%upcase("%sysfunc(dequote(&notstr))"))
        %end;
        then do;
          numlines+1;
          printmore=&printmore;
          %if &print EQ Y %then %do;
            %if &silent EQ Y %then %do;
              if gotit eq 0 then put / ">>>>>>>>>>>>>>>>>>> scanning file &file";
            %end;
            put &_n_ _infile_;
          %end;
          gotit=1;
        end;
        %if %length(&untilstr) %then %do;
          else if printmore>0 and 
          index(upcase(_infile_),%upcase("%sysfunc(dequote(&untilstr))")) then do;
            printmore=0;
            put &_n_ _infile_;
          end;
        %end;
        else do;
          if printmore>0 then do;
            put &_n_ _infile_;
            printmore=printmore-1;
          end;
        end;
      %end;
      %else %do;
        if index(_infile_,"%sysfunc(dequote(&str))")
        %if %length(&notstr) %then %do;
          and not index(_infile_,"%sysfunc(dequote(&notstr))")
        %end;
        then do;
          numlines+1;
          printmore=&printmore;
          %if &print EQ Y %then %do;
            %if &silent EQ Y %then %do;
              if gotit eq 0 then put / ">>>>>>>>>>>>>>>>>>> scanning file &file";
            %end;
            put &_n_ _infile_;
          %end;
          gotit=1;
        end;
        %if %length(&untilstr) %then %do;
          else if printmore>0 and
          index(_infile_,"%sysfunc(dequote(&untilstr))") then do;
            printmore=0;
            put &_n_ _infile_;
          end;
        %end;
        else do;
          if printmore>0 then do;
            put &_n_ _infile_;
            printmore=printmore-1;
          end;
        end;
      %end;
    %end;
  return;
  eof:
    if _n_=1 and _infile_=" " then call symput('_lines_',"EMPTY");
    else call symput('_lines_',compress(put(numlines,13.)));
    stop;
  return;
  run;

  %goto skip;
  %exit: %put &err: (scanfile) Leaving macro due to problem(s) listed;
  %skip:

  options &savopts;

%mend scanfile;
/*<pre><b>
/ Program   : scanlog.sas
/ Version   : 3.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 31-Oct-2013
/ Purpose   : To scan sas log file(s) or the log window for important messages
/             optionally using a "rules" file.
/ SubMacros : none
/ Notes     : For the log file you can either supply a full file name in quotes
/             or an unquoted fileref. This can be a mixed list separated by
/             spaces. If not set then the interactive log window is assumed.
/
/             To automatically supply a directory list of full-path quoted file
/             names then use %lsfpq (Unix) or %dirfpq (Windows) in the supplied
/             parameter value (see examples in the usage notes below).
/
/             Because mixed types (filerefs and filenames) are allowed then no
/             checking will be done for the existence of these files so you
/             should ensure that they really exist.
/
/             If you are running interactively and have not set any parameters
/             then the contents of your log window will be copied to a temporary
/             file with libref _savelog where it will be scanned and diagnostics
/             will be written to print output and the _savelog libref will be
/             cleared at the end of the macro call.
/
/             To use this macro efficiently in interactive sas sessions you can
/             assign a call to this macro to a function key by pressing the F9
/             function key and assigning the exact text of the gsubmit statement
/             in the usage notes below to your chosen function key and saving it
/             using the disk icon. Once done then if you press that function key
/             in the future it will scan what is in the log window for important
/             messages and report diagnostics to print output. This print output
/             can be deleted using the results window on the left when no longer
/             required so as not to clutter the output.
/
/             If you are running an interactive session and this macro is not on
/             your autocall path you can activate it by copying and pasting into
/             a pgm window, make any desired edits to the searches if required,
/             and then compile it by running it. There is no need to save it and
/             used this way you can change the search code as needed without
/             affecting other users.
/
/             You can specify a "rules" text file with this macro and you can
/             optionally specify that the contents of this "rules" file be
/             treated as Perl Regular Expressions. Used in this way you can scan
/             any type of text file (not just sas logs). See the description of
/             the rulesfile parameter below for further details.
/
/             FEEL FREE TO HARDCODE CHANGES TO THE SEARCH in the code below.
/             Your site standards to highlight errors, warnings and notes will
/             be different from mine so feel free to change the code to match
/             your site standards. Changing the code is more efficient than
/             using a rules file.
/
/ Usage     : %scanlog("full-file-path-name")
/             %scanlog("full-file-path-name-1" "full-path-name-2")
/             %scanlog(fileref)
/             %scanlog(fileref(a.log) fileref(b.log))
/             %scanlog(fileref "full-path-name")
/             %scanlog(%lsfpq(/usr/mypath/*.log))
/             %scanlog(%dirfpq(C:\temp\*.log))
/             %scanlog(fileref(a.log) "full-path-name" %dirfpq(C:\temp\*.log))
/             %scanlog;         *- this is for interactive sas sessions -;
/             %scanlog(,log);   *- this is for interactive sas sessions -;
/             %scanlog(fileref,"output-file")
/             %scanlog(rulesfile=C:\temp\myrules.txt)
/             %scanlog(rulesfile="C:\temp\myrules.txt")
/             %scanlog(rulesfile="C:\temp\myrules.txt",prx=yes)
/               or in command line box for interactive sessions (note syntax):
/             gsubmit '%scanlog;'
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ logfile           (pos) Log file(s) to scan (separated by spaces). You must
/                   quote file names but must not quote fileref members.
/ dest              (pos) Destination for diagnostics. Normally it is the log
/                   but for interactive sessions where this macro is called
/                   with no parameters set then the destination will be print
/                   output so that it does not mess up the log. But you can set
/                   this to log, print or a file in quotes to override this
/                   behaviour.
/ has0obs=no        By default do not scan for " has 0 observations ". This has
/                   no effect if the rules file is used. It allows you to switch
/                   on or off this search since in some cases it is useful and
/                   for other cases not.
/ rulesfile         Rules file (quoted or unquoted). This overrides the hard-
/                   coded searches if set and is a plain text file of what lines
/                   to accept, followed by a single blank line, followed by
/                   which lines to reject. No other lines such as comment lines
/                   are allowed. Leading and trailing spaces are significant so
/                   take care that there are the right number of spaces at the                
/                   end of each line even though not visible.
/
/                   Note that these lines will be treated as plain text but if
/                   there is a ^ at the beginning of the line then it will be
/                   assumed that you want the following string to be found at
/                   the start of the line only. If you want the lines to be 
/                   treated as Perl Regular Expressions then set prx=yes in
/                   which case the "^" at the beginning of a line also signifies
/                   the following string must be found at the start of a line.
/
/ prx=no            By default, do not treat the contents of the "rules" file as
/                   Perl Regular Expressions.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jul11         More checks added and added automatic handling and easy
/                      calling for interactive sas sessions (v2.0)
/ rrb  27Jul11         Improve display message for interactive sessions (v2.1)
/ rrb  28Jul11         Minor tidy up in header and searches
/ rrb  31Jul11         Rules file, Perl Regular Expression, has0obs= and
/                      multiple log files processing added (v3.0)
/ rrb  19Aug11         header update
/ rrb  31Oct13         "options notes" and "options nonotes" placed before and
/                      after the scanning data step and FATAL search added for
/                      position 1 in the log (v3.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: scanlog v3.1;

%macro scanlog(logfile,
                  dest,
             rulesfile=,
               has0obs=no,
                   prx=no
              );

  %local savopts err errflag logid i fl;

  %let savopts=%sysfunc(getoption(NOTES)) %sysfunc(getoption(MPRINT));
  options NONOTES NOMPRINT;

  %let err=ERR%str(OR);
  %let errflag=0;


        /****************************************
                Set up parameter defaults
         ****************************************/

  %if not %length(&prx) %then %let prx=no;
  %let prx=%upcase(%substr(&prx,1,1));

  %if not %length(&has0obs) %then %let has0obs=no;
  %let has0obs=%upcase(%substr(&has0obs,1,1));

  %if %length(&rulesfile) %then %do;
    %let rulesfile=%sysfunc(dequote(&rulesfile));
    %if not %sysfunc(fileexist(&rulesfile)) %then %do;
      %put &err: (scanlog) Rules file "&rulesfile" can not be found;
      %let errflag=1;
    %end;
  %end;

  %*- Interactive sessions where the macro is called without parameters and   -;
  %*- so we assume the log window needs scanning and we want the diagnostics  -;
  %*- put some place other than the log so best place is print output instead.-;
  %*- So we set the destination to print output and copy the log window       -;
  %*- contents to a temporary file where we can scan it and discard it later. -;
  %if (&sysenv EQ FORE) and (not %length(&logfile)) %then %do;
    %if not %length(&dest) %then %let dest=print;
    filename _savelog temp;
    dm "log; file _savelog;";
    %let logfile=_savelog;
  %end;

  %if not %length(&logfile) %then %do;
    %put &err: (scanlog) No log file specified as first positional parameter;
    %let errflag=1;
  %end;

  %if &errflag %then %goto exit;

  %*- set up the destination if not set -;
  %if not %length(&dest) %then %let dest=log;
  %else %do;
    %if "%upcase(%sysfunc(dequote(&dest)))" EQ "LOG" %then %let dest=log;
    %else %if "%upcase(%sysfunc(dequote(&dest)))" EQ "PRINT" 
      %then %let dest=print notitles;
  %end;


        /****************************************
                 Generate the rules code
         ****************************************/

  %if %length(&rulesfile) %then %do;
    filename _rulcode temp;

    *-- Generate the rules code and write it to a temporary file --;

    %if &prx EQ Y %then %do;
      data _null_;
        retain switch 0;
        file _rulcode;
        infile "&rulesfile" eof=eof;
        input;
        if _n_=1 then do;
          put 'if (';
          put '   prxmatch("/' _infile_ '/",_infile_)';
        end;
        else if _infile_ = " " then do;
          put ' ) and not (';
          switch=1;
        end;
        else do;
          if switch=1 then do;
            switch=0;
            put '   prxmatch("/' _infile_ '/",_infile_)';
          end;
          else put 'or prxmatch("/' _infile_ '/",_infile_)';
        end;
      return;
      eof:
        put ') then put _infile_;';
      return;
      run;
    %end;

    %else %do;
      data _null_;
        length tempstr $ 200;
        retain switch 0;
        file _rulcode;
        infile "&rulesfile" eof=eof;
        input;
        if _n_=1 then do;
          put 'if (';
          if substr(_infile_,1,1)='^' then do;
            tempstr='   index(_infile_,"'||substr(_infile_,2)||'")=1';
            put tempstr;
          end;
          else put '   index(_infile_,"' _infile_ '")';
        end;
        else if _infile_ = " " then do;
          put ' ) and not (';
          switch=1;
        end;
        else do;
          if switch=1 then do;
            switch=0;
            if substr(_infile_,1,1)='^' then do;
              tempstr='   index(_infile_,"'||substr(_infile_,2)||'")=1';
              put tempstr;
            end;
            else put '   index(_infile_,"' _infile_ '")';
          end;
          else do;
            if substr(_infile_,1,1)='^' then do;
              tempstr='or index(_infile_,"'||substr(_infile_,2)||'")=1';
              put tempstr;
            end;
            else put 'or index(_infile_,"' _infile_ '")';
          end;
        end;
      return;
      eof:
        put ') then put _infile_;';
      return;
      run;
    %end;
  %end;


        /****************************************
            Define the macro to scan each file
         ****************************************/

  %macro _scanlog(file);

    %*- set up a suitable message to say what log is being worked on --;
    %let logid=file %sysfunc(dequote(&file));
    %if (&sysenv EQ FORE) and (&file EQ _savelog) %then
      %let logid=Interactive SAS session log;


    *-- search on the terms either using "rule file" generated code or default --;

    *- NOTES has to be forced into effect for the scanning -;
    *- data step otherwise the important messages searched -;
    *- for in the NOTE: lines will not be written.         -;
    OPTIONS NOTES;
    data _null_;
      infile &file eof=eof;
      file &dest ;
      input;
      if _n_=1 then
  put / / "============== Scanning &logid for important messages ==============";
      %if %length(&rulesfile) %then %do;
        %include _rulcode;
      %end;
      %else %do;
        if (
           index(_infile_,"ERROR")=1
        or index(_infile_,"WARNING")=1
        or index(_infile_,"FATAL")=1
        or index(_infile_,"MERGE statement has more ")
        or index(_infile_,"W.D format")
        or index(_infile_," truncated ")
        or index(_infile_," outside the axis range ")
        or index(_infile_,"NOTE: Invalid")=1
        or index(_infile_," uninitialized")
        or index(_infile_,"was not found or could not be loaded")
        or index(_infile_,"Duplicate BY variable(s)")
        or index(_infile_,"Mathematical operations could not")
        or index(_infile_,"Division by zero")
        %if "&has0obs" EQ "Y" %then %do;
          or index(_infile_," has 0 observations ")
        %end;  
           )
        and not (
           index(_infile_,"BY-line has been truncated")
        or index(_infile_,"The length of data column ")
        or index(_infile_,"Errors printed on")
        or index(_infile_,"scheduled to expire on")
        or index(_infile_,"product with which")
        or index(_infile_,"representative to have")
        or index(_infile_,"The Remote engine is active. The updated SHARESESSIONCNTL")
        or index(_infile_,"Computing exact confidence limits for")
        )
        then put _infile_;
      %end;
    return;
    eof:
    put "=================== Finished scanning &logid =======================";
    return;
    run;
    OPTIONS NONOTES;
  %mend _scanlog;


        /****************************************
            Call the scan macro for each file
         ****************************************/

  %let fl=%sysfunc(scanq(&logfile,1,%str( )));
  %_scanlog(&fl);
  %let i=2;
  %let fl=%sysfunc(scanq(&logfile,&i,%str( )));
  %do %while(%length(&fl));
    %_scanlog(&fl);
    %let i=%eval(&i+1);
    %let fl=%sysfunc(scanq(&logfile,&i,%str( )));
  %end;


        /****************************************
                    Tidy up and exit
         ****************************************/

  %*- Free the temporary fileref if we set it above -;
  %if (&sysenv EQ FORE) and (&logfile EQ _savelog) %then %do;
    filename _savelog clear;
  %end;

  *- Free the temporary file containing rules code -;
  %if %length(&rulesfile) %then %do;
    filename _rulcode clear;
  %end;

  *- delete the internally defined macro -;
  proc catalog catalog=work.sasmacr entrytype=macro;
    delete _scanlog;
  quit;


  %goto skip;
  %exit: %put &err: (scanlog) Leaving macro due to problem(s) listed;
  %skip:

  options &savopts;

%mend scanlog;
/*<pre><b>
/ Program   : sep2sp.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 26-Mar-2013
/ Purpose   : Function-style macro to convert groups of commas and spaces in a
/             string to single spaces.
/ SubMacros : none
/ Notes     : "sep2sp" is best remembered as "separators" to "spaces" where the
/             separators are groups of spaces and commas that will each be
/             replaced by a single space. If your string contains commas then
/             you should surround the string with %nrbquote() when calling this
/             macro.
/ Usage     : %let newstr=%sep2sp(%nrbquote(a  , b,    ,,, c));
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String to convert
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Mar13         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: sep2sp v1.0;

%macro sep2sp(str);
%sysfunc(prxchange(s|[%str( )%str(,)]+|%str( )|,-1,%nrbquote(&str)))
%mend sep2sp;

/*<pre><b>
/ Program   : sep2u.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 24-Aug-2012
/ Purpose   : Function-style macro to convert groups of commas and spaces in a
/             string to single underscores.
/ SubMacros : none
/ Notes     : "sep2u" is best remembered as "separators" to "underscores" where
/             the separators are groups of spaces and commas that will each be
/             replaced by a single underscore. If your string contains commas
/             then you should surround the string with %nrbquote() when calling
/             this macro.
/ Usage     : %let newstr=%sep2u(%nrbquote(a  , b,    ,,, c));
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String to convert
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  24Aug12         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: sep2u v1.0;

%macro sep2u(str);
%sysfunc(prxchange(s|[%str( )%str(,)]+|%str(_)|,-1,%nrbquote(&str)))
%mend sep2u;
/*<pre><b>
/ Program      : showhex.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : To create a new dataset where hex characters in character
/                variables are highlighted.
/ SubMacros    : %varlistc %words
/ Notes        : Variables in the output dataset will have the same name as
/                those in the input dataset but they will be changed to show up
/                hex characters as hex numbers in < > brackets and the variable
/                length will be as defined to the length= parameter. If no
/                variable list is specified then all character variables are 
/                assumed. If badonly=yes then an extra variable named __obs is
/                retained in the output dataset set to the matching observation
/                number in the input dataset.
/ Usage        : %showhex(test1,test2,cvar1 cvar2 cvar3)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsin              (pos) name of inout dataset (no modifiers)
/ dsout             (pos) name of output dataset (no modifiers)
/ vars              (pos) (optional) character variables (separated by spaces)
/ length=200        Length of the new character variables in the output dataset
/ badonly=yes       By default keep only those observations where hex characters
/                   were found in one or more of the listed character variables.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: showhex v1.0;

%macro showhex(dsin,dsout,vars,length=200,badonly=yes);

  %local i var words errflag err;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&badonly) %then %let badonly=yes;
  %let badonly=%upcase(%substr(&badonly,1,1));
  %if not %length(&vars) %then %let vars=%varlistc(&dsin);


  %if not %length(&dsin) %then %do;
    %put &err: (showhex) No input dataset specified;
    %let errflag=1;
  %end;

  %if not %length(&dsout) %then %do;
    %put &err: (showhex) No output dataset specified;
    %let errflag=1;
  %end;

  %if &errflag %then %goto exit;


  %let words=%words(&vars);

  data &dsout;
    length __char $ 1 __temp1 __temp2 &vars $ &length;
    set &dsin(keep=&vars rename=(
              %do i=1 %to &words;
                %let var=%scan(&vars,&i,%str( ));
                &var=_&var
              %end;
              ));
    __bad=0;
    __obs=_n_;
    %do i=1 %to &words;
      %let var=%scan(&vars,&i,%str( ));
      __temp1=_&var;
      link conv;
      &var=__temp2;
    %end;
    %if "&badonly" EQ "Y" %then %do;
      if __bad then output;
    %end;
    %else %do;
      drop __obs;
    %end;
    drop __temp1 __temp2 __pos __rank __char __i __bad
      %do i=1 %to &words;
        %let var=%scan(&vars,&i,%str( ));
        _&var
      %end;
    ;
    return;
  conv:
    *- converts what is in __temp1 to __temp2 with hex expanded -;
    __temp2=' ';
    __pos=1;
    do __i=1 to length(__temp1);
      __char=substr(__temp1,__i,1);
      __rank=rank(__char);
      if __rank<0020x or __rank>00FFx then do;
      *if __rank<0020x or (007Ex < __rank < 00C0x) 
      and __rank not in (00B0x, 00B4x, 00B5x, 00AEx) then do;
        substr(__temp2,__pos,4)='<'||put(__rank,hex2.)||'>';
        __pos=__pos+4;
        __bad=1;
      end;
      else do;
        substr(__temp2,__pos,1)=__char;
        __pos=__pos+1;
      end;
    end;
  return;
  run;

  %goto skip;
  %exit: %put &err: (showhex) Leaving macro due to problem(s) listed;
  %skip:

%mend showhex;
/*<pre><b>
/ Program   : sortedby.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the variables a dataset is sorted
/             by, or null if not sorted.
/ SubMacros : %attrc
/ Notes     : This is a shell macro that calls %attrc
/ Usage     : %let sortedby=%sortedby(dsname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: sortedby v1.0;

%macro sortedby(ds);
  %attrc(&ds,sortedby)
%mend sortedby;
/*<pre><b>
/ Program   : splitmac.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 08-May-2011
/ Purpose   : Function-style macro to insert split characters in a macro string
/ SubMacros : none
/ Notes     : This is the sister macro to %splitmac except it works on macro
/             values instead of SAS variables. It is a function-style macro.
/
/             A split character will normally be placed in a blank space. If
/             there is no suitable space then it will be inserted after a hyphen.
/             But if there is no suitable space and no hyphen then it will be
/             inserted at the end. 
/
/             This macro will only look back the floor of half the column width
/             to find a place to insert the split character.
/
/             If the input string has one or more equals signs in it then
/             enclose the string in %str(). If it has one or more commas in it
/             then enclose it in %quote().
/
/ Usage     : %let str=The quick brown fox jumped over the lazy dog;
/             %let splitstr=%splitmac(&str,10);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) Macro string to split.
/ cols              (pos) Maximum number of columns allowed.
/ split=*           Split character. Must be a single character, unquoted.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  08May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: splitmac v1.0;

%macro splitmac(str,cols,split=*);

  %local errflag err _cols tempstr res;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&str) %then %do;
    %let errflag=1;
    %put &err: (splitmac) No string supplied as first positional parameter;
  %end;

  %if not %length(&cols) %then %do;
    %let errflag=1;
    %put &err: (splitmac) No column width supplied as second positional parameter;
  %end;
  %else %if %sysfunc(verify(&cols,1234567890)) %then %do;
    %let errflag=1;
    %put &err: (splitmac) Cols parameter "&cols" not a valid number of columns;
  %end;

  %if not %length(&split) %then %let split=*;

  %if %length(&split) GT 1 %then %do;
    %let errflag=1;
    %put &err: (splitmac) Split character &split is not a single unquoted character;
  %end;

  %if &errflag %then %goto exit;

  %let tempstr=&str;

  %do %while(%length(&tempstr) GT &cols);
    %do _cols=(&cols+1) %to %eval(&cols/2) %by -1;
      %if "%qsubstr(%quote(&tempstr),&_cols,1)" EQ " " %then %do;
        %let res=&res%qsubstr(%quote(&tempstr),1,%eval(&_cols - 1))&split;
        %let tempstr=%qsubstr(%quote(&tempstr),%eval(&_cols+1));
        %let _cols=1;
      %end;
    %end;
    %*- if space character not found look for a hyphen -;
    %if &_cols GT 1 %then %do;
      %do _cols=&cols %to %eval(&cols/2) %by -1;
        %if "%qsubstr(%quote(&tempstr),&_cols,1)" EQ "-" %then %do;
          %let res=&res%qsubstr(%quote(&tempstr),1,&_cols)&split;
          %let tempstr=%qsubstr(%quote(&tempstr),%eval(&_cols+1));
          %let _cols=1;
        %end;
      %end;
    %end;
    %*- if no hyphen found then split at end -;
    %if &_cols GT 1 %then %do;
      %let res=&res%qsubstr(%quote(&tempstr),1,&cols)&split;
      %let tempstr=%qsubstr(%quote(&tempstr),&cols+1);
    %end;
  %end;

&res&tempstr

  %goto skip;
  %exit: %put &err: (splitmac) Leaving macro due to problem(s) listed;
  %skip:

%mend splitmac;
/*<pre><b>
/ Program   : splitvar.sas
/ Version   : 4.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 06-Mar-2012
/ Purpose   : In-datastep macro to insert split characters in a string variable
/ SubMacros : none
/ Notes     : A split character will normally be placed in a blank space. If
/             there is no suitable space then it will be inserted after a hyphen
/             or a comma but if there is no suitable space and no hyphen or
/             comma then it will be inserted at the end. Searches for spaces
/             and hyphens or commas are only done for half the column width so
/             that the number of lines used for overflow is kept to a limit.
/
/             The string with the split characters added will normally be
/             assigned to a new variable whose name you choose. If left blank
/             then the new string in reassigned to the input variable.
/
/             Indentation is maintained such that if you had to split a string
/             which was indented two spaces then the next segment of the string
/             will also be indented two spaces. You can add to this indentation
/             to create a "hanging indent" using the hindent= parameter to make
/             it clearer that following line segments are a continuation of the
/             first one.
/
/             This macro is a rewrite of the earlier versions of the same name
/             and there is no backward compatibility possible.
/
/             This macro will only work on Western character sets such that one
/             letter uses one byte. If you want a macro to work with Asian
/             characters then you will have to make a copy of this macro that
/             uses the "k" functions such as klength(), ksubstr() etc. in place
/             of the normal string functions as used in this macro. If somebody
/             wants to do this then please call the macro %ksplitvar and get in
/             contact with me. Do not make changes to the logic, just amend the
/             code in this macro as the logic is very complicated.
/
/             Note that this is not a function-style macro. It must be used in a
/             data step as shown in the usage notes.
/
/ Usage     : data aaa;
/               set aaa;
/               %splitvar(oldvar,newvar,10,split=/,hindent=0);
/             run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ oldvar            (pos) Variable to split.
/ newvar            (pos) New variable created with split characters added.
/ width             (pos) The maximum width of the column as displayed.
/ split=@           Split character. Must be a single character (quoted or
/                   unquoted).
/ spliton=",-"      Characters to split after (quoted)
/ splitat=" "       Preferred character to split at (quoted - the split
/                   character will replace this character).
/ colon=": "        Colon character string for indented splits (quoted)
/ hindent=0         By default, do not show following string segments with a 
/                   hanging indent. Set to a positive integer to indent the
/                   following line segments by that number of spaces.
/ usecolon=yes      By default, if ": " occurs in the string start within 30% of
/                   the defined width then use this to align following line
/                   segments.
/ biglen=8040       Default large working length
/===============================================================================
/ TEST CODE FOLLOWS:
/===============================================================================
options nocenter nonumber nodate;
title;

%let width=30;
%let split=/;
%let hindent=4;

data test;
length term $ 200;
term="SOC short term";
output;
term="  PT short 1";
output;
term="  PT short 2";
output;
term=" ";
output;
term="System Organ Class long term that is going to flow to more lines";
output;
term="  PT short 1";
output;
term="  PT short 2";
output;
term="  Preferred term code that is also long and is going to flow to more lines";
output;
term="  Indented: preferred term code that is also long and is going to flow to more lines";
output;
term="  Indented comma-delimited list of patient numbers 1234,1234,1234,1234,1234,1234,1234";
output;
run;

data test2;
  set test;
  %splitvar(term,term2,&width,split=&split,hindent=&hindent);
run;

proc report nowd data=test2 split="&split" headline headskip;
columns term2;
define term2 / "SOC" "  Preferred Term" display flow width=&width spacing=0;
run;
/===============================================================================
/ TEST OUTPUT FOLLOWS:
/===============================================================================
SOC
  Preferred Term
______________________________

SOC short term
  PT short 1
  PT short 2

System Organ Class long term
    that is going to flow to
    more lines
  PT short 1
  PT short 2
  Preferred term code that is
      also long and is going
      to flow to more lines
  Indented: preferred term
            code that is also
            long and is going
            to flow to more
            lines
  Indented comma-delimited
      list of patient numbers
      1234,1234,1234,1234,
      1234,1234,1234
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  07Sep07         Header tidy
/ rrb  04May11         Code tidy
/ rrb  14Jul11         Rewritten (v2.0)
/ rrb  19Aug11         Added usecolon= parameter and changed indent parameter
/                      to hindent= (v3.0)
/ rrb  25Aug11         Header tidy
/ rrb  19Oct11         Bug with __minw value fixed (v3.1)
/ rrb  28Oct11         Bug with lenvar fixed (v3.2)
/ rrb  26Dec11         Header update to explain that this macro only works on
/                      Western character sets.
/ rrb  13Jan12         Commas as well as hyphens can be a split point (v3.3)
/ rrb  14Jan12         Increased work variable length to 8040 (v3.4)
/ rrb  07Feb12         No longer set the length of the new variable (v3.5)
/ rrb  15Feb12         biglen= added (v3.6)
/ rrb  06Mar12         spliton=, splitat= and colon= parameters added plus minor
/                      code changes to make it more like the %ksplitvar macro
/                      for utf-8 encoding (v4.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: splitvar v4.0;

%macro splitvar(oldvar,
                newvar,
                width,
                split=@,
                hindent=0,
                usecolon=yes,
                biglen=8040,
                spliton=",-",
                splitat=" ",
                colon=": ",
                debug=n);

  %local err errflag lenvar;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&debug) %then %let debug=n;
  %let debug=%upcase(%substr(&debug,1,1));

  %if not %length(&usecolon) %then %let usecolon=yes;
  %let usecolon=%upcase(%substr(&usecolon,1,1));

  %if not %length(&newvar) %then %let newvar=&oldvar;
  %else %let lenvar=&newvar;

  %if not %length(&split) %then %let split=@;
  %else %let split=%sysfunc(dequote(&split));

  %if not %length(&width) %then %do;
    %put &err: (splitvar) No width specified as third parameter;
    %let errflag=1;
  %end;
  %else %do;
    %if %length(%sysfunc(compress(&width,0123456789))) %then %do;
      %put &err: (splitvar) You must supply a positive integer value to width=&width;
      %let errflag=1;
    %end;
  %end;

  %if not %length(&hindent) %then %let hindent=0;
  %if %length(%sysfunc(compress(&hindent,0123456789))) %then %do;
    %put &err: (splitvar) You must supply a positive integer value to hindent=&hindent;
    %let errflag=1;
  %end;

  %if not %length(&biglen) %then %let biglen=8040;

  %if &errflag %then %goto exit;

  length __newstr __rest $ &biglen ;

  if length(&oldvar) LE &width then __newstr=&oldvar;
  else do;
    __hindent=&hindent;
    __newstr=" ";
    __rest=&oldvar;
    %if "&usecolon" NE "N" %then %do;
      if 0 LT index(left(__rest),&colon) LE (&width*0.3) 
       then __hindent=index(left(__rest),&colon)+lengthc(&colon)-1;
    %end;
    __indent=verify(__rest," ")-1;
    do while(__rest NE " ");
      __minw=max(__indent+__hindent+1,floor(&width/2));
      %if &debug EQ Y %then %do;
        put __minw= __indent= __hindent=;
        put __rest=;
      %end;
      do __i=(&width+1) to __minw by -1;
        __break=0;
        if (substr(__rest,__i,1) EQ &splitat) 
         or (index(&spliton,substr(__rest,__i,1)) and __i LE &width) then do;
          __break=1;
          if substr(__rest,__i,1) EQ &splitat then do;
            if __newstr=" " then __newstr=trim(substr(__rest,1,__i-1))||"&split";
            else __newstr=trim(__newstr)||trim(substr(__rest,1,__i-1))||"&split";
            __rest=trim(left(substr(__rest,__i+1)));
          end;
          else do;
            *- we have a split-on character that we need to show and keep -;
            if __newstr=" " then __newstr=trim(substr(__rest,1,__i))||"&split";
            else __newstr=trim(__newstr)||trim(substr(__rest,1,__i))||"&split";
            __rest=trim(left(substr(__rest,__i+1)));
          end;
          __i=1;
        end;
      end;
      if not __break then do;
        %if &debug EQ Y %then %do;
          put "NO BREAK FOUND in __rest last half";
          put __newstr=;
          put __rest=;
        %end;
        if __newstr=" " then __newstr=trim(substr(__rest,1,&width))||"&split";
        else __newstr=trim(__newstr)||trim(substr(__rest,1,&width))||"&split";
        __rest=trim(left(substr(__rest,&width+1)));
      end;
      __repspace=__indent+__hindent-1;
      if __repspace GE 0 then do;
        __rest=repeat(" ",__repspace)||__rest;
      end;
      %if &debug EQ Y %then %do;
        put __newstr=;
        put __rest=;
      %end;
    end;
  end;
  &newvar=__newstr;
  DROP __newstr __rest __i __break __minw __repspace __indent __hindent;

  %goto skip;
  %exit: %put &err: (splitvar) Leaving macro due to problem(s) listed;
  %skip:

%mend splitvar;
/*<pre><b>
/ Program   : sqlsamevars.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 30-Apr-2013
/ Purpose   : In-SQL macro to test if two datasets/tables have the same
/             variables (both names and type) and write the results as a 0 or 1
/             to a global macro variable.
/ SubMacros : none
/ Notes     : This macro assumes that you are already within a "proc sql" step.
/             It suits programmers who mix function-style macro code with SQL.
/
/             This macro relies on a one observation dataset/table named "dummy"
/             being present. It will not be used but must exist as a one obs
/             dataset/table to get around "proc sql" syntax restrictions.
/
/             This is not a function-style macro (unlike %samevars). See usage
/             notes.
/
/             %samevars is a function-style macro that does the same job as this
/             macro but is very limited as to the total number of columns it can
/             process efficiently. This is a non-function-style macro that is
/             not limited to the total number of columns.
/
/             A 0 (not true) or a 1 (true) is written to the global macro
/             variable _sqlsamevars_ depending on whether variables are
/             different (0) or the same (1).
/
/             No modifiers are allowed for the two datasets/tables compared.
/
/ Usage     : proc sql noprint;
/               %sqlsamevars(dset1,dset2);
/               %if &_sqlsamevars_ EQ 0 %then %do ....
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dset1             (pos) one or two level dataset for comparison (no modifiers)
/ dset2             (pos) one or two level dataset for comparison (no modifiers)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  30Apr13         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: sqlsamevars v1.0;

%macro sqlsamevars(dset1,dset2);

  %local deflib err errflag;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&dset1) %then %do;
    %let errflag=1;
    %put &err: (sqlsamevars) No dataset specified to first positional parameter;
  %end;

  %if not %length(&dset2) %then %do;
    %let errflag=1;
    %put &err: (sqlsamevars) No dataset specified to second positional parameter;
  %end;

  %if &errflag %then %goto exit;

  %let deflib=%upcase(%sysfunc(getoption(user)));
  %if not %length(&deflib) %then %let deflib=WORK;

  %if not %length(%scan(&dset1,2,.)) %then %let dset1=&deflib..&dset1;
  %if not %length(%scan(&dset2,2,.)) %then %let dset2=&deflib..&dset2;

  %let dset1=%upcase(&dset1);
  %let dset2=%upcase(&dset2);

  %global _sqlsamevars_;
  %let _sqlsamevars_=0;

  select 1 into :_sqlsamevars_ separated by ' ' from dummy where not exists
  (select 1 from 
  (select name, type from dictionary.columns where libname="%scan(&dset1,1,.)" and     memname="%scan(&dset1,2,.)") as a
  full outer join
  (select name, type from dictionary.columns where libname="%scan(&dset2,1,.)" and     memname="%scan(&dset2,2,.)") as b
  on a.name=b.name and a.type=b.type
  where (a.name is null) or (b.name is null)
  );

  %goto skip;
  %exit: %put &err: (sqlsamevars) Leaving macro due to problem(s) listed;
  %skip:

%mend sqlsamevars;
/*<pre><b>
/ Program      : substrw.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ Purpose      : Function-style macro to substring words assigned to a macro
/                variable.
/ SubMacros    : none
/ Notes        : This works like %substr() but acts on words instead. If number
/                parameter is not set then all following words are returned.
/ Usage        : %let whatsleft=%substrw(&mvar,4);
/                %let twothree=%substrw(&str,2,2);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String to work on
/ start             (pos) Start word number
/ number            (pos) Number of words (optional)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called2 message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: substrw v1.0;

%macro substrw(str,start,number);

  %local errflag err i pos bit;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&start) %then %do;
    %let errflag=1;
    %put &err: No start word number provided as second positional parameter;
  %end;

  %if &errflag %then %goto exit;

  %if %length(&str) %then %do;
    %if not %length(&number) %then %do;
      %let pos=&start;
      %let bit=%scan(&str,&pos,%str( ));
      %do %while(%length(&bit));
&bit
        %let pos=%eval(&pos+1);
        %let bit=%scan(&str,&pos,%str( ));
      %end;
    %end;
    %else %do;
      %do i=1 %to &number;
%scan(&str,%eval(&start-1+&i),%str( ))
      %end;
    %end;
  %end;

  %goto skip;
  %exit: %put &err: (substrw) Leaving macro due to problem(s) listed;
  %skip:

%mend substrw;
/*<pre><b>
/ Program   : suffix.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 12-Jun-2011
/ Purpose   : Function-style macro to return a list with a suffix added.
/ SubMacros : none
/ Notes     : Items in matching quotes are treated as single elements
/ Usage     : %let sufflist=%suffix(.sas,fname1 "fname 2" fname3);
/             
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ suffix            (pos) Text to suffix each item with (unquoted)
/ list              (pos) List of items to suffix (separated by spaces)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: suffix v1.0;

%macro suffix(suffix,list);
  %local i bit;
  %let i=1;
  %let bit=%sysfunc(scanq(&list,&i,%str( )));
  %do %while(%length(&bit));
&bit.&suffix
    %let i=%eval(&i+1);
    %let bit=%sysfunc(scanq(&list,&i,%str( )));
  %end;
%mend suffix;

/*<pre><b>
/ Program   : supasort.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To sort a list of datasets by variables if they exist in the
/             datasets.
/ SubMacros : %dsall %words %varlist %quotelst
/ Notes     : You can use the _all_ notation to refer to all the datasets in a
/             library.
/ Usage     : %supasort(work._all_,date time)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ list              (pos) List of datasets. The _all_ notation can be used.
/ by                (pos) List of "by" variables (separated by spaces).
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: supasort v1.0;

%macro supasort(list,by);
  %local byvars varlist i j;
  %dsall(&list)
  %let by=%quotelst(%upcase(&by));

  %do i=1 %to %words(&_dsall_);
    %let byvars=;
    %let varlist=%varlist(%scan(&_dsall_,&i,%str( )));
    %do j=1 %to %words(&varlist);
      %if %index(&by,"%upcase(%scan(&varlist,&j,%str( )))") 
        %then %let byvars=&byvars %scan(&varlist,&j,%str( ));
    %end;
    %if %length(&byvars) %then %do;
      proc sort data=%scan(&_dsall_,&i,%str( ));
        by &byvars;
      run;
    %end;
  %end;
%mend supasort;
/*<pre><b>
/ Program   : superql.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 10-Oct-2012
/ Purpose   : Function-style macro that uses as the argument the NAME of a 
/             macro variable and returns the length of the masked contents
/             of that variable as resolved by %superq().
/ SubMacros : none
/ Notes     : The argument to this macro should be the NAME of a single macro
/             variable or parameter (not its content). If you use the macro in
/             this way:
/               %superql(&mvar)
/             ... then &mvar should resolve to the NAME of a macro variable or
/             macro parameter that you wish to test for content length.
/
/             This macro is intended for use inside a macro you are writing
/             where you need to test whether a parameter has been given a value
/             or not. Masked spaces are considered non-null so the length of
/             these will count. Using this macro is a robust way of testing
/             whether a macro variable or parameter has been set or not. Use 
/             "%if %length(&parm) %then.." where a less robust method is
/             acceptable and you wish to save CPU cycles such as for frequently
/             called low-level macros.
/
/             This macro will test whether a macro variable or parameter has
/             been set and not whether its contents will cause a problem. The
/             contents of the macro variable tested are masked by %superq() so
/             no attempt will be made to resolve the contents therefore no
/             warnings will be issued for macro variable references that are
/             unresolvable that you might need to resolve later in your code.
/
/             The masking done by this macro does not affect the original
/             contents of the macro variable or macro parameter under test.
/
/             For brevity, use this macro in the boolean sense of it returning
/             a value of "0" (not true) or a non-zero positive integer (true)
/             as shown in the usage notes below.
/
/ Usage     : %macro test(parm1, parm2);
/               %if %superql(parm1) %then %put PARM1 is set;
/               %else %put PARM1 not set;
/             %mend test;
/             %test(aa,bb);
/             %test(,bb);
/             %test(R&D,bb);  %*- "&D" not resolvable --;
/
/             (log output with some text changed to fool log scanners)
/             955  %test(aa,bb);
/             PARM1 is set
/             956  %test(,bb);
/             PARM1 not set
/             957  %test(R&D,bb);  %*- "&D" is not resolvable --;
/             WA*NING: Appa*ent sym**lic refe*ence D not res*lved.
/             PARM1 is set
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ mvarname          (pos) NAME of the macro variable or parameter to test
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  10Oct12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: superql v1.0;

%macro superql(mvarname);
%length(%superq(&mvarname))
%mend superql;
/*<pre><b>
/ Program      : sysfmtlist.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 04-May-2011
/ SAS version  : 8.2
/ Purpose      : In-datastep macro to list all the system formats
/ SubMacros    : none
/ Notes        : S370 formats missed out. Do not add a semicolon at the end.
/                Currently there is no way to identify system formats by a field
/                created by proc contents but this may change in the future and
/                if so then that method should be used instead of this macro.
/ Usage        : if format in (" " %sysfmtlist) then _fmt="SYS";
/                else _fmt="USR";
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ N/A
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called2 message added
/ rrb  07Sep07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: sysfmtlist v1.0;

%macro sysfmtlist;
  "$ASCII" "$BINARY" "$CHAR" "$EBCDIC" "$HEX" "$KANJI" "$KANJIX"
  "$MSGCASE" "$OCTAL" "$QUOTE" "$REVERJ" "$REVERS" "UPCASE"
  "$VARYING" "$" "BEST" "BINARY" "COMMA" "COMMAX" "D" "DATE"
  "DATEAMP" "DATETIME" "DAY" "DDMMYY" "DOLLAR" "DOWNAME" "E"
  "EURDFDD" "EURDFDE" "EURDFDN" "EURDFDT" "EURDFDW" "EURDFMN"
  "EURDFMY" "EURDFWDX" "EURDFWKX" "F" "FLOAT" "FRACT" "HEX" "HHMM"
  "HOUR" "IB" "IBR" "IEEE" "JULDAY" "JULIAN" "MINGUO" "MMDDYY"
  "MMSS" "MMYY" "MONNAME" "MONTH" "MONYY" "NEGPAREN" "NENGO"
  "NUMX" "OCTAL" "PD" "PDJULG" "PERCENT" "PIB" "PIBR" "PK"
  "PVALUE" "QTR" "QTRR" "RB" "ROMAN" "SSN"
  /* S370 formats missed out as not required for Unix */
  "TIME" "TIMEAMPM" "TOD" "WEEKDATE" "WEEKDATX" "WEEKDAY"
  "WORDDATE" "WORDDATX" "WORDF" "WORDS" "YEAR" "YEN" "YYMM" 
  "YYMMDD" "YYMON" "YYQ" "YYQR" "Z" "ZD"
%mend sysfmtlist;
/*<pre><b>
/ Program   : termstr.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 02-May-2013
/ Purpose   : To guess the line termination character(s) (CRLF or LF) of a text
/             input file and write it to the global macro variable _termstr_ .
/ SubMacros : none
/ Notes     : This macro is not foolproof. It reads in the first 32767 bytes of
/             the file declaring it to be a fixed record format file and
/             searches for the CRLF characters in that first 32767 bytes only.
/             If found it writes the string CRLF to the global macro variable
/             _termstr_ otherwise it has the default value of LF.
/
/             In SAS data steps, the infile statement allow you to specify the
/             termstr= value as LF or CRLF and this macro guesses the value for
/             you so that you can use "termstr=&_termstr_" in your infile
/             statement after testing a file with this macro.
/
/ Usage     : %termstr(myfile);
/             %put _termstr_ = &_termstr_;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ file              (pos) Full file path name (no quotes). If the file name
/                   contains special characters then enclose it in %nrstr( ) .
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  02May13         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: termstr v1.0;

%macro termstr(file);

  %local savopts;
  %global _termstr_;
  %let _termstr_=LF;
  %let savopts=%sysfunc(getoption(NOTES));

  options nonotes;

  data _null_;
    infile "&file" pad lrecl=32767 recfm=F;
    input;
    *- Look for the carriage-return line-feed double character and if   -;
    *- we find it then assume that CRLF is the line termination string. -;
    if index(_infile_,"0D0A"X) then call symput('_termstr_','CRLF');
    stop;
  run;

  options &savopts;

%mend termstr;
/*<pre><b>
/ Program   : therest.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 27-May-2014
/ Purpose   : Function-style macro to give you everything following any found
/             target string character.
/ SubMacros : none
/ Notes     : This macro is OBSOLETE. It has been replaced by the %allafterc
/             macro which does exactly the same thing.
/
/             It does an "indexc" on a string to find the first occurrence of
/             any of the characters in the target string and returns all the
/             string after that. If none of the target characters are found then
/             a null string is returned. The search is case sensitive.
/
/ Usage     : %let rest=%therest(&str,\/);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos) String to search
/ target            (pos) Target string
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/ rrb  27May14         This macro flagged as OBSOLETE
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: therest v1.0 (obsolete - replaced by allafterc macro);

%macro therest(string,target);
  %local pos;
  %if %sysfunc(indexc(&string,&target)) %then %do;
    %let pos=%sysfunc(indexc(&string,&target));
    %if &pos LT %length(&string) %then %qsubstr(&string,&pos+1);
  %end;
%mend therest;  /*<pre><b>
/ Program   : titlelen.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To create a copy of sashelp.vtitle but with the length added.
/ SubMacros : %casestrvar
/ Notes     : The orginal length of titles and footnotes is unknown since the
/             original trailing spaces are not shown in sashelp.vtitle. This
/             macro will generate a dummy report and work out the original
/             length of the titles and footnotes to the nearest multiple of 2.
/             If any mixed-case form of "#byvar" or "#byval" is detected in a
/             title line then these strings (only) will be converted to
/             uppercase.
/
/ Usage     : %titlelen
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsout=titlelen    Name of the output dataset.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Jan06         Extensively rewritten for version 2.0
/ rrb  13Feb07         "macro called" message added
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: titlelen v2.0;

%macro titlelen(dsout=titlelen);

  %*- store "center" option for restore at end -;
  %local opts;
  %let opts=%sysfunc(getoption(center));


  *- set options to center -;
  options center;


  *- save the titles file -;
  proc sort data=sashelp.vtitle out=_titles;
    by type number;
  run;


  *- set up temporary file -;
  filename titlelen TEMP;


  *- print to the temporary file to put the titles and footnotes there -;
  data _null_;
    file titlelen print titles footnotes ls=200 ps=21;
    put 'xxxxxxxxxx';
  run;


  *- Read in the titles and footnotes from the temporary -;
  *- file to find the start position of the text. -;
  data _ltitles;
    retain type 'T' number 0;
    infile titlelen pad;
    input text $char200.;
    if text='xxxxxxxxxx' then do;
      type='F';
      number=0;
    end;
    else do;
      number=number+1;
      start=verify(text,' ');
      output;
    end;
    drop text;
  run;


  *- clear the temporary file -;
  filename titlelen clear;


  *- sort ready for a merge with the original titles -;
  proc sort data=_ltitles;
    by type number;
  run;


  *- merge with the original titles and calculate length -;
  data _titles;
    merge _titles(in=_orig) _ltitles;
    by type number;
    if _orig;
    if type='T' and text ne ' ' then do;
      %casestrvar(text,'#BYVAR');
      %casestrvar(text,'#BYVAL');
    end;
    length=2*(100-(start-verify(text,' ')));
    if (length-length(text)) EQ 1 then length=length-1;
    drop start;
  run;


  *- sort out to a titles dataet -;
  proc sort data=_titles out=&dsout;
    by descending type number;
  run;


  *- tidy up -;
  proc datasets nolist;
    delete _titles _ltitles;
  run;
  quit;


  *- restore the saved option -;
  options &opts;


%mend titlelen;
/*<pre><b>
/ Program      : unfmt2mvar.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 20-Apr-2013
/ Purpose      : To list distinct values of a variable to a macro variable but
/                without any variable format applied.
/ SubMacros    : none
/ Notes        : Using "select distinct" in proc sql to list the different
/                distinct values of a variable has the problem that the variable
/                format (if any) will be applied. This macro gets around that
/                problem by creating a temporary view with the format nullified
/                for the variable and then this view is used to access the
/                unformatted values from proc sql.
/
/                More than one variable can be specified. Each variable should
/                have a corresponding macro variable and vice versa. All macro
/                variables need to have been declared before this macro is 
/                called.
/
/ Usage        : %unfmt2mvar(test, race sex, mrace msex);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dset              (pos) Input dataset
/ vars              (pos) Variable(s) to return values for. Multiple variables
/                   should be separated by spaces.
/ mvars             (pos) Macro variable(s) to write the variable values to.
/                   Multiple variables should be separated by spaces. All the
/                   macro variables need to be defined before this macro is
/                   called.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  20Apr13         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: unfmt2mvar v1.0;

%macro unfmt2mvar(dset,vars,mvars);

  %local i err errflag var mvar savopts num;
  %let err=ERR%str(OR);
  %let errflag=0;


  %if not %length(&dset) %then %do;
    %let errflag=1;
    %put &err: (unfmt2mvar) No dataset specified as the first positional parameter;
  %end;

  %if not %length(&vars) %then %do;
    %let errflag=1;
    %put &err: (unfmt2mvar) No variable(s) specified as the second positional parameter;
  %end;

  %if not %length(&mvars) %then %do;
    %let errflag=1;
    %put &err: (unfmt2mvar) No Macro variable(s) specified as the third positional parameter;
  %end;

  %if &errflag %then %goto exit;

  %let i=1;
  %let var=%scan(&vars,&i,%str( ));
  %let mvar=%scan(&mvars,&i,%str( ));
  %do %while(%length(&var) or %length(&mvar));
    %if not %length(&var) %then %do;
      %let errflag=1;
      %put &err: (unfmt2mvar) No variable corresponding to macro variable &mvar;
    %end;
    %if not %length(&mvar) %then %do;
      %let errflag=1;
      %put &err: (unfmt2mvar) No macro variable corresponding to variable &var;
    %end;
    %else %if not %symexist(&mvar) %then %do;
      %let errflag=1;
      %put &err: (unfmt2mvar) Macro variable &mvar must already exist but does not;
    %end;
    %let i=%eval(&i+1);
    %let var=%scan(&vars,&i,%str( ));
    %let mvar=%scan(&mvars,&i,%str( ));
  %end;

  %if &errflag %then %goto exit;


  %let num=%eval(&i-1);

  %let savopts=%sysfunc(getoption(NOTES));
  options NONOTES;

  data _unfmt / view=_unfmt;
    set &dset;
    format &vars ;
    keep &vars;
  run;

  proc sql noprint;
  %do i=1 %to &num;
    %let var=%scan(&vars,&i,%str( ));
    %let mvar=%scan(&mvars,&i,%str( ));
    select distinct &var into :&mvar separated by ' ' from _unfmt;
  %end;
    drop view _unfmt;
  quit;


  options &savopts;

  %goto skip;
  %exit: %put &err: (unfmt2mvar) Leaving macro due to problem(s) listed;
  %skip:

%mend unfmt2mvar;
/*<pre><b>
/ Program   : var2mvar.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 09-Sep-2011
/ Purpose   : To write data in a variable to a global macro variable
/ SubMacros : none
/ Notes     : Values are written to the global macro variable _mvar_ .
/
/             This should only be used on a character variable where the
/             contents do not contain spaces between words. Using this macro is
/             just a shorthand way of writing the following SQL:
/               PROC SQL NOPRINT;
/                 SELECT &var into: _mvar_ separated by " " from &ds;
/               QUIT;
/             .... and is here just to save you some typing.
/
/             Loading values into a macro variable can make it easier to run
/             a macro call on each item. Normally the variable should contain
/             non-missing unique values. See the %doallitem macro which uses
/             such a value list for repeat processing on each item.
/
/ Usage     : %var2mvar(sashelp.class(where=(name=:"A")),name);
/             %put **&_mvar_**;
/             **Alfred Alice**
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name (modifiers are allowed)
/ var               (pos) Variable name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  09Sep11         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: var2mvar v1.0;

%macro var2mvar(ds,var);

  %local err errflag savopts;

  %let savopts=%sysfunc(getoption(notes));
  options nonotes;

  %global _mvar_;
  %let _mvar_=;

  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&ds) %then %do;
    %let errflag=1;
    %put &err: (var2mvar) No dataset specified as first positional parameter;
  %end;
  %else %do;
    %if not %sysfunc(exist(%scan(&ds,1,%str(%()))) %then %do;
      %let errflag=1;
      %put &err: (var2mvar) Dataset %scan(&ds,1,%str(%()) does not exist;
    %end;
  %end;

  %if not %length(&var) %then %do;
    %let errflag=1;
    %put &err: (var2mvar) No variable name specified as second positional parameter;
  %end;

  %if &errflag %then %goto exit;

  proc sql noprint;
    select &var into: _mvar_ separated by " " from &ds;
  quit;

  %goto skip;
  %exit: %put &err: (var2mvar) Leaving macro due to problem(s) listed;
  %skip:

  options &savopts;

%mend var2mvar;
/*<pre><b>
/ Program   : varfmt.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return a variable format
/ SubMacros : %attrv
/ Notes     : This is a shell macro that calls %attrv
/ Usage     : %let varfmt=%varfmt(dsname,varname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name
/ var               (pos) Variable name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: varfmt v1.0;

%macro varfmt(ds,var);
  %attrv(&ds,&var,varfmt)
%mend varfmt;
/*<pre><b>
/ Program   : varinfmt.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return a variable informat
/ SubMacros : %attrv
/ Notes     : This is a shell macro that calls %attrv
/ Usage     : %let varinfmt=%varinfmt(dsname,varname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                Dataset name (pos)
/ var               Variable name (pos)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: varinfmt v1.0;

%macro varinfmt(ds,var);
%attrv(&ds,&var,varinfmt)
%mend varinfmt;
/*<pre><b>
/ Program   : varlabel.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return a variable label
/ SubMacros : %attrv
/ Notes     : This is a shell macro that calls %attrv
/ Usage     : %let varlabel=%varlabel(dsname,varname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name
/ var               (pos) Variable name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: varlabel v1.0;

%macro varlabel(ds,var);
  %attrv(&ds,&var,varlabel)
%mend varlabel;
/*<pre><b>
/ Program   : varlen.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return a variable length
/ SubMacros : %attrv %vartype
/ Notes     : This is a shell macro that calls %attrv.
/             Character variables will have the length preceded by a "$ " so you
/             can use it in a length statement in a data step. Set the nodollar
/             paremater to anything to suppress the dollar sign.
/ Usage     : %let varlen=%varlen(dsname,varname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name
/ var               (pos) Variable name
/ nodollar          (pos) If this is set to anything then the dollar shown for 
/                   character length will be suppressed
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  01Nov02         Added parameter to suppress the $
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: varlen v1.0;

%macro varlen(ds,var,nodollar);
  %local varlen;
  %let varlen=%attrv(&ds,&var,varlen);
  %if "%vartype(&ds,&var)" EQ "C" and %length(&nodollar) EQ 0 
    %then %let varlen=$ &varlen;
&varlen
%mend varlen;
/*<pre><b>
/ Program   : varlens.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 01-May-2014
/ Purpose   : Function-style macro to return a list of variables with their
/             lengths than can be used in a LENGTH statement.
/ SubMacros : none
/ Notes     : Dataset modifiers are not allowed. The variables are listed in the
/             same order as they exist in the input dataset. If the vars=
/             parameter is used then no checking will be done to make sure any
/             of the variables actually exist in the input dataset.
/ Usage     : data test;
/               length %varlens(sashelp.class, weight xxxx  name);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name (no modifiers)
/ vars              (pos) Optional limiting list of variables you want the
/                   LENGTH attributes for (separated by spaces - case is not
/                   important).
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Apr14         New (v1.0)
/ rrb  01May14         vars= parameter added (v2.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: varlens v2.0;

%macro varlens(ds,vars);
  %local dsid rc nvars i varlens err varname vartype varlen dollar;
  %let err=ERR%str(OR);
  %let vars=%upcase(&vars);
  %let dsid=%sysfunc(open(&ds,is));
  %if &dsid EQ 0 %then %do;
    %put &err: (varlens) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let nvars=%sysfunc(attrn(&dsid,nvars));
    %if &nvars LT 1 %then %put &err: (varlens) No variables in dataset &ds;
    %else %do;
      %let varlens=;
      %do i=1 %to &nvars;
        %let varname=%sysfunc(varname(&dsid,&i));
        %let vartype=%sysfunc(vartype(&dsid,&i));
        %let varlen=%sysfunc(varlen(&dsid,&i));
        %if &vartype EQ C %then %let dollar=$;
        %else %let dollar=;
        %if not %length(&vars) or %sysfunc(indexw(&vars,%upcase(&varname)))
         %then %let varlens=
          %sysfunc(strip(%sysfunc(compbl(&varlens &varname &dollar &varlen))));
      %end;
    %end;
    %let rc=%sysfunc(close(&dsid));
  %end;
&varlens
%mend varlens;
/*<pre><b>
/ Program   : varlist.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 01-May-2014
/ Purpose   : Function-style macro to return a list of variables in a dataset
/ SubMacros : none
/ Notes     : Variable names will be in uppercase. Variables will be listed in
/             the same order as they occur in the dataset.
/ Usage     : %let varlist=%varlist(dsname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name (no modifiers)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/ rrb  01May14         Initialised varlist macro variable and updated the header
/                      (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: varlist v1.1;

%macro varlist(ds);
  %local dsid rc nvars i varlist err;
  %let err=ERR%str(OR);
  %let dsid=%sysfunc(open(&ds,is));
  %if &dsid EQ 0 %then %do;
    %put &err: (varlist) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let nvars=%sysfunc(attrn(&dsid,nvars));
    %if &nvars LT 1 %then %put &err: (varlist) No variables in dataset &ds;
    %else %do;
      %let varlist=;
      %do i=1 %to &nvars;
        %if %length(&varlist) EQ 0 %then %let varlist=%sysfunc(varname(&dsid,&i));
        %else %let varlist=&varlist %sysfunc(varname(&dsid,&i));
      %end;
    %end;
    %let rc=%sysfunc(close(&dsid));
  %end;
&varlist
%mend varlist;
/*<pre><b>
/ Program   : varlistc.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return a list of character variables in a
/             dataset.
/ SubMacros : none
/ Notes     : Variable names will be in uppercase.
/ Usage     : %let varlistc=%varlistc(dsname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: varlistc v1.0;

%macro varlistc(ds);
  %local dsid rc nvars i varlist err;
  %let err=ERR%str(OR);
  %let dsid=%sysfunc(open(&ds,is));
  %if &dsid EQ 0 %then %do;
    %put &err: (varlistc) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let nvars=%sysfunc(attrn(&dsid,nvars));
    %if &nvars LT 1 %then %put &err: (varlistc) No variables in dataset &ds;
    %else %do;
      %do i=1 %to &nvars;
        %if "%sysfunc(vartype(&dsid,&i))" EQ "C" %then %do;
          %if %length(&varlist) EQ 0 %then %let varlist=%sysfunc(varname(&dsid,&i));
          %else %let varlist=&varlist %sysfunc(varname(&dsid,&i));
        %end;
      %end;
    %end;
    %let rc=%sysfunc(close(&dsid));
  %end;
&varlist
%mend varlistc;
/*<pre><b>
/ Program   : varlistn.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return a list of numeric variables in a
/             dataset.
/ SubMacros : none
/ Notes     : Variable names will be in uppercase.
/ Usage     : %let varlistn=%varlistn(dsname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: varlistn v1.0;

%macro varlistn(ds);
  %local dsid rc nvars i varlist err;
  %let err=ERR%str(OR);
  %let dsid=%sysfunc(open(&ds,is));
  %if &dsid EQ 0 %then %do;
    %put &err: (varlistn) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let nvars=%sysfunc(attrn(&dsid,nvars));
    %if &nvars LT 1 %then %put &err: (varlistn) No variables in dataset &ds;
    %else %do;
      %do i=1 %to &nvars;
        %if "%sysfunc(vartype(&dsid,&i))" EQ "N" %then %do;
          %if %length(&varlist) EQ 0 %then %let varlist=%sysfunc(varname(&dsid,&i));
          %else %let varlist=&varlist %sysfunc(varname(&dsid,&i));
        %end;
      %end;
    %end;
    %let rc=%sysfunc(close(&dsid));
  %end;
&varlist
%mend varlistn;
/*<pre><b>
/ Program   : varnum.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the variable position in a dataset
/             or 0 if not in dataset.
/ SubMacros : none
/ Notes     : Since only 0 or a positive integer is returned you can use this
/             like a truth statement such as %if %varnum(dsname,varnam) %then...
/ Usage     : %let varnum=%varnum(dsname,varname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name
/ var               (pos) Variable name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: varnum v1.0;

%macro varnum(ds,var);
  %local dsid rc varnum err;
  %let varnum=0;
  %let err=ERR%str(OR);
  %let dsid=%sysfunc(open(&ds,is));
  %if &dsid EQ 0 %then %do;
    %put &err: (varnum) Dataset &ds not opened due to the following reason:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let varnum=%sysfunc(varnum(&dsid,&var));
    %let rc=%sysfunc(close(&dsid));
  %end;
&varnum
%mend varnum;
/*<pre><b>
/ Program      : vars2num.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 27-Nov-2012
/ Purpose      : To convert variables to numeric where you know they should be
/                numeric variables.
/ SubMacros    : %editlist
/ Notes        : Especially when importing from spreadsheets, it can sometimes
/                happen that columns you know should be numeric turn out to be
/                character. This macro accepts a list of variables you want to
/                be numeric and transforms them into numeric variables of the
/                same name.
/
/                When this macro converts character values to numeric, a message
/                will be written to the log to this effect. If you do not want
/                that message in the log and your values are all integers then
/                use the %int2num macro.
/
/ Usage        : data test2;
/                  set test1;
/                  %vars2num(vara varb varc vard)
/                run;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ varlist           (pos) List of variables separated by spaces that you want to
/                   ensure are numeric variables.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  27Nov12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: vars2num v1.0;

%macro vars2num(varlist); 
%editlist(&varlist,'__&item=&item*1;drop &item;rename __&item=&item;') 
%mend vars2num;
/*<pre><b>
/ Program   : vartype.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return a variable type as either C or N
/ SubMacros : %attrv
/ Notes     : This is a shell macro that calls %attrv
/ Usage     : %let vartype=%vartype(dsname,varname);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ds                (pos) Dataset name
/ var               (pos) Variable name
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: vartype v1.0;

%macro vartype(ds,var);
  %attrv(&ds,&var,vartype)
%mend vartype;
/*<pre><b>
/ Program   : vaxis.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To generate the values to construct a vaxis scale
/ SubMacros : none
/ Notes     : It does not matter if you get the min and max values the wrong way
/             round. This will be detected and fixed. The global macro variables
/             populated are _from_, _to_, _by_, _format_ and _nminor_.
/ Usage     : %vaxis(&min,&max,spare=1)
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ min               (pos) Text minimum value (unquoted)
/ max               (pos) Text maximum value (unquoted)
/ minticks=5        Minimum number of major tick marks to show on the axis
/ spare=0           Number of major tick mark divisions to leave spare at the
/                   top for annotation.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: vaxis v1.0;

%macro vaxis(min,max,minticks=5,spare=0);

  %local swap;
  %global _from_ _to_ _by_ _format_ _nminor_;


  %if %sysevalf(&max < &min) %then %do;
    %let swap=&min;
    %let min=&max;
    %let max=&swap;
  %end;

  %if not %length(&spare) %then %let spare=0;
  %let minticks=%eval(&minticks-&spare-1);

  data _null_;
    length fmt $ 5;
    retain ld rd 0;
    x=int(log10((&max-&min)/&minticks))+1;
    _by=10**x;
    _nminor=4;
    if (ceil(&max/_by)*_by-floor(&min/_by)*_by)/_by < &minticks then do;
      _by=5*10**(x-1);
      _nminor=3;
    end;
    if (ceil(&max/_by)*_by-floor(&min/_by)*_by)/_by < &minticks then do;
      _by=2*10**(x-1);
      _nminor=3;
    end;
    if (ceil(&max/_by)*_by-floor(&min/_by)*_by)/_by < &minticks then do;
      _by=10**(x-1);
      _nminor=4;
    end;
    if (ceil(&max/_by)*_by-floor(&min/_by)*_by)/_by < &minticks then do;
      _by=5*10**(x-2);
      _nminor=3;
    end;
    if (ceil(&max/_by)*_by-floor(&min/_by)*_by)/_by < &minticks then do;
      _by=2*10**(x-2);
      _nminor=3;
    end;
    _from=floor(&min/_by)*_by;
    _to=ceil(&max/_by)*_by;
    if &spare GT 0 then _to=_to+(&spare*_by);
    do i=_from to _to by _by;
      if length(left(scan(put(i,best16.),1,'.'))) > ld 
        then ld=length(left(scan(put(i,best16.),1,'.')));
      if scan(put(i,best16.),2,'.') NE ' ' then do;
        if length(left(scan(put(i,best16.),2,'.'))) > rd 
          then rd=length(left(scan(put(i,best16.),2,'.')));
      end;
    end;
    if rd>0 then fmt=compress(put(ld+rd+1,2.))||'.'||compress(put(rd,2.));
    else fmt=compress(put(ld,2.))||'.';
    call symput('_to_',trim(left(putn(_to,fmt))));
    call symput('_from_',trim(left(putn(_from,fmt))));
    call symput('_by_',compress(put(_by,best12.)));
    call symput('_format_',trim(left(fmt)));
    call symput('_nminor_',put(_nminor,1.));
  run;

%mend vaxis;
  /*<pre><b>
/ Program   : verifyb.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the position of the first character
/             in a string that does not match any character in a reference
/             string BUT STARTING FROM THE BACK.
/ SubMacros : none
/ Notes     : This is a "backwards" version of the familiar verify macro.
/ Usage     : %let pos=%verifyb(&text,%str( )); %*- last non-blank character -;
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ text              (pos) Text to verify
/ ref               (pos) String of reference characters
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk. 
/=============================================================================*/

%put MACRO CALLED: verifyb v1.0;

%macro verifyb(text,ref);
  %local pos errflag err;
  %let err=ERR%str(OR);
  %let errflag=0;
  %if not %length(&text) %then %do;
    %put &err: (verifyb) No text string supplied for verifyb to act on.;
    %let errflag=1;
  %end;
  %if not %length(&ref) %then %do;
    %put &err: (verifyb) No reference string supplied for verifyb to use.;
    %let errflag=1;
  %end;

  %if &errflag %then %goto exit;

  %do pos=%length(&text) %to 1 %by -1;
    %if NOT %index(&ref,%qsubstr(&text,&pos,1)) %then %goto gotit;
  %end;

  %gotit:
&pos

  %goto skip;
  %exit: %put &err: (verifyb) Leaving macro due to problem(s) listed;
  %skip:
%mend verifyb;
/*<pre><b>
/ Program   : views2data.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 28-Jun-2013
/ Purpose   : To convert all sas data views in one library into data sets in
/             another library.
/ SubMacros : %vwlist %words
/ Notes     : There does not appear to be a native way of copying views from one
/             location to another and turning them into data sets in the process
/             which is a common requirement for when data is sent to regulatory
/             authorities. This macro fills that gap.
/ Usage     : %views2data(viewlib,datalib);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ viewlib           (pos) Libref of the library containing views
/ datalib           (pos) Libref of the library to contain the data sets
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  28Jun13         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: views2data v1.0;

%macro views2data(viewlib,datalib);
  %local i view;
  %vwlist(&viewlib);
  %do i=1 %to %words(&_vwlist_);
    %let view=%scan(&_vwlist_,&i,%str( ));
    data &datalib..&view;
      set &viewlib..&view;
    run;
  %end;
%mend views2data;
/*<pre><b>
/ Program   : vwlist.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To list all the views in a libref.
/ SubMacros : none
/ Notes     : This is NOT a function-style macro. See usage notes.
/             You can set an option to prefix the view names with the libref.
/             The list of views will be written to the global macro variable
/             _vwlist_.
/ Usage     : %vwlist(work);
/             %let vwlist=&_vwlist_;
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ libref            (pos) Libref name for which all datasets are to be listed
/ prefix            (pos) Set this to anything at all and all view names will
/                   be prefixed with the libref name.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: vwlist v1.0;

%macro vwlist(libref,prefix);
  %global _vwlist_;
  %let _vwlist_=;
  %if not %length(&libref) %then %let libref=%sysfunc(getoption(user));
  %if not %length(&libref) %then %let libref=work;
  %let libref=%upcase(&libref);

  proc sql noprint;
    select distinct memname into :_vwlist_ separated by
    %if %length(&prefix) %then %do;
      " &libref.."
    %end;
    %else %do;
      ' '
    %end;
    from dictionary.tables
    where memtype='VIEW'
    and libname="&libref";
  quit;

  %if %length(&prefix) %then %let _vwlist_=&libref..&_vwlist_;
  run;
%mend vwlist;
/*<pre><b>
/ Program   : v_macros.sas
/ Version   : 2.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 08-May-2011
/ Purpose   : To compile the validation macros %mmm, %fmm, %dmm and set up
/             global macro variables "mut", "rut", "exp" and "act".
/ SubMacros : none
/ Notes     : The meaning of the macros and global macro variables is explained
/             in this section.
/
/             Global macros variables mean as follows:
/
/             mut = macro under test
/             rut = requirements under test
/             exp = expected result (could be text, a file name in quotes or a
/                   dataset name)
/             act = actual result (could be text, a file name in quotes or a
/                   dataset name)
/
/             Macros assert that expected and actual results match. If they
/             match then it puts out a SUCCESS message to the log and if they
/             do not match it puts out a FAILURE message to the log.
/
/             %vmm = data step variable contents of "exp" and "act" must match
/             %mmm = macro variable contents of "exp" and "act" must match
/             %fmm = files (in quotes) defined to "exp" and "act" must match
/             %dmm = datasets defined to "exp" and "act" must match
/
/ Usage     : %v_macros
/
/             %let mut=removew;
/             %let rut=req001 req002;
/             %let days=mon tue wed thu fri sat;
/             %let act=%&mut(&days,tue fri);
/             %let exp=mon wed thu sat;
/             %mmm
/
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  27Mar09         %vmm macro added for v2.1
/ rrb  08May11         Code tidy
/=============================================================================*/

%*-- dummy macro definition --;
%macro v_macros;
%mend v_macros;


%put VALIDATION MACROS VERSION 2.1 RUNNING ON &SYSSCPL FOR SAS VERSION &SYSVLONG;
%put;

%global mut rut exp act;

%put The following macro variables have been declared global: ;
%put mut = macro under test;
%put rut = requirements under test;
%put exp = expected result;
%put act = actual result;
%put;


%*-- Variable (data step) contents must match --;
%macro vmm;
  if %superq(act) NE %superq(exp) then put "FAILURE: (&mut) &rut";
  else put "SUCCESS: (&mut) &rut";
  put;
%mend vmm;


%*-- Macro variable contents must match --;
%macro mmm;
  %if %superq(act) NE %superq(exp) %then %put FAILURE: (&mut) &rut;
  %else %put SUCCESS: (&mut) &rut;
  %put;
%mend mmm;


%*-- File contents must match --;
%macro fmm;
  %local errflag err compare;
  %let err=ERR%str(OR);
  %let compare=DIFF;
  %let errflag=0;

  %if not %sysfunc(fileexist(%superq(act))) %then %do;
    %let errflag=1;
    %put &err: (fmm) "Actual" file %superq(act) does not exist;
    %put;
  %end;

  %if not %sysfunc(fileexist(%superq(exp))) %then %do;
    %let errflag=1;
    %put &err: (fmm) "Expected" file %superq(exp) does not exist;
    %put;
  %end;

  %if not &errflag %then %do;

    data _null_;
      retain compare "SAME";
      length cont1 cont2 $ 32767;
      rc=filename('fref1',&exp);
      rc=filename('fref2',&act);
      fid1=fopen('fref1',"I",32767,"B");
      if fid1<=0 then do;
        compare="DIFF";
        put '&err: (fmm) "Expected" file could not be opened';
      end;
      fid2=fopen('fref2',"I",32767,"B");
      if fid2<=0 then do;
        compare="DIFF";
        put '&err: (fmm) "Actual" file could not be opened';
      end;
      if (compare="SAME" and fid1>0 and fid2>0) then do;
        eof1=fread(fid1);
        eof2=fread(fid2);
        if eof1 ne eof2 then compare="DIFF";
        do while(compare="SAME" and not (eof1 or eof2));
          get1=fget(fid1,cont1,32767);
          get2=fget(fid2,cont2,32767);
          if (get1 ne get2) or (frlen(fid1) ne frlen(fid2)) or (cont1 ne cont2) then compare="DIFF";
          if compare="SAME" then do;
            eof1=fread(fid1);
            eof2=fread(fid2);
            if eof1 ne eof2 then compare="DIFF";
          end;
        end;
      end;
      if fid1>0 then rc=fclose(fid1);
      if fid2>0 then rc=fclose(fid2);
      rc=filename('fref1',' ');
      rc=filename('fref2',' ');
      call symput('compare',compare);
    run;

  %end;
  %if &compare EQ DIFF %then %put FAILURE: (&mut) &rut;
  %else %put SUCCESS: (&mut) &rut;
  %put;
%mend fmm;



%*-- Dataset contents must match --;
%macro dmm;
  %local rc;
  proc compare base=&exp compare=&act;
  run;
  %let rc=&sysinfo;
  %if &rc NE 0 %then %put FAILURE: (&mut) &rut;
  %else %put SUCCESS: (&mut) &req;
  %put;
%mend dmm;



%put The following validation macros have been compiled: ;
%put vmm = Variable (data step) contents must match ;
%put mmm = Macro variable contents must match ;
%put fmm = File contents must match ;
%put dmm = Dataset contents must match ;
%put;
/*<pre><b>
/ Program   : windex.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the word count position in a string
/ SubMacros : %words
/ Notes     : none
/ Usage     : %let windex=%windex(string,target);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               String (pos) UNQUOTED
/ target            Target string (pos) UNQUOTED
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  10May07         Break loop if match is found (v1.1)
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: windex v1.1;

%macro windex(str,target);
  %local i res words;
  %let res=0;
  %let words=%words(&str);
  %do i=1 %to &words;
    %if "%scan(&str,&i,%str( ))" EQ "&target" %then %do;
      %let res=&i;
      %let i=&words;
    %end;
  %end;
&res
%mend windex;
/*<pre><b>
/ Program   : worddate.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 24-Aug-2012
/ Purpose   : Function-style macro to convert a date in the form "date"D to a 
/             worddate format string.
/ SubMacros : none
/ Notes     : The "strip" function is used to strip leading and trailing spaces
/             so you need sas v9.2 or higher. See also the %worddateu macro that
/             additionally converts space and comma separator groups in the
/             string to single underscores.
/ Usage     : %let worddate=%worddate("&sysdate9"D);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ date              (pos) Date in the form "date"D (defaults to current date)
/ format=worddate20.      Default format for the worddate is worddate20.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  24Aug12         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: worddate v1.0;

%macro worddate(date,format=worddate20.);
%if not %length(&date) %then %let date="&sysdate9"D;
%if not %length(&format) %then %let format=worddate20.;
%sysfunc(strip(%sysfunc(putn(&date,&format))))
%mend worddate;
/*<pre><b>
/ Program   : worddateu.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 24-Aug-2012
/ Purpose   : Function-style macro to convert a date in the form "date"D to a 
/             worddate format string with groups of commas and spaces changed to
/             single underscores.
/ SubMacros : %worddate %sep2u
/ Notes     : The "strip" function is used to strip leading and trailing spaces
/             so you need sas v9.2 or higher. 
/ Usage     : %let worddateu=%worddateu("&sysdate9"D);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ date              (pos) Date in the form "date"D (defaults to current date)
/ format=worddate20.      Default format for the worddate is worddate20.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  24Aug12         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: worddateu v1.0;

%macro worddateu(date,format=worddate20.);
%if not %length(&date) %then %let date="&sysdate9"D;
%if not %length(&format) %then %let format=worddate20.;
%sep2u(%nrbquote(%worddate(&date,format=&format)))
%mend worddateu;
/*<pre><b>
/ Program   : words.sas
/ Version   : 3.2
/ Author    : Roland Rashleigh-Berry
/ Date      : 09-Jan-2013
/ Purpose   : Function-style macro to return the number of words in a string
/ SubMacros : none
/ Notes     : You can change the delimiter to other than a space if required.
/ Usage     : %let words=%words(string);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               String (pos) UNQUOTED
/ delim=%str( )     Delimeter (defaults to a space)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  26Sep08         "countw" used for sas version 9 onwards for v2.0
/ rrb  01Sep09         Use of countw() function discontinued (v3.0)
/ rrb  04May11         Code tidy
/ rrb  02Jan13         Use of %qscan dropped (v3.1)
/ rrb  09Jan13         Use of %qscan reinstated (v3.2)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: words v3.2;

%macro words(str,delim=%str( ));
  %local i;
  %let i=1;
  %do %while(%length(%qscan(&str,&i,&delim)) GT 0);
    %let i=%eval(&i + 1);
  %end;
%eval(&i - 1)
%mend words;
/*<pre><b>
/ Program      : xl2sas.sas
/ Version      : 2.2
/ Author       : Roland Rashleigh-Berry
/ Date         : 26-Jun-2011
/ Purpose      : Read an Excel spreadsheet into a sas dataset using DDE
/ SubMacros    : none
/ Notes        : This is meant to be run interactively. The start and end rows
/                and columns you specify are those required to read the grid of
/                spreadsheet cells you are interested in. For columns, A=1, B=2,
/                etc.. Numeric integer values must be given for these. You must
/                have Excel for this to work. This was especially written for
/                Excel spreadsheets that are really html files such as those
/                written using "ods html file=xxx.xls;" as Excel can correctly
/                open these html files and treat them as normal spreadsheets and 
/                communicate the cell values through DDE.
/
/                This macro is also useful for XML imported into Excel and
/                difficult spreadsheet page contents where you have blocks of
/                information separated by space lines that SAS/Connect is
/                unable to interpret. If the start row and row length of these
/                blocks is variable then you can use this macro to read only
/                column 1 using dropblanklines=no and then the resulting dataset
/                will reveal the start and end rows of the blocks by the
/                observation number and then subsequent calls of this macro can
/                be used to read the blocks at the correct start and end rows.               
/
/                Note that because of rules for rendering html, double spaces in
/                cell values in the html spreadsheet file will, by default, be
/                compressed to single spaces unless the value is protected by
/                tags or the spaces are non-breaking spaces ("A0"x) or
/                compression disabled using compbl=no.
/
/ Usage        : %xl2sas(xlfile=C:\myfiles\My Spread Sheet.xls,sheetname=Sheet1,
/                        dsout=sasuser.myspread,compress=no,vpref=_col,vlen=50,
/                        startrow=5,startcol=1,endrow=95,endcol=10)
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ xlfile            (no quotes) Full path name of spreadsheet file (will accept
/                   file name with spaces).
/ sheetname         (no quotes) Name of spreadsheet sheet you want to read in.
/                   This will be visible as the bottom tag name when you open
/                   the spreadsheet in Excel (or you can use %xlsheets to write
/                   this list of sheet names to a global macro variable but
/                   you must remove the quotes added by the %xlsheets macro for
/                   sheet names containing spaces (use %dequote)).
/ secswait=2        Number of seconds to wait for the spreadsheet to open
/ dsout             Output dataset name (will default to the internal work
/                   dataset _xl2sas if you do not specify a value but you must
/                   not specify _xl2sas to this parameter as a dataset name)
/ compress=no       (no quotes) Set to "yes" to compress for all spaces. This
/                   will include the non-breaking space character "A0"x .
/                   Note this this action, if set to "yes", will effectively
/                   override the actions of compbl= and left= .
/ compbl=yes        (no quotes) By default, compress multiple spaces into single
/                   spaces. This will include the non-breaking space character
/                   "A0"x . Even if you set this to "no" then Excel itself will
/                   compress multiple spaces into single spaces unless the tags
/                   in the html file protect the values or the spaces are non-
/                   breaking spaces ("A0"x).
/ left=yes          (no quotes) By default, left-align fields by removing
/                   leading spaces. Leading spaces include the non-breaking
/                   space character "A0"x . Even if you set this to "no" then
/                   Excel itself will left-align text by dropping leading
/                   spaces unless the tags in the html file protect the values
/                   or the spaces are non-breaking spaces ("A0"x).
/ dropblanklines=yes (no quotes) By default, drop lines where all the values in
/                   the column range you specify are blank.
/ vpref=C           Prefix for the numbered variables created in the sas dataset
/ vlen=80           Length of the sas dataset variables (they are all character)
/ startrow=1        Start row to read cells from
/ startcol=1        Start column to read cells from
/ endrow            End row to read cells from
/ endcol            End column to read cells from
/ quit=yes          By default, close the spreadsheet file after reading the
/                   spreadsheet sheet.
/ closesheet=yes    By default, close the sheet after reading it
/ getnames=yes      By default, use what is in the first row read in for the
/                   variable names and their labels.
/ xlisopen=no       Set to yes if the Excel file is already open in Excel
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  31Aug10         Add quit= parameter and File.Close() and QUIT (v1.1)
/ rrb  16Dec10         %sysexec used in place of X command so you can use file
/                      names with spaces in them without any problem (v1.2)
/ rrb  21Dec10         Added getnames=yes so the variable names and their labels
/                      will be taken from the first row read and added
/                      closesheet=yes so the converse will allow leaving the
/                      sheet open after reading it (v2.0)
/ rrb  01Jan11         xlisopen= parameter added (v2.1)
/ rrb  04May11         Code tidy
/ rrb  26Jun11         Remove xlfile quotes if supplied (v2.2)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: xl2sas v2.2;

%macro xl2sas(xlfile=,
           sheetname=,
            secswait=2,
               dsout=,
            compress=no,
              compbl=yes,
                left=yes,
      dropblanklines=yes,
               vpref=C,
                vlen=80,
            startrow=1,
            startcol=1,
              endrow=,
              endcol=,
            getnames=yes,
                quit=yes,
          closesheet=yes,
            xlisopen=no
              );

  %local errflag err savopts maxvarnum;
  %let err=ERR%str(OR);
  %let errflag=0;
  %if %length(&xlfile) %then %let xlfile=%sysfunc(dequote(&xlfile));



      /*----------------------------------*
              Check input parameters
       *----------------------------------*/

  %if not %length(&xlisopen) %then %let xlisopen=no;
  %let xlisopen=%upcase(%substr(&xlisopen,1,1));

  %if not %length(&getnames) %then %let getnames=yes;
  %let getnames=%upcase(%substr(&getnames,1,1));

  %if not %length(&quit) %then %let quit=yes;
  %let quit=%upcase(%substr(&quit,1,1));

  %if not %length(&closesheet) %then %let closesheet=yes;
  %let closesheet=%upcase(%substr(&closesheet,1,1));

  %if &xlisopen NE Y %then %do;
    %if not %length(&xlfile) %then %do;
      %let errflag=1;
      %put &err: (xl2sas) No Excel spreadsheet file name supplied to xlfile=;
    %end;
    %else %do;
      %if not %sysfunc(fileexist(&xlfile)) %then %do;
        %let errflag=1;
        %put &err: (xl2sas) xlfile=&xlfile can not be found;
      %end;
    %end;
  %end;


  %if not %length(&sheetname) %then %do;
    %let errflag=1;
    %put &err: (xl2sas) No Excel spreadsheet sheet name supplied to sheetname=;
  %end;


  %if not %length(&secswait) %then %let secswait=2;
  %else %do;
    %if %length(%sysfunc(compress(&secswait,1234567890))) %then %do;
      %let errflag=1;
      %put &err: (xl2sas) An integer number of seconds is required. You specified secswait=&secswait;
    %end;
  %end;



  %if not %length(&compress) %then %let compress=no;
  %let compress=%upcase(%substr(&compress,1,1));


  %if not %length(&compbl) %then %let compbl=yes;
  %let compbl=%upcase(%substr(&compbl,1,1));


  %if not %length(&left) %then %let left=yes;
  %let left=%upcase(%substr(&left,1,1));


  %if not %length(&dropblanklines) %then %let dropblanklines=yes;
  %let dropblanklines=%upcase(%substr(&dropblanklines,1,1));


  %if not %length(&vpref) %then %let vpref=C;


  %if not %length(&vlen) %then %let vlen=80;


  %if not %length(&startrow) %then %let startrow=1;
  %else %do;
    %if %length(%sysfunc(compress(&startrow,1234567890))) %then %do;
      %let errflag=1;
      %put &err: (xl2sas) An integer is required. You specified startrow=&startrow;
    %end;
  %end;


  %if not %length(&startcol) %then %let startcol=1;
  %else %do;
    %if %length(%sysfunc(compress(&startcol,1234567890))) %then %do;
      %let errflag=1;
      %put &err: (xl2sas) An integer is required. You specified startcol=&startcol;
    %end;
  %end;


  %if not %length(&endrow) %then %do;
    %let errflag=1;
    %put &err: (xl2sas) No integer specified for endrow=;
  %end;
  %else %do;
    %if %length(%sysfunc(compress(&endrow,1234567890))) %then %do;
      %let errflag=1;
      %put &err: (xl2sas) An integer is required. You specified endrow=&endrow;
    %end;
  %end;


  %if not %length(&endcol) %then %do;
    %let errflag=1;
    %put &err: (xl2sas) No integer specified for endcol=;
  %end;
  %else %do;
    %if %length(%sysfunc(compress(&endcol,1234567890))) %then %do;
      %let errflag=1;
      %put &err: (xl2sas) An integer is required. You specified endcol=&endcol;
    %end;
  %end;


  %if &errflag %then %goto exit;



      /*---------------------------------*
              Store current options
       *---------------------------------*/

  %*- store current xwait and xsync settings -;
  %let savopts=%sysfunc(getoption(xwait,keyword)) %sysfunc(getoption(xsync,keyword)); 



      /*---------------------------------*
              Read the spreadsheet
       *---------------------------------*/

  %*- calculate highest numbered sas variable -;
  %let maxvarnum=%eval(&endcol-&startcol+1);


  *- set required options for dde to work correctly -;
  options noxwait noxsync;


  %if &xlisopen NE Y %then %do;

    *- start up Excel by opening the spreadsheet -;
    %sysexec "&xlfile";

    %if &secswait GT 0 %then %do;
      *- wait for Excel to finish starting up -;
      data _null_;
        x=sleep(&secswait);
      run;
    %end;

  %end;


  *- assign filerefs -;
  filename _xlin dde "Excel|&sheetname!R&startrow.C&startcol:R&endrow.C&endcol" lrecl=3000;
  filename _xlcmd dde 'Excel|system' lrecl=3000;


  *- Excel command to remove new-line characters -;
  data _null_;
    file _xlcmd;
    put "[error(FALSE)]";
    put "[FORMULA.REPLACE(""%sysfunc(byte(10))"","""",2,1,FALSE,FALSE)]" ;
  run;


  *- read in the spreadsheet page -;
  data _xl2sas;
    length &vpref.1-&vpref.&maxvarnum $ &vlen;
    infile _xlin dlm='09'x notab dsd pad missover;
    input &vpref.1-&vpref.&maxvarnum;
  run;


  *- close the spreadsheet sheet and optionally quit -;
  data _null_;
    file _xlcmd;
    %if &closesheet NE N %then %do;
      put "[File.Close()]";
    %end;
    %if &quit NE N %then %do;
      put '[QUIT]';
    %end;
  run;


  *- deassign filerefs -;
  filename _xlin clear;
  filename _xlcmd clear;



      /*---------------------------------*
                 Restore options
       *---------------------------------*/

  *- restore previous xwait and xsync settings -;
  options &savopts;



      /*---------------------------------*
                Edit the dataset
       *---------------------------------*/

  *- edit the fields and drop rows depending on options set -;
  %if "&compress" EQ "Y" or "&compbl" EQ "Y" or "&left" EQ "Y"
   or "&dropblanklines" EQ "Y" %then %do;
    data _xl2sas;
      retain accum "  ";
      set _xl2sas;
      array &vpref.ra {*} &vpref.1-&vpref.&maxvarnum;
      accum=" ";
      do i=1 to dim(&vpref.ra);
        %if "&compress" EQ "Y" or "&compbl" EQ "Y" or "&left" EQ "Y" %then %do;
          *- translate the non-breaking space into an ordinary space -;
          &vpref.ra(i)=translate(&vpref.ra(i)," ","A0"x);
        %end;
        %if "&compress" EQ "Y" %then %do;
          *- compress for all spaces -;
          &vpref.ra(i)=compress(&vpref.ra(i));
        %end;
        %else %do;
          %if "&compbl" EQ "Y" %then %do;
            *- compress for multiple blank spaces -;
            &vpref.ra(i)=compbl(&vpref.ra(i));
          %end;
          %if "&left" EQ "Y" %then %do;
            *- left-align field -;
            &vpref.ra(i)=left(&vpref.ra(i));
          %end;
        %end;
        accum=trim(left(accum))||trim(left(&vpref.ra(i)));
      end;
      %if "&dropblanklines" EQ "Y" %then %do;
        if accum ne " " then output;
      %end;
      drop i accum;
    run;
  %end;

      /*---------------------------------*
                Getnames processing
       *---------------------------------*/

  %if "&getnames" EQ "Y" %then %do;

    data _null_;
      length oddchars oldvar newvar tochars value $ 32 label $ 200;
      set _xl2sas(obs=1);
      array &vpref.ra {*} &vpref.1-&vpref.&maxvarnum;
      if _n_=1 then call execute('data _xl2sas;set _xl2sas(firstobs=2);rename');
      do i=1 to dim(&vpref.ra);
        oldvar=vname(&vpref.ra(i));
        value=vvalue(&vpref.ra(i));
        if missing(value) then value=oldvar;
        else do;
          link ren;
          call execute(' '||trim(oldvar)||"="||trim(newvar));
        end;
      end;
      call execute(";label");
      do i=1 to dim(&vpref.ra);
        oldvar=vname(&vpref.ra(i));
        label=vvalue(&vpref.ra(i));
        if not missing(label) then
          call execute(' '||trim(oldvar)||'="'||trim(left(label))||'"');
      end;
      call execute(";run;");
    return;
    ren:
      tochars=repeat("_",31);
      oddchars=compress(trim(value),
        "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
      newvar=left(translate(trim(value),tochars,oddchars));
    return;
    run;

  %end;



      /*---------------------------------*
                Tidy up and Exit
       *---------------------------------*/

  %if %length(&dsout) %then %do;

    data &dsout;
      set _xl2sas;
    run;

    proc datasets nolist memtype=data;
      delete _xl2sas;
      run;
    quit;

  %end;


  %goto skip;
  %exit: %put &err: (xl2sas) Leaving macro due to problem(s) listed;
  %skip:

%mend xl2sas;
/*<pre><b>
/ Program      : xlblocks.sas
/ Version      : 2.1
/ Author       : Roland Rashleigh-Berry
/ Date         : 15-Sep-2012
/ Purpose      : Read an Excel spreadsheet sheet containing blocks of
/                information using DDE with each block output as a numbered
/                dataset.
/ SubMacros    : %xl2sas %attrn %getvalue
/ Notes        : This is meant to be run interactively. The maximum end columns
/                and end rows you specify are those required to read the grid
/                of spreadsheet cells you are interested in, leaving at least
/                one completely blank column and one completely blank row
/                at the end. Numeric integer values must be given for these.
/                You must have Excel for this to work. This was especially
/                written for Excel spreadsheets that contain blocks of
/                information at different locations.
/
/                The different blocks must be separated from the other blocks
/                by blank columns or blank rows but they can touch at the
/                corners.
/
/                information in single separated cells will not be read.
/
/                Note that because of rules for rendering html, double spaces
/                in cell values in the html spreadsheet file will, by default,
/                be compressed to single spaces unless the value is protected
/                by tags or the spaces are non-breaking spaces ("A0"x) or
/                compression disabled using compbl=no.
/
/                By specifying readblocks=no you will just keep the blocks work
/                dataset _xlblocks (that is normally used to subsequently read
/                the blocks) plus the _xl2sas dataset (used to determine where
/                the blocks are). Using this option allows you to make changes
/                to the _xlblocks dataset to tailor the calls to %xl2sas for
/                each block number in a following step, depending on the
/                information given for each block. The variables kept in the 
/                _xlblocks dataset are as follows:
/                   Numeric variables:
/                   BLOCKNO: The block number (1,2,3,etc.)
/                   STARTROW, STARTCOL: Block start row and column
/                   ENDROW, ENDCOL:     Block end row and column          
/                   Character variables:
/                   GETNAMES: "no" or "yes" to get variable names and labels
/                             from the first row.
/                   DSNAME:   Low level name of the dataset to output
/                   OUTLIB:   Library to store the dataset in
/
/ Usage        : %xlblocks(xlfile=C:\myfiles\My Sheet.xls,sheetname=Sheet One,
/                       dspref=sasuser.myspread,compress=no,vpref=col,vlen=40);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ xlfile            (no quotes) Full path name of spreadsheet file (will accept
/                   file name with spaces).
/ sheetname         (no quotes) Name of spreadsheet sheet you want to read in.
/                   This will be visible as the bottom tag name when you open
/                   the spreadsheet in Excel (or you can use %xlsheets to write
/                   this list of sheet names to a global macro variable but
/                   you must remove the quotes added by the %xlsheets macro for
/                   sheet names containing spaces (use %dequote)).
/ secswait=2        Number of seconds to wait for the spreadsheet to open
/ dspref            Output dataset name prefix (no modifiers)
/ compress=no       (no quotes) Set to "yes" to compress for all spaces. This
/                   will include the non-breaking space character "A0"x .
/                   Note this this action, if set to "yes", will effectively
/                   override the actions of compbl= and left= .
/ compbl=yes        (no quotes) By default, compress multiple spaces into single
/                   spaces. This will include the non-breaking space character
/                   "A0"x . Even if you set this to "no" then Excel itself will
/                   compress multiple spaces into single spaces unless the tags
/                   in the html file protect the values or the spaces are non-
/                   breaking spaces ("A0"x).
/ left=yes          (no quotes) By default, left-align fields by removing
/                   leading spaces. Leading spaces include the non-breaking
/                   space character "A0"x . Even if you set this to "no" then
/                   Excel itself will left-align text by dropping leading
/                   spaces unless the tags in the html file protect the values
/                   or the spaces are non-breaking spaces ("A0"x).
/ vpref=C           Prefix for the numbered variables created in the sas dataset
/ vlen=80           Length of the sas dataset variables (they are all character)
/ maxcols=50        Maximum columns (must include a blank column at the end)
/ maxrows=3000      Maximum rows (must include a blank row at the end)
/ quit=yes          By default, close the spreadsheet file after reading the
/                   spreadsheet sheet.
/ closesheet=yes    By default, close the sheet after reading it
/ getnames=no       By default, do not use what is in the first row read in for
/                   the variable names and their labels.
/ outlib=work       Library to store the numbered block datasets in
/ readblocks=yes    By default, read the blocks once found. Set this to no to
/                   just keep the _xlblocks dataset for later processing.
/ probelen=8        Length of character variables when reading in the
/                   spreadsheet for the first time to determine where the blocks
/                   are (gets written to _xl2sas).
/ filtercode        Code to run against the _xlblocks dataset to change its
/                   values if need be. You might want to changes the value of
/                   getnames, for example, for some of the blocks.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/ rrb  26Jun11         Remove quotes from xlfile if supplied (v1.1)
/ rrb  24Sep11         Block detection logic completely changed (v2.0)
/ rrb  15Sep12         Call to %getvalue simplified for new version (v2.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/
 
%put MACRO CALLED: xlblocks v2.1;
 
%macro xlblocks(xlfile=,
             sheetname=,
              secswait=2,
                dspref=_xblock,
              compress=no,
                compbl=yes,
                  left=yes,
                 vpref=C,
                  vlen=80,
               maxcols=50,
               maxrows=3000,
              getnames=no,
                  quit=yes,
            closesheet=yes,
            readblocks=yes,
              probelen=8,
                outlib=WORK,
            filtercode=,
                 debug=no
                );

  %local errflag err i blocknobs startcol startrow endcol endrow savopts getn outl;
  %let err=ERR%str(OR);
  %let errflag=0;
  %if %length(&xlfile) %then %let xlfile=%sysfunc(dequote(&xlfile));


      /*----------------------------------*
              Check input parameters
       *----------------------------------*/

  %if not %length(&outlib) %then %let outlib=WORK;

  %if not %length(&probelen) %then %let probelen=8;
 
  %if not %length(&readblocks) %then %let readblocks=yes;
  %let readblocks=%upcase(%substr(&readblocks,1,1));

  %if not %length(&getnames) %then %let getnames=no;

  %if not %length(&debug) %then %let debug=no;
  %let debug=%upcase(%substr(&debug,1,1));

  %if not %length(&dspref) %then %let dspref=_xlblock;
 
  %if not %length(&quit) %then %let quit=yes;
  %let quit=%upcase(%substr(&quit,1,1));
 
  %if not %length(&closesheet) %then %let closesheet=yes;
  %let closesheet=%upcase(%substr(&closesheet,1,1));

  %if not %length(&compress) %then %let compress=no;
  %let compress=%upcase(%substr(&compress,1,1));
 
  %if not %length(&compbl) %then %let compbl=yes;
  %let compbl=%upcase(%substr(&compbl,1,1));
 
  %if not %length(&left) %then %let left=yes;
  %let left=%upcase(%substr(&left,1,1));
 
  %if not %length(&vpref) %then %let vpref=C;
 
  %if not %length(&vlen) %then %let vlen=80;



    %if not %length(&xlfile) %then %do;
      %let errflag=1;
      %put &err: (xlblocks) No Excel spreadsheet file name supplied to xlfile=;
    %end;
    %else %do;
      %if not %sysfunc(fileexist(&xlfile)) %then %do;
        %let errflag=1;
        %put &err: (xlblocks) xlfile=&xlfile can not be found;
      %end;
    %end;
 
    %if not %length(&sheetname) %then %do;
      %let errflag=1;
      %put &err: (xlblocks) No Excel spreadsheet sheet name supplied to sheetname=;
    %end;
 
    %if not %length(&secswait) %then %let secswait=2;
    %else %do;
      %if %length(%sysfunc(compress(&secswait,1234567890))) %then %do;
        %let errflag=1;
        %put &err: (xlblocks) An integer number of seconds is required. You specified secswait=&secswait;
      %end;
    %end;
 
    %if not %length(&maxrows) %then %let maxrows=1500;
    %else %do;
      %if %length(%sysfunc(compress(&maxrows,1234567890))) %then %do;
        %let errflag=1;
        %put &err: (xlblocks) An integer is required. You specified maxrows=&maxrows;
      %end;
    %end;
  
    %if not %length(&maxcols) %then %let maxcols=99;
    %else %do;
      %if %length(%sysfunc(compress(&maxcols,1234567890))) %then %do;
        %let errflag=1;
        %put &err: (xlblocks) An integer is required. You specified maxcols=&maxcols;
      %end;
    %end;



 
  %if &errflag %then %goto exit;


       /*---------------------------------*
              Store current options
       *---------------------------------*/


    %*- store current xwait and xsync settings -;
    %let savopts=%sysfunc(getoption(xwait,keyword)) %sysfunc(getoption(xsync,keyword)); 

    *- set required options for dde to work correctly -;
    options noxwait noxsync;



      /*---------------------------------*
              Open the spreadsheet
       *---------------------------------*/

    *- start up Excel by opening the spreadsheet -;
    %sysexec "&xlfile";

    %if &secswait GT 0 %then %do;
      *- wait for Excel to finish starting up -;
      data _null_;
        x=sleep(&secswait);
      run;
    %end;


 
      /*---------------------------------*
              Read the spreadsheet
       *---------------------------------*/

  %xl2sas(xlfile=&xlfile,sheetname=&sheetname,vpref=C,vlen=&probelen,
          startcol=1,endcol=&maxcols,startrow=1,endrow=&maxrows,dsout=,
          secswait=0,quit=no,closesheet=no,xlisopen=yes,compress=no,
          left=yes,compbl=yes,dropblanklines=no,getnames=no);



      /*---------------------------------*
                Find the blocks
       *---------------------------------*/

  data _xlblocks(keep=blockno outlib dsname getnames  
                      startrow startcol endrow endcol);
    length dsname $ 32 outlib $ 16 getnames $ 3;
    retain outlib "&OUTLIB" getnames "&getnames" blockno 0;
    array x{&maxcols,&maxrows} _temporary_;
    set _xl2sas end=last;
    array cra{*} c1-c&maxcols;
    *- fill up temporary array -;
    do i=1 to &maxcols;
      if not missing(cra(i)) then x{i,_n_}=1;
      else x{i,_n_}=0;
    end;
    *- look for blocks after temporary array is filled -;
    if last then do;
      link maxrow;
      link maxcol;
      link fillcorners;
      link delsingles;
      link getblocks;
      stop;
    end;
  return;

  maxrow:
  do row=&maxrows to 1 by -1;
    do col=1 to &maxcols;
      if x(col,row)=1 then do;
        maxrow=row;
        col=&maxcols;
        row=1;
      end;
    end;
  end;
  return;

  maxcol:
  do col=&maxcols to 1 by -1;
    do row=1 to maxrow;
      if x(col,row)=1 then do;
        maxcol=col;
        col=1;
        row=maxrow;
      end;
    end;
  end;
  return;

  fillcorners:
  gotone=1;
  do while(gotone);
    gotone=0;
    col=1;
    do row=1 to maxrow;
      if x(col,row)=0 and x(col+1,row)=1 then do;
        gotone=1;
        x(col,row)=1;
      end;
    end;
    do col=maxcol to 2 by -1;
      do row=1 to (maxrow-1);
        if x(col,row)=0 then do;
          if x(col,row+1)=1
          and x(col-1,row+1)=1
          and x(col-1,row)=1 then do;
            gotone=1;
            x(col,row)=1;
          end;
        end;
      end;
    end;
    do col=maxcol to 2 by -1;
      do row=2 to maxrow;
        if x(col,row)=0 then do;
          if x(col,row-1)=1
          and x(col-1,row-1)=1
          and x(col-1,row)=1 then do;
            gotone=1;
            x(col,row)=1;
          end;
        end;
      end;
    end;
    do col=(maxcol-1) to 1 by -1;
      do row=2 to maxrow;
        if x(col,row)=0 then do;
          if x(col,row-1)=1
          and x(col+1,row-1)=1
          and x(col+1,row)=1 then do;
            gotone=1;
            x(col,row)=1;
          end;
        end;
      end;
    end;
    row=maxrow;
    do col=1 to (maxcol-1);
      if x(col,row)=0 and x(col+1,row)=1 then do;
        gotone=1;
        x(col,row)=1;
      end;
    end;
  end; 
  return;

  delsingles:
    row=1;
    do col=1 to (maxcol-1);
      if x(col,row)=1 then do;
        if x(col,row+1)=0
        and x(col+1,row)=0
        then x(col,row)=0;
      end;
    end;
    do row=2 to (maxrow-1);
      do col=1 to (maxcol-1);
        if x(col,row)=1 then do;
          if x(col,row+1)=0
          and x(col,row-1)=0
          and x(col+1,row)=0
          then x(col,row)=0;
        end;
      end;
    end;
    row=maxrow;
    do col=1 to (maxcol-1);
      if x(col,row)=1 then do;
        if x(col+1,row)=0
        and x(col,row-1)=0
        then x(col,row)=0;
      end;
    end;
    col=maxcol;
    do row=2 to (maxrow-1);
       if x(col,row)=1 then do;
         if x(col-1,row)=0
         and x(col,row-1)=0
         and x(col,row+1)=0
         then x(col,row)=0;
       end;
    end;
    row=1;
    col=maxcol;
    if x(col,row)=1 then do;
      if x(col-1,row)=0
      and x(col,row+1)=0
      then x(col,row)=0;
    end;
    row=maxrow;
    if x(col,row)=1 then do;
      if x(col-1,row)=0
      and x(col,row-1)=0
      then x(col,row)=0;
    end;
  return;

  getblocks:
    gotblock=1;
    do while(gotblock);
      gotblock=0;
      startcol=0;
      endcol=0;
      startrow=0;
      endrow=0;
      do row=1 to maxrow;
        do col=1 to maxcol;
          if x(col,row)=1 then do;
            startrow=row;
            startcol=col;
            do col=startcol to maxcol;
              if x(col,row)=0 or col=maxcol then do;
                if col<maxcol then endcol=col-1;
                else endcol=maxcol;
                do row=startrow to maxrow;
                  if x(endcol,row)=0 or row=maxrow then do;
                    if row<maxrow then endrow=row-1;
                    else endrow=maxrow;
                    do col=startcol to endcol;
                      do row=startrow to endrow;
                        x(col,row)=0;
                      end;
                    end;
                    gotblock=1;
                    blockno=blockno+1;
                    dsname="&dspref"||compress(put(blockno,6.));
                    output;
                    row=maxrow;
                    col=maxcol;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  return;

  run;


 
      /*---------------------------------*
                Apply filtercode
       *---------------------------------*/
 
  %if %length(&filtercode) %then %do;
    data _xlblocks;
      set _xlblocks;
      &filtercode;
    run;
  %end;



      /*---------------------------------*
                 Read each block
       *---------------------------------*/

  %if &readblocks EQ Y %then %do;
    %let blocknobs=%attrn(_xlblocks,nobs);
    %do i=1 %to &blocknobs;
      %*- numeric variables -;
      %let startcol=%getvalue(_xlblocks,startcol,&i);
      %let startrow=%getvalue(_xlblocks,startrow,&i);
      %let endcol=%getvalue(_xlblocks,endcol,&i);
      %let endrow=%getvalue(_xlblocks,endrow,&i);
      %*- character variables -;
      %let getn=%getvalue(_xlblocks,getnames,&i);
      %let outl=%getvalue(_xlblocks,outlib,&i);
      %let dsname=%getvalue(_xlblocks,dsname,&i);
      %if &i EQ &blocknobs %then %do;
        %*- Use quit and closesheet parameter settings only in the last case   -;
        %xl2sas(xlfile=&xlfile,sheetname=&sheetname,vpref=&vpref,vlen=&vlen,
                startcol=&startcol,endcol=&endcol,startrow=&startrow,
                endrow=&endrow,secswait=0,quit=&quit,closesheet=&closesheet,
                compress=&compress,compbl=&compbl,left=&left,dsout=&outl..&dsname,
                dropblanklines=yes,getnames=&getn,xlisopen=yes);
      %end;
      %else %do;
        %xl2sas(xlfile=&xlfile,sheetname=&sheetname,vpref=&vpref,vlen=&vlen,
                startcol=&startcol,endcol=&endcol,startrow=&startrow,
                endrow=&endrow,secswait=0,quit=no,closesheet=no,
                compress=&compress,compbl=&compbl,left=&left,dsout=&outl..&dsname,
                dropblanklines=yes,getnames=&getn,xlisopen=yes);
      %end;
    %end;
  %end;



      /*---------------------------------*
                 Restore options
       *---------------------------------*/

  %if &debug NE Y %then %do;
    *- restore previous xwait and xsync settings -;
    options &savopts;
  %end;



      /*---------------------------------*
                Tidy up and Exit
       *---------------------------------*/

  %if &debug NE Y and &readblocks NE N %then %do;
    proc datasets nolist memtype=data;
      delete _xlblocks _xl2sas;
    run;
    quit;
  %end;

  %goto skip;
  %exit: %put &err: (xlblocks) Leaving macro due to problem(s) listed;
  %skip:
 
%mend xlblocks;
/*<pre><b>
/ Program      : xlsheets.sas
/ Version      : 2.1
/ Author       : Roland Rashleigh-Berry
/ Date         : 26-Jun-2011
/ Purpose      : Get a list of sheet names (topics) from an Excel spreadsheet
/                using DDE and write them to a global macro variable.
/ SubMacros    : none
/ Notes        : Sheet names containing spaces will be enclosed in double quotes
/                in the global macro variable. You must remove these double
/                quotes when using the %xl2sas macro as sheet names in quotes
/                are not accepted. Use the %dequote macro to do this. You can
/                extract each name in turn, whether quoted or not, using:
/                     %dequote(%scanq(&_xlsheets_,&i,%str( )))
/                and to count the number of sheet names to loop through use
/                %wordsq. Sheet names are returned in alphabetical order, rather
/                than sheet position order, due to the way "topics" are handled
/                by Excel.
/ Usage        : %xlsheets(C:\Mydata\Spread Sheet Name.xls);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ xlfile            (pos) (no quotes) Full path name of spreadsheet file (allows
/                   spaces in the file name).
/ secswait=2        Number of seconds to wait for the spreadsheet to open
/ mvar=_xlsheets_   Name of global macro variable to receive sheet names
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  16Dec10         Use %sysexec instead of X command to open file to allow
/                      for spaces in the file name (v1.1)
/ rrb  20Dec10         Write sheet names to a global macro variable instead of
/                      to a dataset (v2.0)
/ rrb  08May11         Code tidy
/ rrb  26Jun11         Remove xlfile quotes if supplied (v2.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: xlsheets v2.1;

%macro xlsheets(xlfile,
              secswait=2,
                  mvar=_xlsheets_
                );

  %local errflag err savopts;
  %let err=ERR%str(OR);
  %let errflag=0;
  %if %length(&xlfile) %then %let xlfile=%sysfunc(dequote(&xlfile));

  %if not %length(&mvar) %then %let mvar=_xlsheets_;

  %global &mvar;
  %let &mvar=;


      /*----------------------------------*
              Check input parameters
       *----------------------------------*/


  %if not %length(&xlfile) %then %do;
    %let errflag=1;
    %put &err: (xlsheets) No Excel spreadsheet file name supplied to xlfile=;
  %end;
  %else %do;
    %if not %sysfunc(fileexist(&xlfile)) %then %do;
      %let errflag=1;
      %put &err: (xlsheets) xlfile=&xlfile can not be found;
    %end;
  %end;



  %if not %length(&secswait) %then %let secswait=2;
  %else %do;
    %if %length(%sysfunc(compress(&secswait,1234567890))) %then %do;
      %let errflag=1;
      %put &err: (xlsheets) An integer number of seconds is required. You specified secswait=&secswait;
    %end;
  %end;

  %if &errflag %then %goto exit;



      /*---------------------------------*
              Store current options
       *---------------------------------*/

  %*- store current xwait and xsync settings -;
  %let savopts=%sysfunc(getoption(xwait,keyword)) %sysfunc(getoption(xsync,keyword)); 



      /*---------------------------------*
              Read the spreadsheet
       *---------------------------------*/


  *- set required options for dde to work correctly -;
  options noxwait noxsync;


  *- start up Excel by opening the spreadsheet -;
  %sysexec "&xlfile";


  *- wait for Excel to finish starting up -;
  data _null_;
    x=sleep(&secswait);
  run;


  *- assign filerefs -;
  filename _xlcmd dde 'Excel|system' lrecl=3000;
  filename _xltop dde 'Excel|system!topics' lrecl=3000;


  *- Excel command to remove new-line characters -;
  data _null_;
    file _xlcmd;
    put "[error(FALSE)]";
    put "[FORMULA.REPLACE(""%sysfunc(byte(10))"","""",2,1,FALSE,FALSE)]" ;
  run;


  *- read in the topics -;
  data _null_;
    length topic scan2 $ 1000 storetop $ 30000;
    retain storetop " ";
    infile _xltop dlm='09'x dsd pad notab;
    input topic $ @@;
    if _n_>1 then do;
      if index(topic,'[')=1 then do;
        scan2=scan(topic,2,']');
        if length(scan2) > length(compress(scan2,' '))
          then storetop=trim(storetop)||' "'||trim(scan2)||'"';
        else storetop=trim(storetop)||' '||scan2;
        call symput("&mvar",trim(left(storetop)));
      end;
    end;
  run;


  *- close the spreadsheet and quit -;
  data _null_;
    file _xlcmd;
    put "[File.Close()]";
    put '[QUIT]';
  run;


  *- deassign filerefs -;
  filename _xltop clear;
  filename _xlcmd clear;


      /*---------------------------------*
                 Restore options
       *---------------------------------*/

  *- restore previous xwait and xsync settings -;
  options &savopts;




      /*---------------------------------*
                       Exit
       *---------------------------------*/

  %goto skip;
  %exit: %put &err: (xlsheets) Leaving macro due to problem(s) listed;
  %skip:

%mend xlsheets;
/*<pre><b>
/ Program      : xpt2sas.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry
/ Date         : 02-Feb-2011
/ Purpose      : Convert all the .xpt files in a folder to sas datasets
/ SubMacros    : none
/ Notes        : Paths specified must end in a slash and must be enclosed in
/                double quotes. If the path name contains special characters
/                such as '&' or '%' then the double-quoted path name should be
/                enclosed in %nrstr( ) to stop sas trying to resolve these
/                symbols.
/
/                This was written for a Windows platform and uses the "dir" DOS
/                command to list the .xpt files.
/
/ Usage        : %xpt2sas(%nrstr("V:\SAS\Two Parts\X&Y\"),
/                         %nrstr("V:\SAS\Two Parts\X&Y\temp\"));
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ infolder          (pos) Full path name of input folder containing .xpt files
/                   (must end in a slash, must be enclosed in double quotes and
/                   if containing special characters such as "&" or "%" must
/                   also be enclosed by %nrstr( )  )
/ out               (pos) Either the full path name of the output folder for the
/                   created sas datasets (same naming rules as above) or an
/                   existing libref contained in round brackets such as (WORK)
/                   (no quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%macro xpt2sas(infolder,out);

  %local pipestr;
  %let pipestr=%str(%')dir &infolder.*.xpt%str(%');

  filename _inpipe pipe %unquote(&pipestr);
  libname _outsas &out;

  data _null_;
    retain inxpt &infolder;
    length xptname $ 40;
    infile _inpipe;
    input;
    if index(_infile_,".xpt") then do;
      xptname=scan(_infile_,countw(substr(_infile_,1,index(_infile_,".xpt"))," ")," ");
      call execute("libname _xptin xport %nrstr('"||trim(inxpt)||trim(xptname)||"');");
      call execute('proc copy in=_xptin out=_outsas;run;');
      call execute('libname _xptin clear;');
    end;
  run;

  filename _inpipe clear;
  libname _outsas clear;

%mend xpt2sas;
/*<pre><b>
/ Program   : yrcutoff.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To set the year cutoff option to a number of years previous to the
/             current year. 90 is the default which is suitable for clinical
/             reporting.
/ SubMacros : none
/ Notes     : none
/ Usage     : %yrcutoff
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ yearsago          (pos) Number of years ago to set yrcutoff option to. Will
/                   default to 90.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  28Sep08         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: yrcutoff v1.0;

%macro yrcutoff(yearsago);
  %if not %length(&yearsago) %then %let yearsago=90;
  options yearcutoff=%eval(%substr(&sysdate9,6)-&yearsago);
  %put NOTE: (yrcutoff) Year cutoff option has been changed to   %sysfunc(getoption(yearcutoff,keyword));
%mend yrcutoff;
/*<pre><b>
/ Program   : zerogrid.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry
/ Date      : 04-May-2011
/ Purpose   : To create a "grid" of combined values with a variable set to zero
/             for all combinations of values.
/ SubMacros : %commas
/ Notes     : Output sort order will be by supplied variable name if nothing is
/             specified.
/ Usage     : %zerogrid(dsout=grid,var1=subject,ds1=demog,var2=tmtarm,
/             ds2=demog,zerovar=count,sortby=tmtarm subject)
/             %zerogrid(zerovar=str,zero="  0 (  0.0)",var1=trtrand ddose,
/                       ds1=period1,var2=day,ds2=period1)
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dsout=zerogrid    Output dataset name (defaults to "zerogrid")
/ zero=0            By default, the zero setting is numeric 0
/ zerovar           Name of variable to receive zero setting for all obs
/ sortby            Variable list to sort output dataset by (defaults to
/                   supplied variable order)
/ var1              First variable(s) for extracting distinct values
/ ds1               Dataset source of first variable
/ var2              Second variable(s) for extracting distinct values
/ ds2               Dataset source of second variable
/ var3              Third variable(s) for extracting distinct values
/ ds3               Dataset source of third variable
/ var4              Fourth variable(s) for extracting distinct values
/ ds4               Dataset source of fourth variable
/ var5              Fifth variable(s) for extracting distinct values
/ ds5               Dataset source of fifth variable
/ (9 of these)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Apr05         Ability to change zero setting added
/ rrb  13Feb07         "macro called" message added
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%put MACRO CALLED: zerogrid v1.0;

%macro zerogrid(dsout=zerogrid,
               sortby=,
                 zero=0,
              zerovar=,
                 var1=,
                  ds1=,
                 var2=,
                  ds2=,
                 var3=,
                  ds3=,
                 var4=,
                  ds4=,
                 var5=,
                  ds5=,
                 var6=,
                  ds6=,
                 var7=,
                  ds7=,
                 var8=,
                  ds8=,
                 var9=,
                  ds9=,
                  ); 

  %local errflag i err;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&zero) %then %let zero=0;

  %if not %length(&dsout) %then %do;
    %let errflag=1;
    %put &err: (zerogrid) Output dataset dsout= not given a name;
  %end;

  %if not %length(&zerovar) %then %do;
    %let errflag=1;
    %put &err: (zerogrid) Zero value variable zerovar= not given a name;
  %end;

  %do i=1 %to 9;
    %if %length(&&var&i) and not %length(&&ds&i) %then %do;
      %let errflag=1;
      %put &err: (zerogrid) Variable name supplied as var&i=&&var&i but no ds&i=;
    %end;
    %if %length(&&ds&i) and not %length(&&var&i) %then %do;
      %let errflag=1;
      %put &err: (zerogrid) Dataset name supplied as ds&i=&&ds&i but no var&i=;
    %end;
  %end;

  %if &errflag %then %goto exit;

  %if not %length(&sortby) %then 
    %let sortby=&var1 &var2 &var3 &var4 &var5 &var6 &var7 &var8 &var9;


  proc sql noprint;
    create table &dsout as 
    select &zero as &zerovar, * from
    %if %length(&var1) and %length(&ds1) %then %do;
    (select distinct %commas(&var1) from &ds1)
    %end;
    %if %length(&var2) and %length(&ds2) %then %do;
    , (select distinct %commas(&var2) from &ds2)
    %end;
    %if %length(&var3) and %length(&ds3) %then %do;
    , (select distinct %commas(&var3) from &ds3)
    %end;
    %if %length(&var4) and %length(&ds4) %then %do;
    , (select distinct %commas(&var4) from &ds4)
    %end;
    %if %length(&var5) and %length(&ds5) %then %do;
    , (select distinct %commas(&var5) from &ds5)
    %end;
    %if %length(&var6) and %length(&ds6) %then %do;
    , (select distinct %commas(&var6) from &ds6)
    %end;
    %if %length(&var7) and %length(&ds7) %then %do;
    , (select distinct %commas(&var7) from &ds7)
    %end;
    %if %length(&var8) and %length(&ds8) %then %do;
    , (select distinct %commas(&var8) from &ds8)
    %end;
    %if %length(&var9) and %length(&ds9) %then %do;
    , (select distinct %commas(&var9) from &ds9)
    %end;
    order by %commas(&sortby);
  quit;

  %goto skip;
  %exit: %put &err: (zerogrid) Leaving macro due to problem(s) listed;
  %skip:

%mend zerogrid;
